(* Tagless staged interpreter *)
(* The language is simply typed lambda-calculus with booleans,
   and deBruin encoding of variables.
   The language is isomorphic to the one generated by the following
   datatype definition:
   type var = VZ | VS var
   type exp = V of var | B of bool | A of exp * exp | L of exp
*)


(* implementation *)
let id x = x;;

let b (bv:bool) env = fun f -> f .<bv>.;;
let varZ (vc,_) = fun f -> f vc;;
let varS vp (_,envr) = fun f -> vp envr f;;
let app e1 e2 env = fun f -> e1 env (fun e1v -> e2 env (fun e2v -> 
  f .<.~e1v .~e2v>.));;
let lam e env = fun f -> f .<fun x -> .~(e (.<x>.,env) id)>.;;

(* tests *)

let t1 = lam varZ;;
let t11 = lam varZ () id;;

let t2 = app (lam varZ) (b true) () id;;

let t3 = (lam (lam (varS varZ))) () id;;

let t4 = app (lam (lam (varS varZ))) (lam varZ) () id;;

let t5 = (app 
	    (app (lam (lam (app (app (varS varZ) (b true)) varZ)))
               (lam (lam varZ)))
	    (b false)) () id;;

(* the following are exprected errors *)
let t6 = (app 
	    (app (lam (lam (app (app (varS varZ) (b true)) varZ)))
               (lam varZ))
	    (b false)) () id;;

let t6' = (lam (app varZ varZ)) () id;;
