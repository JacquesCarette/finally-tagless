(* Tagless staged interpreter *)
(* The language is simply typed lambda-calculus with booleans,
   and deBruin encoding of variables.
   The language is isomorphic to the one generated by the following
   datatype definition:
   type var = VZ | VS var
   type exp = V of var | A of exp * exp | L of exp |
              B of bool | I of int
*)


(* implementation *)
(* base *)
let varZ (vc,_) = vc;;
let varS vp (_,envr) = vp envr;;
let app e1 e2 env = .<.~(e1 env) .~(e2 env)>.;;
let lam e env = .<fun x -> .~(e (.<x>.,env))>.;;

(* extensions *)
(* booleans *)
let b (bv:bool) env = .<bv>.;;
let band b1 b2 env = .<b1 && b2>. ;;
let bor b1 b2 env = .<b1 || b2>. ;;
let bnot b1 env = .<not b1 >. ;;

(* integers *)
let i (i:int) env = .<i>.;;
let (++) i j env = .< i + j >. ;;
let ( ** ) i j env = .< i * j >. ;;
let ( -- ) i j env = .< i - j >. ;;
let ( // ) i j env = .< i / j >. ;;

(* pairs *)
let p a b env = .< (a, b) >. ;;
let pfst p env = .< fst p >. ;;
let psnd p env = .< snd p >. ;;

(* references *)
let rref a env = .< ref a>. ;;
let (!!) a env = .< !a >. ;;
let ( := ) aref b = .< aref := b >. ;;

(* sequencing *)
let seq a b env = .< (a ; b) >. ;;

(* even let ! However, note how the 2nd part is a code-to-code function
    which kind of ruins the symmetry of things... *)
let nlet v f env = .< let x = .~(v env) in .~(f .<x>.) >. ;;
(* we can have this too, but it isn't much better! *)
let nlet2 v f env = .< let x = .~(v env) in .~f x >. ;;

(* tests *)
let t1 = lam varZ;;
let t11 = lam varZ ();;

let t2 = app (lam varZ) (b true) ();;

let t3 = (lam (lam (varS varZ))) ();;

let t4 = app (lam (lam (varS varZ))) (lam varZ) ();;

let t5 = (app 
	    (app (lam (lam (app (app (varS varZ) (b true)) varZ)))
               (lam (lam varZ)))
	    (b false)) ();;

(* the following are exprected errors *)
(* and are commented out for testing 
let t6 = (app 
	    (app (lam (lam (app (app (varS varZ) (b true)) varZ)))
               (lam varZ))
	    (b false)) ();;

let t6' = (lam (app varZ varZ)) ();; *)

(* a few new tests *)
let t7 = (5 ++ 6) () ;;
let t8 = nlet ((5 ++ 6) ) (fun x -> .<.~x *3>. ) ();;
