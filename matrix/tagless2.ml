(* Tagless staged interpreter *)
(* The language is simply typed lambda-calculus with booleans,
   and deBruin encoding of variables.
   The language is isomorphic to the one generated by the following
   datatype definition:
   type var = VZ | VS var
   type exp = V of var | B of bool | A of exp * exp | L of exp
*)


(* implementation *)
let b (bv:bool) env = .<bv>.;;
let varZ (vc,_) = vc;;
let varS vp (_,envr) = vp envr;;
let app e1 e2 env = .<.~(e1 env) .~(e2 env)>.;;
let lam e env = .<fun x -> .~(e (.<x>.,env))>.;;

(* tests *)

let t1 = lam varZ;;
let t11 = lam varZ ();;

let t2 = app (lam varZ) (b true) ();;

let t3 = (lam (lam (varS varZ))) ();;

let t4 = app (lam (lam (varS varZ))) (lam varZ) ();;

let t5 = (app 
	    (app (lam (lam (app (app (varS varZ) (b true)) varZ)))
               (lam (lam varZ)))
	    (b false)) ();;

(* the following are exprected errors *)
let t6 = (app 
	    (app (lam (lam (app (app (varS varZ) (b true)) varZ)))
               (lam varZ))
	    (b false)) ();;

let t6' = (lam (app varZ varZ)) ();;
