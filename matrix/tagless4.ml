(* Tagless staged partial evaluation *)
(* The language is simply typed lambda-calculus with booleans,
   and deBruin encoding of variables.
   The language is isomorphic to the one generated by the following
   datatype definition:
   type var = VZ | VS var
   type exp = V of var | A of exp * exp | L of exp |
              B of bool | I of int
*)

type ('e,'d,'s) vrep
    = ('e,'d) code * 's option;;
type ('e,'d,'s) crep
    = { eval: 'w. (('e,'d,'s) vrep -> ('e,'w) code) -> ('e,'w) code };;

(* implementation *)

(* base *)
(* literals and pure functions *)
let pureZ (v: ('e,'d,'s) vrep) (env: 'r)
    : ('e,'d,'s) crep
    = { eval = fun k -> k v };;
let pureS (pure: ('e,'b) code * 'b option -> 'r -> ('e,'d,'s) crep)
          ((d: ('e, 'a -> 'b) code), (s: ('a -> 'b) option))
          (env: 'r)
    : ('e, 'a -> 'b, ('e,'a,'a) vrep -> ('e,'d,'s) crep) crep
    = { eval = fun k -> k (d, Some (fun x -> match s, x with
        | Some f, (_, Some x) -> let r = f x in pure (.<r>., Some r) env
        | _, (x, _) -> pure (.<.~d .~x>., None) env)) };;
let literal x = (.<x>., Some x);;
let lit x = pureZ (literal x);;
let unary f = pureS pureZ (literal f);;
let binary f = pureS (pureS pureZ) (literal f);;

(* variables *)
let varZ ((vc: ('e,'d,'s) vrep), _)
    : ('e,'d,'s) crep
    = { eval = fun k -> k vc };;
let varS (vp: 'r -> ('e,'d,'s) crep) ((_: (_,_,_) vrep), (envr: 'r))
    : ('e,'d,'s) crep
    = vp envr;;

(* combinations *)
let app (e1: 'r -> ('e, 'd1->'d2, ('e,'d1,'s1) vrep -> ('e,'d2,'s2) crep) crep)
        (e2: 'r -> ('e, 'd1, 's1) crep)
        (env: 'r)
    : ('e,'d2,'s2) crep
    = { eval = fun k -> (e1 env).eval (fun f ->
                        (e2 env).eval (fun x -> match f with
                        | (_, Some f) -> (f x).eval k
                        | (f, None) -> .<let r = .~f .~(fst x) in
                                         .~(k (.<r>., None))>.)) };;
let lam (e: ('e,'d1,'s1) vrep * 'r -> ('e,'d2,'s2) crep) (env: 'r)
    : ('e, 'd1 -> 'd2, ('e,'d1,'s1) vrep -> ('e,'d2,'s2) crep) crep
    = { eval = fun k -> k ( .<fun x -> .~((e ((.<x>., None), env)).eval fst)>.,
                            Some (fun x -> e (x, env)) ) };;
let iif (e0: 'r -> ('e,bool,bool) crep)
        (e1: 'r -> ('e,'d,'s) crep)
        (e2: 'r -> ('e,'d,'s) crep)
        (env: 'r)
    : ('e,'d,'s) crep
    = { eval = fun k -> (e0 env).eval (function
        | (_, Some b) -> ((if b then e1 else e2) env).eval k
        | (b, None) -> .<if .~b then .~((e1 env).eval k)
                                else .~((e2 env).eval k)>.) };;

(* extensions *)
(* booleans *)
let band b1 b2 = iif b1 b2 (lit false);;
let bor  b1 b2 = iif b1 (lit true) b2 ;;
let bnot env = unary not env;;

(* integers *)
let ( ++ ) env = binary ( + ) env;;
let ( ** ) env = binary ( * ) env;;
let ( -- ) env = binary ( - ) env;;
let ( // ) env = binary ( / ) env;;

(* pairs *)
let p env = binary (fun x y -> (x,y)) env;;
let pfst env = unary fst env;;
let psnd env = unary snd env;;

(* references *)
let rref env = unary ref env;;
let (!!) env = unary (fun r -> !r) env;;
let (=:) env = binary (:=) env;;

(* sequencing *)
let seq env = binary (fun a b -> b) env;;

(* even let! *)
let nlet v f = app (lam f) v;;

(* tests *)
(* --to evaluate, say something like: .! ((t1 ()).eval fst) *)
let t1 env = lam varZ env;;

let t2 env = app (lam varZ) (lit true) env;;

let t3 env = (lam (lam (varS varZ))) env;;

let t4 env = app (lam (lam (varS varZ))) (lam varZ) env;;

let t5 env = (app (app (lam (lam (app (app (varS varZ) (lit true)) varZ)))
                       (lam (lam varZ)))
	          (lit false)) env;;

(* the following are expected errors *)
(* and are commented out for testing 
let t6 env = (app (app (lam (lam (app (app (varS varZ) (lit true)) varZ)))
                       (lam varZ))
	          (lit false)) env;;

let t6' env = (lam (app varZ varZ)) env;; *)

(* a few new tests *)
let t7 env = app (app (++) (lit 5)) (lit 6) env;;
let t8 env = nlet (app (app (++) (lit 5)) (lit 6))
                  (app (app ( ** ) varZ) (lit 3)) env;;

(* test that side effects are not repeated *)
let t9 env = lam (lam (nlet (app (varS varZ) varZ)
                            (app (app (++) varZ) varZ))) env;;

