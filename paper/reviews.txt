Paper: 29
Title: Multi-stage programming with functors and monads: eliminating
abstraction overhead

-------------------- review 98 --------------------
 
OVERALL RATING: 3 (strong accept) 
CONFIDENCE: 4 (expert)  
----------------------- REVIEW --------------------

The aim of multi-stage programming is to support programming
abstractions without paying an extra runtime cost.
Ideally, the programmer should be able to easily transform a generic
program into a program generator, and the generator should produce
efficient code where the abstractions have been eliminated.
Unfortunately there are many applications where this is not
possible, and the generator has to be written in a substantially
different way in order to obtain the desired result. Typically,
the generator writer uses techniques like CPS transformations,
which are very cumbersome to compose.

This paper advocates the use of monadic programming to encapsulate
the details of these transformations. The immediate advantage of
this approach is that the `weaving` of the various transformations
is done automatically by the high-level monadic operations.
A new syntax is introduced to make it easier for the programmer
to write in monadic style, borrowing ideas from Haskell's notation.
While this notation certainly helps, I have the impression that it
ought to be possible to use a more intuitive notation based on annotations
on the original source code. For example, it is conceivable, although
not straightforward, that annotations on let expressions would allow
to automatically generate the appropriate monadic code for binding.

The paper is written is a very clear style. I liked the choice of Gaussian
elimination to illustrate the issues and describe the ideas behind the
proposed solution.

In summary, this is an important contribution towards making generator
writing available to the everyday programmer.

Minor comments:
p.3: "Figure 2 shows" --> "Figure 1 shows"

section 3: the initial discussion about aspects, functors, and
parameterization is very clear, but the details about the implementation
are somehow blurred and difficult to understand. 


-------------------- review 60 --------------------
 
OVERALL RATING: 2 (accept) 
CONFIDENCE: 2 (medium)  
----------------------- REVIEW --------------------

This paper reports how to improve the code generator in
(MetaOCaml) with monads and module system to completely eliminate the
abstraction overhead of generated numerical algorithms.
The main contributions of this paper are:
1. It extends the monad used in "A Methodology for Generating Verified
Combinatorial Circuits" by introducing condition and loop code
generator as new instance of the monad. They also implement a
mdo-notation similar to the do-notation used in Haskell, which gives
the generator code an imperative appearance. This will make the CPS
code (necessary for big multistage programs) easier to read and write
for programmer's familiar with imperative languages.
2. It introduces OCaml's module system and functors to overload the
code generator with different domain, outputs. This technique makes
multi-stage programming more scalable by introducing modular design.

------------------------

The techniques in this paper are valuable for multi-stage programming
 by making it more user friendly. The propose of
using functor to solve the modularity problems of  multi-stage
programming is novel. The paper is self-contained and
technically correct. Thus, I would recommend to accept the paper.

The presentation of the paper could be improved. For example, it would be
better to break down some large code pieces, so that the explanation and
the code can stay together.

----------------------
Suggestions:
In Figure 2, the monad has type signature "('v,'s,'w) monad". It will
trick the reader to think it is a monad of type ('v,'s,'w) while in
fact it is a monad of type 'v according to the "ret" and "bind"
definition. It can be made more clear by adding type signatures to
"ret" and "bind" functions and explaining in the text.

It would be interesting to see how much of the overhead is removed by
the techniques proposed by this paper with a performance comparison
between the GE codes generated by the code generator with and without
using techniques.
----------------------
Typos:
Page 3, section 2: "Figure 2" should be Figure 1. 


-------------------- review 146 --------------------
 
OVERALL RATING: 2 (accept) 
CONFIDENCE: 2 (medium)  
----------------------- REVIEW --------------------

This is paper addressing an interesting topic. Generative programming
by multi-stage programming with functors and monads is described.
They use Gaussian Elimination as a running example and demonstrate the
safe code generation with combination of various aspects provided by
user.  The generated code has no run time overhead and is guaranteed
to be well-typed owing to the mechanism of MetaOCaml.  The high
modularity of this approach much owes to separation of problems and
``good glue'' (combination of state and continuation monad and staged
higher-order functions (combinators) that are provided by authors, and
functors) to combine the solutions for them.  The concept behind this
paper is reasonable and interesting.  These are not merely a picture,
but it is accompanied with the actual implementation in the author's
web site.

* Detailed Comments 

The first contribution they raise is the extension of monad from [17].
This extension is natural and reasonable, and the application of the
new control structures are much wider.  It is essential to generate a
program which shares the common subexpressions in a modular way.  But,
the progress is not such a big step, since the original idea of weaving
code by continuations is already described before.

The name ``mdo'' for do-notation might cause wrong guess, since the
mdo-notation is used as recursive do-notation in Haskell.  It would be
helpful if you write that mdo-notation excludes monadic fixpoints
explicitly (, although it is mentioned in Chap4).  Or it is recursive,
and this paper does not use such property?  The mdo-notation is good
interface to use monad in imperative style.

As mentioned in the paper, a complex monad can be made up from basic
monads with a monad transformer.  The monad `` ('v,'s,'w) monad '' is,
however, made up from scratch in this paper.  To keep track of logs
and handle errors, users of your library may well want to add these
functionality to your monad.  Though I am not sure whether it is
possible, is it reasonable to provide the monad as monad transformer?

To reveal the impossible compositions statically, they use type
sharing constraint which expresses domain-specific knowledge.  They
show that in MetaOCaml this mechanism can be realized without
difficulty.

I only have vague understanding of the codes in Appendices.  Of
course, users of this library do not need to read these codes, since
any post-processing is neither allowed nor necessary.  But, I would
like to have intentional guide for quick check to have feeling that it
certainly works.

* Supplemental Comments

Is it all right?
  pp.8 l.11  These are separated out from the others [and/are] they are ...

References following Figure point elsewhere:
  pp.3 l.22  Figure 2 => Figure 1
  pp.8 l.17  Fig. 2   => Figure 1

Small typos in References:
  [17]  pages are missing -- FIXED
  [24]  the font of "http://haskell.org/" -- FIXED

  [27]  probably brace brackets are missing for "cbn", "or" and "metaml" 
        (in LaTeX source code) -- FIXED
  

-----
Please use a smaller font for the appendix to stay
within the page limit.

-----

The authors may want to consider the previous work done on the
automatic staging of mathematical algorithms. Related work, beside MetaOCaml,
is also MetaScheme, a target language for automatic or manual staging.

[1] Gluck, Nakashige, Zochling. Binding-time analysis applied to mathematical 
algorithms. In Dolezal, Fidler. System Modelling and Optimization, 1995.

Note: the algorithms do not include matrix operations.
We should mention that our specialzied codes may have different types
(that is not the case above). They try do discover opportunities
for specialization in a very general program with lots of
abstractions; We, OTH, don't produce abstraction overhead; some of our
abstraction elimination are very long-correlated (treatment of
determinant). Things like switching from full pivoting to no pivoting
cannot be discovered by PE.
\cite{Gluck95}

[2]  Gluck, Jorgensen. Multi-level specialization, LNCS 1706, 1999
\cite{GluckJ98}
---
Cite the manuscript:

	http://www.cs.rice.edu/~taha/publications/preprints/2004-02-16.pdf

as \cite{MSP:PADL04}



========================================================================
	To fix


Rev1: ``I have the impression that it ought to be possible to use a
more intuitive notation based on annotations on the original source
code. For example, it is conceivable, although not straightforward,
that annotations on let expressions would allow to automatically
generate the appropriate monadic code for binding.''
To future work: we're working on this

Rev1: ``section 3: the initial discussion about aspects, functors, and
parameterization is very clear, but the details about the implementation
are somehow blurred and difficult to understand.''
We're out of space!


Rev2: ''it would be better to break down some large code pieces, so
that the explanation and the code can stay together.''

Rev2: ``In Figure 2, the monad has type signature "('v,'s,'w) monad". It will
trick the reader to think it is a monad of type ('v,'s,'w) while in
fact it is a monad of type 'v according to the "ret" and "bind"
definition. It can be made more clear by adding type signatures to
"ret" and "bind" functions and explaining in the text.''

Performance comparison. Do we have space for that?
Perhaps only mention in the presentation, and refer to the web site?

The name ``mdo''...


``I only have vague understanding of the codes in Appendices.  Of
course, users of this library do not need to read these codes, since
any post-processing is neither allowed nor necessary.  But, I would
like to have intentional guide for quick check to have feeling that it
certainly works.''

