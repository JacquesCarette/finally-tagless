@STRING{j_acmcs			= "{ACM} Computing Surveys" }
@STRING{j_hosc			= "Higher-Order and Symbolic Computation" }
@STRING{j_jacm			= "Journal of the {ACM}" }
@STRING{j_jfp			= "Journal of Functional Programming" }
@STRING{proc_icfp_1		= "{ICFP} '" }
@STRING{proc_icfp_2		= ": Proceedings of the {ACM} International Conference on Functional Programming" }
@STRING{proc_popl_1		= "{POPL} '" }
@STRING{proc_popl_2		= ": Conference Record of the Annual {ACM} Symposium on Principles of Programming Languages" }
@STRING{pub_acm			= "{ACM} {P}ress" }
@STRING{pub_acm_addr		= "{N}ew {Y}ork" }
@STRING{pub_sv			= "Springer-Verlag" }
@STRING{pub_sv_addr		= "Berlin" }
@STRING{s_lncs			= "{L}ecture {N}otes in {C}omputer {S}cience" }

@inproceedings{WalidICFP02,
  author	= "Emir Pa{\v s}ali{\'c} and Walid Taha and Tim Sheard",
  title		= "Tagless Staged Interpreters for Typed Languages",
  pages		= "157--166",
  crossref	= "icfp2002",
  url		= "http://www.cs.rice.edu/~taha/publications/conference/icfp02.dvi http://www.cs.rice.edu/~taha/publications/conference/icfp02.ps http://www.cs.rice.edu/~taha/publications/conference/icfp02.pdf"
}

@Article{	hudak-building,
  author	= {Paul Hudak},
  title		= {Building Domain-Specific Embedded Languages},
  journal	= j_acmcs,
  year		= 1996,
  month		= dec,
  volume	= 28,
  number	= {4es},
  pages		= 196
}

@InProceedings{	xi-guarded,
  author	= "Hongwei Xi and Chiyan Chen and Gang Chen",
  title		= "Guarded Recursive Datatype Constructors",
  pages		= "224--235",
  crossref	= "popl2003",
  url		= "http://www.cs.bu.edu/~hwxi/academic/papers/popl03.pdf http://www.cs.bu.edu/~hwxi/academic/papers/popl03.ps http://www.cs.bu.edu/~hwxi/academic/talks/popl03.ppt"
}

@inproceedings{WalidPOPL03,
  author    = {Walid Taha and Michael Florentin Nielsen},
  title     = {Environment Classifiers},
  pages     = {26--37},
  crossref  = "popl2003",
  url       = "http://www.cs.rice.edu/~taha/publications/conference/popl03.dvi http://www.cs.rice.edu/~taha/publications/conference/popl03.ps http://www.cs.rice.edu/~taha/publications/conference/popl03.pdf"
}

@InProceedings{	baars-typing,
  author	= "Arthur I. Baars and S. Doaitse Swierstra",
  title		= "Typing Dynamic Typing",
  pages		= "157--166",
  crossref	= "icfp2002",
  url		= "http://www.cs.uu.nl/~arthurb/data/Dynamic/p189-baars.pdf http://www.cs.uu.nl/~arthurb/data/Dynamic/Talk.pdf http://www.cs.uu.nl/~arthurb/dynamic.html",
  abstract	= "Even when programming in a statically typed language we every now and then encounter statically untypable values; such values result from interpreting values or from communicating with the outside world. To cope with this
		  problem most languages include some form of \emph{dynamic} types. It may be that the core language has been explicitly extended with such a type, or that one is allowed to live dangerously by using functions like
		  \emph{unsafeCoerce}. We show how, by a careful use of existentially and universally quantified types, one may achieve the same effect, without extending the language with new or unsafe features. The techniques explained
		  are universally applicable, provided the core language is expressive enough; this is the case for the common implementations of Haskell. The techniques are used in the description of a type checking compiler that, starting
		  from an expression term, constructs a typed function representing the semantics of that expression. In this function the overhead associated with the type checking is only once being paid for; in this sense we have thus
		  achieved static type checking."
}

@InProceedings{	taha-tag,
  author	= {Walid Taha and Henning Makholm and John Hughes},
  title		= {Tag Elimination and {J}ones-Optimality},
  pages		= {257--275},
  crossref	= {pado2001},
  url		= "http://www.cs.rice.edu/~taha/publications/conference/padoII.dvi http://www.cs.rice.edu/~taha/publications/conference/padoII.ps http://www.cs.rice.edu/~taha/publications/conference/padoII.pdf"
}

@InProceedings{	peyton-jones-simple,
  author	= "Peyton Jones, Simon L. and Dimitrios Vytiniotis and Stephanie Weirich and Geoffrey Washburn",
  title		= "Simple Unification-Based Type Inference for {GADT}s",
  pages		= "50--61",
  crossref	= "icfp2006",
  url		= "http://research.microsoft.com/~simonpj/papers/gadt/"
}

@InProceedings{	fogarty-concoqtion,
  author	= "Seth Fogarty and Emir Pasalic and Jeremy Siek and Walid Taha",
  title		= "{C}oncoqtion: Indexed Types Now!",
  crossref	= "pepm2007",
  url		= "http://www.cs.rice.edu/~taha/publications/conference/pepm07b.pdf"
}

@misc{metaocaml,
  key = {metaocaml},
  note = {\url{http://www.metaocaml.org}}
}

@inproceedings{NanevskiICFP02,
  author    = {Aleksandar Nanevski},
  title     = {Meta-programming with Names and Necessity},
  pages     = {206--217},
  crossref  = "icfp2002"
}

@article{NanevskiJFP05,
  author    = {Aleksandar Nanevski and
               Frank Pfenning},
  title     = {Staged Computation with Names and Necessity},
  journal   = j_jfp,
  volume    = {15},
  number    = {6},
  year      = {2005},
  pages     = {893-939},
  ee        = {http://dx.doi.org/10.1017/S095679680500568X},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  url = "http://www.eecs.harvard.edu/~aleks/papers/necessity/jfpnames02.ps"
}

@article{DaviesJACM01,
  author    = {Rowan Davies and
               Frank Pfenning},
  title     = {A Modal Analysis of Staged Computation},
  journal   = j_jacm,
  volume    = {48},
  number    = {3},
  year      = {2001},
  pages     = {555-604},
  ee        = {http://doi.acm.org/10.1145/382780.382785},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@Article{	nanevski-contextual,
  author	= "Aleksandar Nanevski and Frank Pfenning and Brigitte Pientka",
  title		= "Contextual Modal Type Theory",
  journal	= "Transactions on Computational Logic",
  year		= 2007,
  note		= "To appear",
  url		= "http://www.cs.cmu.edu/~fp/papers/tocl07.pdf",
  annote	= "Frank Pfenning's talk \cite{pfenning-contexts-talk}"
}

@InProceedings{	reynolds-definitional-notes,
  author	= "John C. Reynolds",
  title		= "Definitional Interpreters for Higher-Order Programming Languages",
  pages		= "717--740",
  crossref	= "acm1972",
  note		= "Reprinted as \cite{reynolds-definitional}",
  volume	= 2,
  abstract	= "Higher-order programming languages (i.e., languages in which procedures or labels can occur as values) are usually defined by interpreters which are themselves written in a programming language based on the lambda
		  calculus (i.e., an applicative language such as pure LISP). Examples include McCarthy's definition of LISP, Landin's SECD machine, the Vienna definition of PL/I, Reynolds' definitions of GEDANKEN, and recent unpublished
		  work by L. Morris and C. Wadsworth. Such definitions can be classified according to whether the interpreter contains higher-order functions, and whether the order of application (i.e., call-by-value versus call-by-name) in
		  the defined language depends upon the order of application in the defining language. As an example, we consider the definition of a simple applicative programming language by means of an interpreter written in a similar
		  language. Definitions in each of the above classifications are derived from one another by informal but constructive methods. The treatment of imperative features such as jumps and assignment is also discussed."
}

@Article{	reynolds-definitional,
  author	= "John C. Reynolds",
  title		= "Definitional Interpreters for Higher-Order Programming Languages",
  journal	= j_hosc,
  year		= 1998,
  volume	= 11,
  number	= 4,
  pages		= "363--397",
  url		= "ftp://ftp.cs.cmu.edu/user/jcr/defint.ps.gz",
  abstract	= "Higher-order programming languages (i.e., languages in which procedures or labels can occur as values) are usually defined by interpreters that are themselves written in a programming language based on the lambda calculus
		  (i.e., an applicative language such as pure LISP). Examples include McCarthy's definition of LISP, Landin's SECD machine, the Vienna definition of PL/I, Reynolds' definitions of GEDANKEN, and recent unpublished work by L.
		  Morris and C. Wadsworth. Such definitions can be classified according to whether the interpreter contains higher-order functions, and whether the order of application (i.e., call by value versus call by name) in the
		  defined language depends upon the order of application in the defining language. As an example, we consider the definition of a simple applicative programming language by means of an interpreter written in a similar
		  language. Definitions in each of the above classifications are derived from one another by informal but constructive methods. The treatment of imperative features such as jumps and assignment is also discussed.",
  keywords	= "programming language, language definition, interpreter, lambda calculus, applicative language, higher-order function, closure, order of application, continuation, LISP, GEDANKEN, PAL, SECD machine, J-operator, reference"
}

@Proceedings{	acm1972,
  key		= "{\relax ACM}",
  title		= "Proceedings of the {ACM} National Conference",
  booktitle	= "Proceedings of the {ACM} National Conference",
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 1972,
  location	= "Boston"
}

@Proceedings{	icfp2002,
  key		= "{\relax ICFP}",
  title		= proc_icfp_1 # "02"  # proc_icfp_2,
  booktitle	= proc_icfp_1 # "02"  # proc_icfp_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 2002,
  location	= "Pittsburgh, PA"
}

@Proceedings{	icfp2006,
  key		= "{\relax ICFP}",
  title		= proc_icfp_1 # "06"  # proc_icfp_2,
  booktitle	= proc_icfp_1 # "06"  # proc_icfp_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 2006,
  location	= "Portland, OR"
}

@Proceedings{	popl2003,
  key		= "{\relax POPL}",
  title		= proc_popl_1 # "03"  # proc_popl_2,
  booktitle	= proc_popl_1 # "03"  # proc_popl_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 2003,
  isbn		= {1-58113-628-5},
  issn		= "0730-8566",
  location	= {New Orleans}
}

@Proceedings{	pado2001,
  editor	= {Olivier Danvy and Andrzej Filinski},
  title		= {Proceedings of {PADO} 2001: 2nd Symposium on Programs as Data Objects},
  booktitle	= {Proceedings of {PADO} 2001: 2nd Symposium on Programs as Data Objects},
  address	= pub_sv_addr,
  publisher	= pub_sv,
  year		= 2001,
  month		= "21--23 "  # may,
  number	= 2053,
  series	= s_lncs,
  isbn		= {3-540-42068-1},
  location	= "Aarhus, Denmark"
}

@Proceedings{	pepm2007,
  key		= "{\relax ACM}",
  title		= "Proceedings of the 2007 {ACM} {SIG{\-}PLAN} Workshop on Partial Evaluation and Semantics-Based Program Manipulation",
  booktitle	= "Proceedings of the 2007 {ACM} {SIG{\-}PLAN} Workshop on Partial Evaluation and Semantics-Based Program Manipulation",
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 2007
}
