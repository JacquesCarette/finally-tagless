@STRING{j_acmcs			= "{ACM} Computing Surveys" }
@STRING{j_hosc			= "Higher-Order and Symbolic Computation" }
@STRING{j_jacm			= "Journal of the {ACM}" }
@STRING{j_jcss			= "Journal of Computer and System Sciences" }
@STRING{j_jfp			= "Journal of Functional Programming" }
@STRING{j_ngc			= "New Generation Computing" }
@STRING{j_scp			= "Science of Computer Programming" }
@STRING{j_sigplan		= "{ACM} {SIG{\-}PLAN} Notices" }
@STRING{j_tcs			= "Theoretical Computer Science" }
@STRING{proc_icfp_1		= "{ICFP} '" }
@STRING{proc_icfp_2		= ": Proceedings of the {ACM} International Conference on Functional Programming" }
@STRING{proc_pldi_1		= "{PLDI} '" }
@STRING{proc_pldi_2		= ": Proceedings of the {ACM} Conference on Programming Language Design and Implementation" }
@STRING{proc_popl_1		= "{POPL} '" }
@STRING{proc_popl_2		= ": Conference Record of the Annual {ACM} Symposium on Principles of Programming Languages" }
@STRING{pub_acm			= "{ACM} {P}ress" }
@STRING{pub_acm_addr		= "{N}ew {Y}ork" }
@STRING{pub_elsevier		= "Elsevier Science" }
@STRING{pub_elsevier_addr	= "Amsterdam" }
@STRING{pub_ph			= "Prentice-Hall" }
@STRING{pub_ph_addr		= "Englewood Cliffs, NJ" }
@STRING{pub_ieee		= "{IEEE} Computer Society Press" }
@STRING{pub_ieee_addr		= "Washington, {DC}" }
@STRING{pub_sv			= "Springer-Verlag" }
@STRING{pub_sv_addr		= "Berlin" }
@STRING{s_entcs			= "Electronic Notes in Theoretical Computer Science" }
@STRING{s_lncs			= "{L}ecture {N}otes in {C}omputer {S}cience" }

@inproceedings{WalidICFP02,
  author	= "Emir Pa{\v s}ali{\'c} and Walid Taha and Tim Sheard",
  title		= "Tagless Staged Interpreters for Typed Languages",
  pages		= "157--166",
  crossref	= "icfp2002",
  url		= "http://www.cs.rice.edu/~taha/publications/conference/icfp02.dvi http://www.cs.rice.edu/~taha/publications/conference/icfp02.ps http://www.cs.rice.edu/~taha/publications/conference/icfp02.pdf"
}

@Article{	hudak-building,
  author	= {Paul Hudak},
  title		= {Building Domain-Specific Embedded Languages},
  journal	= j_acmcs,
  year		= 1996,
  month		= dec,
  volume	= 28,
  number	= {4es},
  pages		= 196
}

@InProceedings{	xi-guarded,
  author	= "Hongwei Xi and Chiyan Chen and Gang Chen",
  title		= "Guarded Recursive Datatype Constructors",
  pages		= "224--235",
  crossref	= "popl2003",
  url		= "http://www.cs.bu.edu/~hwxi/academic/papers/popl03.pdf http://www.cs.bu.edu/~hwxi/academic/papers/popl03.ps http://www.cs.bu.edu/~hwxi/academic/talks/popl03.ppt"
}

@inproceedings{WalidPOPL03,
  author    = {Walid Taha and Michael Florentin Nielsen},
  title     = {Environment Classifiers},
  pages     = {26--37},
  crossref  = "popl2003",
  url       = "http://www.cs.rice.edu/~taha/publications/conference/popl03.dvi http://www.cs.rice.edu/~taha/publications/conference/popl03.ps http://www.cs.rice.edu/~taha/publications/conference/popl03.pdf"
}

@InProceedings{	baars-typing,
  author	= "Arthur I. Baars and S. Doaitse Swierstra",
  title		= "Typing Dynamic Typing",
  pages		= "157--166",
  crossref	= "icfp2002",
  url		= "http://www.cs.uu.nl/~arthurb/data/Dynamic/p189-baars.pdf http://www.cs.uu.nl/~arthurb/data/Dynamic/Talk.pdf http://www.cs.uu.nl/~arthurb/dynamic.html",
  abstract	= "Even when programming in a statically typed language we every now and then encounter statically untypable values; such values result from interpreting values or from communicating with the outside world. To cope with this
		  problem most languages include some form of \emph{dynamic} types. It may be that the core language has been explicitly extended with such a type, or that one is allowed to live dangerously by using functions like
		  \emph{unsafeCoerce}. We show how, by a careful use of existentially and universally quantified types, one may achieve the same effect, without extending the language with new or unsafe features. The techniques explained
		  are universally applicable, provided the core language is expressive enough; this is the case for the common implementations of Haskell. The techniques are used in the description of a type checking compiler that, starting
		  from an expression term, constructs a typed function representing the semantics of that expression. In this function the overhead associated with the type checking is only once being paid for; in this sense we have thus
		  achieved static type checking."
}

@InProceedings{	taha-tag,
  author	= {Walid Taha and Henning Makholm and John Hughes},
  title		= {Tag Elimination and {J}ones-Optimality},
  pages		= {257--275},
  crossref	= {pado2001},
  url		= "http://www.cs.rice.edu/~taha/publications/conference/padoII.dvi http://www.cs.rice.edu/~taha/publications/conference/padoII.ps http://www.cs.rice.edu/~taha/publications/conference/padoII.pdf"
}

@InProceedings{	peyton-jones-simple,
  author	= "Peyton Jones, Simon L. and Dimitrios Vytiniotis and Stephanie Weirich and Geoffrey Washburn",
  title		= "Simple Unification-Based Type Inference for {GADT}s",
  pages		= "50--61",
  crossref	= "icfp2006",
  url		= "http://research.microsoft.com/~simonpj/papers/gadt/"
}

@InProceedings{	fogarty-concoqtion,
  author	= "Seth Fogarty and Emir Pasalic and Jeremy Siek and Walid Taha",
  title		= "{C}oncoqtion: Indexed Types Now!",
  crossref	= "pepm2007",
  url		= "http://www.cs.rice.edu/~taha/publications/conference/pepm07b.pdf"
}

@misc{metaocaml,
  key = {MetaOCaml},
  note = {\url{http://www.metaocaml.org}}
}

@inproceedings{NanevskiICFP02,
  author    = {Aleksandar Nanevski},
  title     = {Meta-programming with Names and Necessity},
  pages     = {206--217},
  crossref  = "icfp2002"
}

@article{NanevskiJFP05,
  author    = {Aleksandar Nanevski and
               Frank Pfenning},
  title     = {Staged Computation with Names and Necessity},
  journal   = j_jfp,
  volume    = {15},
  number    = {6},
  year      = {2005},
  pages     = {893-939},
  ee        = {http://dx.doi.org/10.1017/S095679680500568X},
  bibsource = {DBLP, http://dblp.uni-trier.de},
  url = "http://www.eecs.harvard.edu/~aleks/papers/necessity/jfpnames02.ps"
}

@article{DaviesJACM01,
  author    = {Rowan Davies and
               Frank Pfenning},
  title     = {A Modal Analysis of Staged Computation},
  journal   = j_jacm,
  volume    = {48},
  number    = {3},
  year      = {2001},
  pages     = {555-604},
  ee        = {http://doi.acm.org/10.1145/382780.382785},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@Article{	nanevski-contextual,
  author	= "Aleksandar Nanevski and Frank Pfenning and Brigitte Pientka",
  title		= "Contextual Modal Type Theory",
  journal	= "Transactions on Computational Logic",
  year		= 2007,
  note		= "To appear",
  url		= "http://www.cs.cmu.edu/~fp/papers/tocl07.pdf",
  annote	= "Frank Pfenning's talk \cite{pfenning-contexts-talk}"
}

@InProceedings{	reynolds-definitional,
  author	= "John C. Reynolds",
  title		= "Definitional Interpreters for Higher-Order Programming Languages",
  pages		= "717--740",
  crossref	= "acm1972",
  note		= "Reprinted with a foreword in \emph{Higher-Order and Symbolic Computation} 11(4):\penalty0 363--397",
  volume	= 2,
  abstract	= "Higher-order programming languages (i.e., languages in which procedures or labels can occur as values) are usually defined by interpreters which are themselves written in a programming language based on the lambda
		  calculus (i.e., an applicative language such as pure LISP). Examples include McCarthy's definition of LISP, Landin's SECD machine, the Vienna definition of PL/I, Reynolds' definitions of GEDANKEN, and recent unpublished
		  work by L. Morris and C. Wadsworth. Such definitions can be classified according to whether the interpreter contains higher-order functions, and whether the order of application (i.e., call-by-value versus call-by-name) in
		  the defined language depends upon the order of application in the defining language. As an example, we consider the definition of a simple applicative programming language by means of an interpreter written in a similar
		  language. Definitions in each of the above classifications are derived from one another by informal but constructive methods. The treatment of imperative features such as jumps and assignment is also discussed."
}

@Article{	hindley-principal,
  author	= "Hindley, J. Roger",
  title		= "The Principal Type-Scheme of an Object in Combinatory Logic",
  journal	= "Transactions of the American Mathematical Society",
  year		= 1969,
  month		= dec,
  volume	= 146,
  pages		= "29--60"
}

@Article{	milner-theory,
  author	= "Robin Milner",
  title		= "A Theory of Type Polymorphism in Programming",
  journal	= j_jcss,
  year		= 1978,
  volume	= 17,
  pages		= "348--375"
}

@InProceedings{	yang-encoding,
  author	= {Zhe Yang},
  title		= {Encoding Types in {ML}-Like Languages},
  pages		= {289--300},
  crossref	= "icfp1998",
  url		= "http://cs.nyu.edu/zheyang/papers/YangZ--ICFP98.html http://cs.nyu.edu/zheyang/papers/YangZ--ICFP98.ps.gz"
}

@InProceedings{	pfenning-higher-order,
  author	= {Frank Pfenning and Conal Elliott},
  title		= {Higher-Order Abstract Syntax},
  pages		= {199--208},
  crossref	= "pldi1988",
  url		= "http://www.cs.cmu.edu/~fp/papers/pldi88.pdf"
}

@InProceedings{	miller-manipulating,
  author	= {Dale Miller and Gopalan Nadathur},
  title		= {A Logic Programming Approach to Manipulating Formulas and Programs},
  pages		= {379--388},
  crossref	= "slp1987"
}

@InProceedings{	calcagno-ml-like,
  author	= "Cristiano Calcagno and Eugenio Moggi and Walid Taha",
  title		= "{ML}-Like Inference for Classifiers",
  pages		= "79--93",
  crossref	= "esop2004",
  url		= "http://www.doc.ic.ac.uk/~ccris/ftp/esop04.pdf"
}

@InProceedings{Gluck-jones-optimality,
 author = {Robert Gl{\"u}ck},
 title = {{J}ones Optimality, Binding-Time Improvements, and the Strength of Program Specializers},
 booktitle = {{ASIA-PEPM} '02: Proceedings of the {ASIAN} Symposium on Partial Evaluation and Semantics-Based Program Manipulation},
 year = {2002},
 isbn = {1-58113-458-4},
 pages = {9--19},
 location = {Aizu, Japan},
 doi = {http://doi.acm.org/10.1145/568173.568175},
 publisher = pub_acm,
 address = pub_acm_addr
 }

@InProceedings{	oliveira-typecase,
  author	= {Oliveira, Bruno C{\'e}sar {\lowercase{D}}os Santos and Jeremy Gibbons},
  title		= {{T}ype{C}ase: A Design Pattern for Type-Indexed Functions},
  pages		= {98--109},
  crossref	= "haskell2005",
  url		= {http://web.comlab.ox.ac.uk/oucl/work/bruno.oliveira/typecase.pdf}
}

@Article{	asai-binding-time,
  author	= {Kenichi Asai},
  title		= {Binding-Time Analysis for Both Static and Dynamic Expressions},
  journal	= j_ngc,
  year		= 2001,
  volume	= 20,
  number	= 1,
  pages		= {27--52},
  url		= {http://pllab.is.ocha.ac.jp/~asai/papers/ngc02.ps.gz}
}

@Article{	sumii-hybrid,
  author	= "Eijiro Sumii and Naoki Kobayashi",
  title		= "A Hybrid Approach to Online and Offline Partial Evaluation",
  journal	= j_hosc,
  year		= 2001,
  month		= sep,
  volume	= 14,
  number	= "2--3",
  pages		= "101--142",
  url		= "http://www.kb.ecei.tohoku.ac.jp/~sumii/pub/onpe-hosc.dvi http://www.kb.ecei.tohoku.ac.jp/~sumii/pub/onpe-hosc.ps.gz http://www.kb.ecei.tohoku.ac.jp/~sumii/pub/onpe-hosc.pdf"
}

@InProceedings{	SwadiTahaKiselyovPasalic2006,
  author	= "Kedar Swadi and Walid Taha and Oleg Kiselyov and Emir Pasalic",
  title		= "A Monadic Approach for Avoiding Code Duplication When Staging Memoized Functions",
  pages		= "160--169",
  crossref	= "pepm2006",
  url		= "http://www.cs.rice.edu/~taha/publications/conference/pepm06.dvi http://www.cs.rice.edu/~taha/publications/conference/pepm06.ps http://www.cs.rice.edu/~taha/publications/conference/pepm06.pdf"
}

@InProceedings{	SperberThiemann:TwoForOne,
  author	= {Michael Sperber and Peter Thiemann},
  title		= {Two for the Price of One: Composing Partial Evaluation and Compilation},
  pages		= {215--225},
  crossref	= "pldi1997",
  url		= "http://www-pu.informatik.uni-tuebingen.de/users/sperber/papers/composing-pe-and-compilation.ps.gz http://www-pu.informatik.uni-tuebingen.de/users/sperber/papers/composing-pe-and-compilation.pdf"
}

@Article{	PlotkinCBN,
  author	= "Gordon D. Plotkin",
  title		= "Call-by-Name, Call-by-Value and the $\lambda$-Calculus",
  journal	= j_tcs,
  year		= 1975,
  volume	= 1,
  number	= 2,
  pages		= "125--159",
  url		= "http://homepages.inf.ed.ac.uk/gdp/publications/cbn_cbv_lambda.pdf"
}

@InProceedings{	reynolds-relation,
  author	= "John C. Reynolds",
  title		= "On the Relation between Direct and Continuation Semantics",
  pages		= "141--156",
  crossref	= "alp1974",
  url		= "ftp://ftp.cs.cmu.edu/user/jcr/reldircont.pdf"
}

@Book{		jones-partial,
  author	= "Neil D. Jones and Carsten K. Gomard and Peter Sestoft",
  title		= "Partial Evaluation and Automatic Program Generation",
  booktitle	= "Partial Evaluation and Automatic Program Generation",
  address	= pub_ph_addr,
  publisher	= pub_ph,
  year		= 1993,
  month		= jun,
  url		= "http://www.dina.dk/~sestoft/pebook/pebook.html",
  isbn		= "0-13-020249-5",
  annote	= "With chapters by L. O. Andersen and T. Mogensen"
}

@InProceedings{	Danvy-tagging-encoding,
  author	= {Olivier Danvy and Pablo E. Mart{\'\i}nez L{\'o}pez},
  title		= {Tagging, Encoding, and {J}ones Optimality},
  pages		= {335--347},
  crossref	= "esop2003"
}

@InProceedings{laod93,
  author	= "Konstantin L{\"a}ufer and Martin Odersky",
  booktitle	= "Proceedings of the 4th Annual {OOPSLA}\slash {ECOOP} Workshop on Object-Oriented Reflection and Metalevel Architectures",
  month      = oct,
  title      = {Self-Interpretation and Reflection in a Statically Typed Language},
  year       = {1993},
  url = "http://webpages.cs.luc.edu/~laufer/papers/reflection.pdf"
}

@inproceedings{HonsellLenisa,
 author = {Furio Honsell and Marina Lenisa},
  editor	= "Mariangiola Dezani-Ciancaglini and Gordon D. Plotkin",
 title = {Final Semantics for untyped lambda-calculus},
 booktitle = {{TLCA} '95: Proceedings of the 2nd International Conference on Typed Lambda Calculi and Applications},
 year = {1995},
 isbn = {3-540-59048-X},
 pages = {249--265},
 publisher = pub_sv,
 address = pub_sv_addr,
  number	= 902,
  series	= s_lncs
 }

@article{ honsell99coinductive,
    author = "Furio Honsell and Marina Lenisa",
    title = "Coinductive characterizations of applicative structures",
    journal = "Mathematical Structures in Computer Science",
    volume = "9",
    number = "4",
    pages = "403-435",
    year = "1999",
    url = "citeseer.ist.psu.edu/honsell98coinductive.html" }

@inproceedings{fiore:nbe-ppdp2002,
   author = "Marcelo P. Fiore",
   title = "Semantic Analysis of Normalisation by Evaluation for Typed Lambda Calculus",
  booktitle	= {Proceedings of the 4th International Conference on Principles and Practice of Declarative Programming},
  address	= pub_acm_addr,
  publisher	= pub_acm,
  pages		= "26--37",
   month = "October",
   year = "2002",
   url = "http://repository.readscheme.org/ftp/papers/fiore-nbe-ppdp2002.pdf"
}

@inproceedings{balat:tdpe-popl2004,
   author = "Vincent Balat and Di Cosmo, Roberto and Marcelo P. Fiore",
   title = "Extensional Normalisation and Type-Directed Partial Evaluation for Typed Lambda Calculus with Sums",
   crossref="popl2004",
  pages		= "64--76",
   url = "http://repository.readscheme.org/ftp/papers/balat-tdpe-popl2004.pdf"
}

@InProceedings{	Ramsey-ML-module-mania,
  author	= "Norman Ramsey",
  title		= "{ML} Module Mania: A Type-Safe, Separately Compiled, Extensible Interpreter",
  crossref	= "ml2005",
  url		= "http://www.eecs.harvard.edu/~nr/pubs/maniaws-abstract.html http://www.eecs.harvard.edu/~nr/pubs/maniaws.ps http://www.eecs.harvard.edu/~nr/pubs/maniaws.pdf http://www.eecs.harvard.edu/~nr/pubs/maniaws.dvi"
}

@InProceedings{	Washburn-Weirich-boxes,
  author	= {Geoffrey Washburn and Stephanie Weirich},
  title		= {Boxes Go Bananas: Encoding Higher-Order Abstract Syntax with Parametric Polymorphism},
  pages		= {249--262},
  crossref	= "icfp2003"
}

@InProceedings{	Danvy-TDPE,
  author	= "Olivier Danvy",
  title		= "Type-Directed Partial Evaluation",
  pages		= "242--257",
  crossref	= "popl1996",
  url		= "ftp://ftp.daimi.au.dk/pub/empl/danvy/Papers/danvy-popl96.ps.gz"
}

@Article{	Benton-embedded-interpreters,
  author	= "P. Nick Benton",
  title		= "Embedded Interpreters",
  journal	= j_jfp,
  year		= 2005,
  month		= jul,
  volume	= 15,
  number	= 4,
  pages		= "503--542",
  url		= "http://research.microsoft.com/~nick/benton03.pdf http://research.microsoft.com/~nick/benton03.ps"
}

@InProceedings{	Thiemann:cogeninsixlines,
  author	= {Peter Thiemann},
  title		= {Cogen in Six Lines},
  pages		= "180--189",
  crossref	= "icfp1996",
  url		= "http://www.informatik.uni-freiburg.de/~thiemann/papers/icfp96.ps.gz"
}

@InProceedings{	Guillemette-Monier-PLPV,
  author	= "Louis-Julien Guillemette and Stefan Monnier",
  title		= "Statically Verified Type-Preserving Code Transformations in {H}askell",
  pages		= "40--53",
  crossref	= "plpv2006"
}

@Article{	bohm-automatic,
  author	= "Corrado B{\"o}hm and Alessandro Berarducci",
  title		= "Automatic Synthesis of Typed {$\Lambda$}-Programs on Term Algebras",
  journal	= j_tcs,
  year		= 1985,
  volume	= 39,
  pages		= "135--154"
}

@InProceedings{berarducci-models,
  author    = "Alessandro Berarducci", 
  title     = "Infinite lambda-calculus and non-sensible models", 
  booktitle = "Logic and Algebra",
  year      = 1996,
  pages     = "339--378",
  publisher = "Marcel Dekker",
  volume    = "180",
  editor    = "A. Ursini and P. Aglian\`{o}"
}

@Misc{haskell-list,
    author="Joost Visser and Dimitrios Vytiniotis",
    title="Simple {GADT} Parser for the Eval Example",
    howpublished="Haskell-Cafe mailing list. \url{http://www.haskell.org/pipermail/haskell-cafe/2006-October/019160.html}
    \url{http://www.haskell.org/pipermail/haskell-cafe/2006-October/019161.html}",
    year=2006
}

@Misc{jacobs-coalgebra,
  author = "Bart Jacobs",
  title  = "Introduction to Coalgebra:  Towards Mathematics of States and Observations",
  note   = "Draft book",
  year   = 2007,
  howpublished = "\url{http://www.cs.ru.nl/B.Jacobs/CLG/JacobsCoalgebraIntro.pdf}" }

@InProceedings{	shao-typed,
  author	= "Zhong Shao",
  title		= "Typed Cross-Module Compilation",
  pages		= "141--152",
  crossref	= "icfp1998",
  url		= "http://flint.cs.yale.edu/flint/publications/tcc.ps.gz http://flint.cs.yale.edu/flint/publications/tcc.pdf"
}

@InProceedings{	shao-transparent,
  author	= "Zhong Shao",
  title		= "Transparent Modules with Fully Syntactic Signatures",
  pages		= "220--232",
  crossref	= "icfp1999",
  url		= "http://flint.cs.yale.edu/flint/publications/fullsig.ps.gz http://flint.cs.yale.edu/flint/publications/fullsig.pdf"
}

@PhDThesis{	Rhiger-thesis,
  author	= "Morten Rhiger",
  title		= "{H}igher-{O}rder Program Generation",
  booktitle	= "{H}igher-{O}rder Program Generation",
  school        = "{BRICS} {Ph.D.} School. Department of Computer Science,
                   University of Aarhus, Denmark",
  year		= 2001,
  url = "http://www.brics.dk/DS/01/4/index.html",
  abstract	= {
This dissertation addresses the challenges of embedding programming languages,
specializing generic programs to specific parameters, and generating
specialized instances of programs directly as executable code. Our main tools
are higher-order programming techniques and automatic program generation. It is
our thesis that they synergize well in the development of customizable
software.
\par
Recent research on domain-specific languages propose to embed them into
existing general-purpose languages. Typed higher-order languages have proven
especially useful as meta languages because they provide a rich infrastructure
of higher-order functions, types, and modules. Furthermore, it has been
observed that embedded programs can be restricted to those having simple types
using a technique called ``phantom types''. We prove, using an idealized
higher-order language, that such an embedding is sound (i.e., when all
object-language terms that can be embedded into the meta language are simply
typed) and that it is complete (i.e., when all simply typed object-language
terms can be embedded into the meta language). The soundness proof is shown by
induction over meta-language terms using a Kripke logical relation. The
completeness proof is shown by induction over object-language terms.
Furthermore, we address the use of Haskell and Standard ML as meta-languages.
\par
Normalization functions, as embodied in type-directed partial evaluation, map a
simply-typed higher-order value into a representation of its long beta-eta
normal form. However, being dynamically typed, the original Scheme
implementation of type-directed partial evaluation does not restrict input
values to be typed at all. Furthermore, neither the original Scheme
implementation nor the original Haskell implementation guarantee that
type-directed partial evaluation preserves types. We present three
implementations of type-directed partial evaluation in Haskell culminating with
a version that restricts the input to typed values and for which the proofs of
type-preservation and normalization are automated.
\par
Partial evaluation provides a solution to the disproportion between general
programs that can be executed in several contexts and their specialized
counterparts that can be executed efficiently. However, stand-alone partial
evaluation is usually too costly when a program must be specialized at run
time. We introduce a collection of byte-code combinators for OCaml, a dialect
of ML, that provides run-time code generation for OCaml programs. We apply
these byte-code combinators in semantics-directed compilation for an imperative
language and in run-time specialization using type-directed partial evaluation.
\par
Finally, we present an approach to compiling goal-directed programs, i.e.,
programs that backtrack and generate successive results: We first specify the
semantics of a goal-directed language using a monadic semantics and a spectrum
of monads. We then compile goal-directed programs by specializing their
interpreter (i.e., by using the first Futamura projection), using type-directed
partial evaluation. Through various back ends, including a run-time code
generator, we generate ML code, C code, and OCaml byte code.
}
}


@inproceedings{Lava,
  author    = {Per Bjesse and
               Koen Claessen and
               Mary Sheeran and
               Satnam Singh},
  title     = {Lava: Hardware Design in {H}askell},
  pages     = {174-184},
  crossref	= "icfp1998",
  ee        = {http://doi.acm.org/10.1145/289423.289440},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@article{Pfenning-Lee,
  author    = {Frank Pfenning and
               Peter Lee},
  title     = {Metacircularity in the Polymorphic $\lambda$-Calculus},
  journal   = j_tcs,
  volume    = {89},
  number    = {1},
  year      = {1991},
  pages     = {137-159},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@inproceedings{Morrisett-intensional,
  author    = {Robert Harper and
               J. Gregory Morrisett},
  title     = {Compiling Polymorphism Using Intensional Type Analysis},
  crossref	= "popl1995",
  pages     = {130-141}
}

@article{Generic-Haskell,
  author    = {Ralf Hinze and
               Johan Jeuring and
               Andres L{\"o}h},
  title     = {Type-indexed data types},
  journal   = j_scp,
  volume    = {51},
  number    = {1-2},
  year      = {2004},
  pages     = {117-151},
  ee        = {http://dx.doi.org/10.1016/j.scico.2003.07.001},
  bibsource = {DBLP, http://dblp.uni-trier.de}
}

@InProceedings{	chen-typeful,
  author	= {Chiyan Chen and Hongwei Xi},
  title		= {Implementing Typeful Program Transformations},
  pages		= {20--28},
  crossref	= {pepm2003},
  abstract	= {The notion of program transformation is ubiquitous in programming language studies on interpreters, compilers, partial evaluators, etc. In order to implement a program transformation, we need to choose a representation in
		  the meta language, that is, the programming language in which we construct programs, for representing object programs, that is, the programs in the object language on which the program transformation is to be performed. In
		  practice, most representations chosen for typed object programs are typeless in the sense that the type of an object program cannot be reflected in the type of its representation. This is unsatisfactory as such typeless
		  representations make it impossible to capture in the type system of the meta language various invariants in a program transformation that are related to the types of object programs. In this paper, we propose an approach
		  to implementing program transformations that makes use of a first-order typeful program representation formed in Dependent ML (DML), where the type of an object program as well as the types of the free variables in the
		  object program can be reflected in the type of the representation of the object program. We introduce some programming techniques needed to handle this typeful program representation, and then present an implementation of
		  a CPS transform function where the relation between the type of an object program and that of its CPS transform is captured in the type system of DML. In a broader context, we claim to have taken a solid step along the
		  line of research on constructing certifying compilers.}
}

@InProceedings{CaretteKiselyov05,
	author = {Jacques Carette and Oleg Kiselyov},
	title = {Multi-stage programming with {F}unctors and {M}onads: eliminating abstraction overhead from generic code},
	booktitle = {Generative Programming and Component-based Engineering {GPCE}},
	year = {2005},
    pages = {256--274}
}

@Article{	jones-challenging,
  author	= {Neil D. Jones},
  title		= {Challenging Problems in Partial Evaluation and Mixed Computation},
  journal	= j_ngc,
  year		= 1988,
  volume	= 6,
  number	= {2--3},
  pages		= {291--302},
  annote	= "Jones-optimality"
}

%------------------------------------------------------------------------
% After this, only procedings etc

@Proceedings{	acm1972,
  key		= "{\relax ACM}",
  title		= "Proceedings of the {ACM} National Conference",
  booktitle	= "Proceedings of the {ACM} National Conference",
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 1972,
  location	= "Boston"
}

@Proceedings{	icfp1998,
  key		= "{\relax ICFP}",
  title		= proc_icfp_1 # "98"  # proc_icfp_2,
  booktitle	= proc_icfp_1 # "98"  # proc_icfp_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 1998,
  volume	= "34(1)",
  series	= j_sigplan,
  url		= "http://dblp.uni-trier.de/db/conf/icfp/icfp98.html",
  isbn		= "0-58113-024-4",
  location	= "Baltimore"
}

@Proceedings{	icfp1999,
  key		= "{\relax ICFP}",
  title		= proc_icfp_1 # "99"  # proc_icfp_2,
  booktitle	= proc_icfp_1 # "99"  # proc_icfp_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 1999,
  volume	= "34(9)",
  series	= j_sigplan,
  url		= "http://pauillac.inria.fr/pli/ http://dblp.uni-trier.de/db/conf/icfp/icfp99.html",
  isbn		= "1-58113-111-9",
  location	= "Paris"
}

@Proceedings{	icfp2002,
  key		= "{\relax ICFP}",
  title		= proc_icfp_1 # "02"  # proc_icfp_2,
  booktitle	= proc_icfp_1 # "02"  # proc_icfp_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 2002,
  location	= "Pittsburgh, PA"
}

@Proceedings{	icfp2006,
  key		= "{\relax ICFP}",
  title		= proc_icfp_1 # "06"  # proc_icfp_2,
  booktitle	= proc_icfp_1 # "06"  # proc_icfp_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 2006,
  location	= "Portland, OR"
}

@Proceedings{	popl2003,
  key		= "{\relax POPL}",
  title		= proc_popl_1 # "03"  # proc_popl_2,
  booktitle	= proc_popl_1 # "03"  # proc_popl_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 2003,
  isbn		= {1-58113-628-5},
  issn		= "0730-8566",
  location	= {New Orleans}
}

@Proceedings{	pado2001,
  editor	= {Olivier Danvy and Andrzej Filinski},
  title		= {Proceedings of {PADO} 2001: 2nd Symposium on Programs as Data Objects},
  booktitle	= {Proceedings of {PADO} 2001: 2nd Symposium on Programs as Data Objects},
  address	= pub_sv_addr,
  publisher	= pub_sv,
  year		= 2001,
  month		= "21--23 "  # may,
  number	= 2053,
  series	= s_lncs,
  isbn		= {3-540-42068-1},
  location	= "Aarhus, Denmark"
}

@Proceedings{	pepm2003,
  key		= "{\relax PEPM}",
  title		= "Proceedings of the 2003 {ACM} {SIG{\-}PLAN} Workshop on Partial Evaluation and Semantics-Based Program Manipulation",
  booktitle	= "Proceedings of the 2003 {ACM} {SIG{\-}PLAN} Workshop on Partial Evaluation and Semantics-Based Program Manipulation",
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 2003,
  month		= "7~"  # jun,
  isbn		= {1-58113-667-6},
  location	= "San Diego, CA"
}

@Proceedings{	pepm2007,
  key		= "{\relax PEPM}",
  title		= "Proceedings of the 2007 {ACM} {SIG{\-}PLAN} Workshop on Partial Evaluation and Semantics-Based Program Manipulation",
  booktitle	= "Proceedings of the 2007 {ACM} {SIG{\-}PLAN} Workshop on Partial Evaluation and Semantics-Based Program Manipulation",
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 2007
}

@Proceedings{	pldi1988,
  key		= "{\relax PLDI}",
  title		= proc_pldi_1 # "88"  # proc_pldi_2,
  booktitle	= proc_pldi_1 # "88"  # proc_pldi_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 1988,
  month		= "22--24 "  # jun,
  volume	= "23(7)",
  series	= j_sigplan,
  location	= "Atlanta"
}

@Proceedings{	slp1987,
  editor	= "Seif Haridi",
  title		= "{IEEE} Symposium on Logic Programming",
  booktitle	= "{IEEE} Symposium on Logic Programming",
  address	= pub_ieee_addr,
  publisher	= pub_ieee,
  year		= 1987,
  isbn		= "0-8186-0799-8",
  location	= "San Francisco"
}

@Proceedings{	esop2004,
  editor	= "David A. Schmidt",
  title		= "Programming Languages and Systems: Proceedings of {ESOP} 2004, 13th {E}uropean Symposium on Programming",
  booktitle	= "Programming Languages and Systems: Proceedings of {ESOP} 2004, 13th {E}uropean Symposium on Programming",
  address	= pub_sv_addr,
  publisher	= pub_sv,
  year		= 2004,
  number	= 2986,
  series	= s_lncs,
  isbn		= "3-540-21313-9",
  location	= "Barcelona, Spain"
}

@Proceedings{	haskell2005,
  title		= "Proceedings of the 2005 {H}askell Workshop",
  booktitle	= "Proceedings of the 2005 {H}askell Workshop",
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 2005,
  isbn		= {1-59593-071-X},
  location	= {Tallinn, Estonia}
}

@Proceedings{	pepm2006,
  key		= "{\relax PEPM}",
  title		= "Proceedings of the 2006 {ACM} {SIG{\-}PLAN} Workshop on Partial Evaluation and Semantics-Based Program Manipulation",
  booktitle	= "Proceedings of the 2006 {ACM} {SIG{\-}PLAN} Workshop on Partial Evaluation and Semantics-Based Program Manipulation",
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 2006,
  isbn		= "1-59593-196-1",
  location	= "Charleston, SC"
}

@Proceedings{	pldi1997,
  key		= "{\relax PLDI}",
  title		= proc_pldi_1 # "97"  # proc_pldi_2,
  booktitle	= proc_pldi_1 # "97"  # proc_pldi_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 1997,
  month		= "16--18 "  # jun,
  location	= "Las Vegas, NV"
}

@Proceedings{	alp1974,
  editor	= "Jacques Loeckx",
  title		= "Automata, Languages and Programming: 2nd Colloquium",
  booktitle	= "Automata, Languages and Programming: 2nd Colloquium",
  address	= pub_sv_addr,
  publisher	= pub_sv,
  year		= 1974,
  number	= 14,
  series	= s_lncs,
  location	= "Saarbr{\"u}cken, Germany"
}

@Proceedings{	esop2003,
  editor	= "Pierpaolo Degano",
  title		= "Programming Languages and Systems: Proceedings of {ESOP} 2003, 12th {E}uropean Symposium on Programming",
  booktitle	= "Programming Languages and Systems: Proceedings of {ESOP} 2003, 12th {E}uropean Symposium on Programming",
  address	= pub_sv_addr,
  publisher	= pub_sv,
  year		= 2003,
  number	= 2618,
  series	= s_lncs,
  isbn		= "3-540-00886-1",
  location	= "Warsaw"
}

@Proceedings{	popl2004,
  key		= "{\relax POPL}",
  title		= proc_popl_1 # "04"  # proc_popl_2,
  booktitle	= proc_popl_1 # "04"  # proc_popl_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 2004,
  location	= {Venice, Italy}
}

@Proceedings{	ml2005,
  key		= "{\relax ML}",
  title		= "Proceedings of the 2005 Workshop on {ML}",
  booktitle	= "Proceedings of the 2005 Workshop on {ML}",
  address	= pub_elsevier_addr,
  publisher	= pub_elsevier,
  year		= 2005,
  month		= sep,
  series	= s_entcs,
  url		= "http://ttic.uchicago.edu/~blume/ml05/",
  annote	= "To be published as a volume of ENTCS",
  location	= "Tallinn"
}

@Proceedings{	icfp2003,
  key		= "{\relax ICFP}",
  title		= proc_icfp_1 # "03"  # proc_icfp_2,
  booktitle	= proc_icfp_1 # "03"  # proc_icfp_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 2003,
  volume	= "38(9)",
  series	= j_sigplan,
  isbn		= {1-58113-756-7},
  location	= "Uppsala, Sweden"
}

@Proceedings{	popl1996,
  key		= "{\relax POPL}",
  title		= proc_popl_1 # "96"  # proc_popl_2,
  booktitle	= proc_popl_1 # "96"  # proc_popl_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 1996,
  isbn		= {0-89791-769-3},
  issn		= "0730-8566",
  location	= "St.~Petersburg Beach, FL"
}

@Proceedings{	icfp1996,
  key		= "{\relax ICFP}",
  title		= proc_icfp_1 # "96"  # proc_icfp_2,
  booktitle	= proc_icfp_1 # "96"  # proc_icfp_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 1996,
  volume	= "31(6)",
  series	= j_sigplan,
  url		= "http://www.cs.indiana.edu/icfp96/ http://dblp.uni-trier.de/db/conf/icfp/icfp96.html",
  isbn		= "0-89791-770-7",
  issn		= "0362-1340",
  location	= "Philadelphia"
}

@Proceedings{	plpv2006,
  editor	= "Aaron Stump and Hongwei Xi",
  title		= {{PLPV} 2006: Programming Languages Meets Program Verification},
  booktitle	= {{PLPV} 2006: Programming Languages Meets Program Verification},
  address	= pub_elsevier_addr,
  publisher	= pub_elsevier,
  year		= 2006,
  number	= "174(7)",
  series	= s_entcs,
  location	= "Seattle, WA"
}

@Proceedings{	popl1995,
  key		= "{\relax POPL}",
  title		= proc_popl_1 # "95"  # proc_popl_2,
  booktitle	= proc_popl_1 # "95"  # proc_popl_2,
  address	= pub_acm_addr,
  publisher	= pub_acm,
  year		= 1995,
  isbn		= "0-89791-692-1",
  issn		= "0730-8566",
  location	= "San Francisco"
}
