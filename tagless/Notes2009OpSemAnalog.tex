%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\documentclass[11pt,fleqn]{article}

\usepackage{fleqn,amssymb,amsmath,latexsym}

% BIG PAGE:  fill the page out in breadth and height


% SIDE MARGINS:
\oddsidemargin -20pt    %   Note that \oddsidemargin = \evensidemargin
\evensidemargin -20pt
\marginparwidth 50pt 
\marginparsep 5pt       % Horizontal space between outer margin and 
                        % marginal note
% VERTICAL SPACING:        
                         %Top of page:
\topmargin -10pt         % Nominal distance from top of page to top of
                         %    box containing running head.
% DIMENSION OF TEXT:
\textheight 220mm        % Height of text (including footnotes and figures, 
                         % excluding running head and foot).
\textwidth 170mm         % Width of text line.


% NEWCOMMANDS

\newcommand{\com}{\newcommand}
\newcommand{\rcom}{\renewcommand}
\newcommand{\newenv}{\newenvironment}

\newcommand{\ignore}[1]{#1}
\newcommand{\maybe}[1]{}

% \prglab{...} macro for setting a framed label in program text
\makeatletter
\newcommand{\prglab}[1]{{\newbox\prglabbox\newbox\innerlabbox
    \setbox\innerlabbox=\hbox{\fontsize{6}{7}\selectfont#1}%
    \dp\innerlabbox=0pt
    \setbox\prglabbox=\hbox{\fbox{\box\innerlabbox}}%
  \newdimen\charwidth \settowidth\charwidth{M}\newcount\labelchars
  \labelchars=\wd\prglabbox
  \advance\labelchars by -1 \divide\labelchars by \charwidth
  \advance\labelchars by 1  \multiply\charwidth by \labelchars
  \edef\@tempa{\ttdefault}\ifx\@tempa\f@family
    \wd\prglabbox=\charwidth
  \fi
  \box\prglabbox}}
\makeatother

\com{\deq}{{\downarrow}{\raisebox{1ex}{\rmfamily\hspace{-1.3ex}\scriptsize=}}}
\com{\deqsm}{\downarrow{}^{\hspace{-1.1ex}=}}

\newcommand{\head}[1]{\bc \underline{\Huge\bf#1}\ec}
\newcommand{\thm}[1]{\fl{\bf Theorem} #1}
\newcommand{\lem}[1]{\fl{\bf Lemma} #1}
\newcommand{\dfn}[1]{\fl{\bf Definition} #1}

\newcommand{\judge}[3]
{\pgt{p},\,\mbox{$#1$}\mbox{$\,\vdash\,${\tt#2}}\mbox{$\rightarrow#3$}}


\newcommand{\judgeif}[5]
{\pgt{p},\,\mbox{$#1,\,#2$}\mbox{$\,\vdash^{if}\,${\tt#3},{\tt#4}}
\mbox{$\rightarrow#5$}}

\newcommand{\judget}[4]
{\pgt{p},\,
\mbox{$#1$}
\mbox{$\,\vdash\,${\tt#2}}
\mbox{$\rightarrow#3,#4$}}

\newcommand{\judgec}[5]
{\pgt{p},\,
\mbox{$#1,#2$}
\mbox{$\,\vdash\,${\tt#3}}
\mbox{$\rightarrow#4,#5$}
}

\newcommand{\un}[1]{\underline{#1}}

\newcommand{\fl}{\noindent}
\newcommand{\hair}{\hspace{3mm}}
\newcommand{\vair}{\vspace{3mm}}
\newcommand{\lngth}[1]{\mbox{$\mid$#1$\mid$}}
\newcommand{\nat}{{I\!\!N}}
\newcommand{\ints} { Z\!\!\!Z}
\newcommand{\bools}{{I\!\!B}}
\newcommand{\lwhile}{{\tt WHILE}}
\newcommand{\pairs}{I\!\!D}
\newcommand{\startprog}{\begin{program}}
\newcommand{\stopprog}{\vspace{0.5cm}\end{program}}

\newcommand{\bpic}{\begin{center} \begin{picture}(50,50)(-25,-25)}
\newcommand{\epic}{\end{picture} \end{center}}
\newcommand{\ptext}[1]{\makebox(0,0){#1}}

\newcommand{\lsem}{\mbox{$\lbrack\hspace{-0.3ex}\lbrack$}}
\newcommand{\rsem}{\mbox{$\rbrack\hspace{-0.3ex}\rbrack$}}
\newcommand{\sempar}[1]{\mbox{\lsem\pgt{#1}\rsem}}
\newcommand{\semparlang}[2]{\sempar{#1}$^\pgt{#2}$}

\newcommand{\bq}{\begin{quote}}
\newcommand{\eq}{\end{quote}}

\newcommand{\bc}{\begin{center}}
\newcommand{\ec}{\end{center}}

\newcommand{\bi}{\begin{itemize}}
\newcommand{\ei}{\end{itemize}}

\newcommand{\be}{\begin{enumerate}}
\newcommand{\ee}{\end{enumerate}}

\newcommand{\ba}{\begin{array}}
\newcommand{\ea}{\end{array}}

\newcommand{\bd}{\begin{description}}
\newcommand{\ed}{\end{description}}

\newcommand{\bdfn}{\begin{definition}}
\newcommand{\edfn}{\end{definition}}

\newcommand{\blem}{\begin{lemma}}
\newcommand{\elem}{\end{lemma}}

\newcommand{\bcor}{\begin{corollary}}
\newcommand{\ecor}{\end{corollary}}

\newcommand{\bprf}{\fl{\bf Proof~}}
\newcommand{\eprf}{}

\newcommand{\bthm}{\begin{theorem}}
\newcommand{\ethm}{\end{theorem}}

\newcommand{\bp}{\begin{program}}
\newcommand{\ep}{\end{program}}

\newcommand{\bt}{\begin{tabular}}
\newcommand{\et}{\end{tabular}}

\newcommand{\runpgm}[2]{\mbox{\lsem\pgt{#1}\rsem}(\pgt{#2})}
\newcommand{\runpgmlang}[3]{\mbox{\lsem\pgt{#1}\rsem$^\pgt{#3}({\pgt#2})$}}
\newcommand{\runpgmlangnest}[3]{\mbox{\lsem#1\rsem$^\pgt{#3}(\pgt{#2})$}}
\newcommand{\timepgm}[2]{\mbox{{\em time}$_\pgt{#1}(\pgt{#2})$}} 
\newcommand{\timepgmlang}[3]{\mbox{{\em
time}$^\pgt{#3}_\pgt{#1}(\pgt{#2})$}}

\newcommand{\spacepgm}[2]{\mbox{{\em space}$_\pgt{#1}(\pgt{#2})$}} 
\newcommand{\spacepgmlang}[3]{\mbox{{\em
space}$^\pgt{#3}_\pgt{#1}(\pgt{#2})$}}

\com{\pgt}[1]{{\tt #1}}

\newcommand{\startproof}{\par\noindent{\bf Proof\ \ }}
\newcommand{\stopproof}{}


\com{\irule}[2]{$\frac{\mbox{\raisebox{.2ex}{#1}}}{\mbox{\raisebox{-.4ex}[1.5ex][1.5ex]{#2}}}$}


% Latex Examples and Propositions

\newtheorem{example-thm}{Example}[section]
\newenvironment{example}{\begin{example-thm}\rm}%
	{\end{example-thm}}

\newtheorem{proposition-thm}[example-thm]{Proposition}
\newenvironment{proposition}{\begin{proposition-thm}\rm}%
	{\end{proposition-thm}}

\newtheorem{theorem-thm}[example-thm]{Theorem}
\newenvironment{theorem}{\begin{theorem-thm}\rm}%
	{\end{theorem-thm}}

\newtheorem{corollary-thm}[example-thm]{Corollary}
\newenvironment{corollary}{\begin{corollary-thm}\rm}%
	{ \end{corollary-thm}}

\newtheorem{observation-thm}[example-thm]{Observation}
\newenvironment{observation}{\begin{observation-thm}\rm}%
	{ \end{observation-thm}}

\newtheorem{lemma-thm}[example-thm]{Lemma}
\newenvironment{lemma}{\begin{lemma-thm}\rm}%
	{ \end{lemma-thm}}

\newtheorem{definition-thm}[example-thm]{Definition}
\newenvironment{definition}{\begin{definition-thm}\rm}%
	{\end{definition-thm}}



\newcommand{\programenvironment}{\programmode%
	\def\par{\leavevmode\endgraf}\obeylines\nobreak%
	\programmode}
\newcommand{\programinfig}{%
	 \parindent 0em
	 \nobreak\programenvironment}
\newcommand{\programmode}{\small\tt%   Is: \small\tt, PS 1992-09-23
	\catcode`\_=12 \catcode`\?=12 \catcode`\.=12 \catcode`\,=12
	\catcode`\;=12 \catcode`\:=12 \catcode`\@=12 \catcode`\~=12
        \catcode`\#=12 \catcode`\&=12      % Added by PS 1991-06-17
	\obeyspaces\frenchspacing}%

\newenvironment{programintext}{\programenvironment}{}

\newenvironment{program}{\setlength{\partopsep}{0mm}\setlength{\topsep}{0mm}
	\begin{trivlist}\item[]
	\hspace*{\mathindent}\begin{minipage}{0.90\textwidth}
	\vspace{1mm}
	\begin{programintext}
	}{\end{programintext}
	\vspace{1mm}
	\end{minipage}
	\end{trivlist}
	\noindent}

% The following code makes Tex respect spaces and tabs in the source text, 
% which is useful for program layout.

{\catcode`\^^I=\active \obeyspaces\global\def^^I{ }}
{\obeyspaces\global\let =\ } % let active space = control space
{\catcode`\`=\active \gdef`{\relax\lq}}
% Environment for displaying material (to replace quote and vair
% etc.).  Indents the same amount as displaymath, equations, etc.

\newenvironment{quot}{\begin{list}{{}}{
	\setlength{\partopsep}{0mm}\setlength{\topsep}{3mm}
	\setlength{\leftmargin}{\mathindent}\setlength{\rightmargin}{0mm}}
	\item[]}{\end{list}}

  %% doframeit draws a box around it argument by manipulating boxes.  It
  %% is used in the frame environments.
  %% 
  %%  Rene' Seindal (seindal@diku.denet) Fri Feb 12 16:03:07 1988
  %%  added \fboxrule and \fboxsep to \doframeit

\def\doframeit#1{\vbox{%
  \hrule height\fboxrule
    \hbox{%
      \vrule width\fboxrule \kern\fboxsep
      \vbox{\kern\fboxsep #1\kern\fboxsep }%
      \kern\fboxsep \vrule width\fboxrule }%
    \hrule height\fboxrule }}

  %% The frameit and Frameit environments formats text within a single 
  %% Anything can be framed, including verbatim text.

\def\frameit{\smallskip \advance \linewidth by -7.5pt \setbox0=\vbox \bgroup
\strut \ignorespaces }

\def\endframeit{\ifhmode \par \nointerlineskip \fi \egroup
\doframeit{\box0}}


%
%-----------------------------------------------------------------------------
%     figure environment
%
%  #1 = caption, #2 = location, #3 = label
%

\newcounter{figur}[section]
\def\thefigur{\thesection.\arabic{figur}}
\newsavebox{\fighack}

\newenvironment{fig}[3]
{
\refstepcounter{figur}
\label{#3}
\sbox{\fighack}{{\it Figure \ref{#3}: #1}}
\begin{figure}[#2]
\begin{frameit}
\hspace*{3mm}\begin{minipage}{0.95\textwidth}}{\end{minipage}\end{frameit}\usebox{\fighack}\end{figure}}




\newenvironment{fig0}[3]
{
\refstepcounter{figur}
\label{#3}
\sbox{\fighack}{{\it Figure \ref{#3}: #1}}
\begin{figure}[#2]
%\begin{frameit}
\hspace*{3mm}\begin{minipage}{0.95\textwidth}}{\end{minipage} 
%\end{frameit}
\usebox{\fighack}\end{figure}}


\newcommand{\state}[2]{\mbox{\tt#1} $::\, #2$}

\newcommand{\code}[1]{\mbox{$\ulcorner$}{\tt#1}\mbox{$\urcorner $}}

\newcommand{\ifp}{\mathtt{if}}

\newcommand{\loopp}{\mathtt{loop}}

\newcommand{\dynamic}[1]{\underline{#1}}

\newcommand{\static}[1]{\underline{\underline{#1}}}

\newcommand{\val}{\mathit{Value}}


\newcommand{\pg}[1]{\paragraph{#1}}


\title{II: An Operational Semantics version of the Futamura Projections}

%\author{Neil D.\ Jones}


\begin{document}

\maketitle



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 1. Notations/definitions from book PEAPG
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% 1. Curried versions of PEAPG not's/def'ns
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bc\fbox{\bf Curried versions of PEAPG notations and definitions}
\ec



All first-order. Generalised a bit: not necessarily {\em one} program input and output.
No pairing function. Modify equality, semantic function, etc. 

\vspace{5mm}

{\bf Language L} 
\bi
\item A set $L-programs$, elements $p, q, comp, int,\ldots$
\item A set $L-data$, elements $d, s, source, target,\ldots$

\item -- no pairing function --
\item Semantic function: for each program $p \in L-programs$, a set of {\em observable runs}
$$
\lsem p\rsem  \subseteq (L-data)^+
$$
Syntactic sugar: write $\lsem p\rsem v_1\ldots v_n = v$  if $(v_1,\ldots, v_n, v) \in \lsem p\rsem$
is an observable run.
\ei





\pg{Equality of values:} there is no undefined value $\bot$. Equality is identity.

\pg{Program equivalence:} programs $p,q$ are equivalent if $\lsem p\rsem = \lsem q\rsem$. 
This is essentially the well-known {\em observational  equivalence} $p \approx q$, defined by:

$$
p \approx q
 \mbox{\ iff\ }
\forall n\forall v, v_1,\ldots,v_n \in \val
( \ 
\lsem p\rsem v_1\ldots v_n = v
\mbox{\ iff\ }
\lsem q\rsem v_1\ldots v_n = v  \ )
$$


\pg{Programs as data:} when needed, assume $L-programs \subseteq L-data$
so programs {\em are} data.




\pg{L-to-L compiler:} a program $comp$ such that
$
\forall p (\  p \approx  \lsem comp\rsem(p)\ )
$


\pg{Interpreter:} a program $int$ such that
$$
\forall p, n, v_0,\ldots,v_n(\ \lsem int\rsem \ p \ v_1\ldots v_n = v_0
\mbox{\ iff\ }
\lsem p\rsem v_1\ldots v_n = v_0 \ )
$$
This can be shortened by abuse of notation: write
$
 \forall p(\ \lsem int\rsem\  p =\lsem p\rsem\  )
$
with the same meaning.

\pg{Self-interpretation:} a consequence is that
$
\forall p\ \lsem p\rsem = \lsem int\rsem\ p  = \lsem int\rsem\  int\ p 
$.

%\vspace{5mm}

\pg{Specialiser:} program $spec$ such that
$
\forall p\forall s\  \lsem\lsem spec\rsem\ p\ s\rsem = \lsem p\rsem\ s 
$.
%\vspace{5mm}

\pg{Futamura 1:}  If $q =  \lsem spec\rsem\ p\ s  $
 then 
$
\lsem q \rsem =  \lsem p\rsem\ s
 $.
 \medskip
 
Special case: $target =  \lsem spec\rsem\ int\ source  $, so
$
\lsem target\rsem = \lsem int\rsem\ source = \lsem source\rsem
$.
%\vspace{5mm}

\pg{Futamura 2:}  If $p\mbox{-}gen =  \lsem spec\rsem\ spec\ p  $
 then 
$
\forall s\ (
\lsem \lsem p\mbox{-}gen\rsem\ s \rsem =  \lsem p\rsem\ s )
 $
 \medskip
 
Special case: $comp =  \lsem spec\rsem\ spec\ int  = int\mbox{-}gen$.

% \vspace{5mm}

\pg{Futamura 3:} If $cogen =  \lsem spec\rsem\ spec\ spec  $
and $p\mbox{-}gen =  \lsem cogen\rsem\ p $ then 
$
\forall s\ (
\lsem \lsem p\mbox{-}gen\rsem\ s \rsem =  \lsem p\rsem\ s )
 $.
\medskip


Special case: $comp =  \lsem cogen\rsem\ int  = int\mbox{-}gen$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Operational semantics analogy (of Curried versions of PEAPG not's/def'ns)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bc\fbox{\bf Operational semantics analogy}
\ec

All first-order, made from Curried version of PEAPG. Not necessarily {\em one} program input and output.
No pairing function.

\medskip

{\bf Language L} 
\bi

\item A set $\mathit{Terms}$ (unspecified, closed). Elements  $e, e', p, q, comp, int, spec, source, target, cogen,  int\mbox{-}gen,  p\mbox{-}gen$.

\item A subset $\mathit{Values} \subseteq \mathit{Terms}$. Elements  $v, v', s, d$.

\item Evaluation relation $e \Downarrow v$  such that $v \Downarrow v$ for any $v \in \mathit{Values} $.  $ \Downarrow $ is in general not total.

\item Application operation $@:\mathit{Terms} \times \mathit{Terms} \to \mathit{Terms}$ (often elided, just syntax, no special interpretation).


\ei


\pg{Equality on $\mathit{Values} $}  is identity as usual. It could be extended to $\alpha$-equivalence. It should {\em not}  be extended to $\beta$-equivalence.

\pg{Program equivalence:} Observational equivalence defines
 (eliding $@$ for brevity)
$$
e \approx e'
\mbox{\ iff\ }
\forall n\forall v, v_1,\ldots,v_n \in \val
(\ e v_1\ldots v_n \Downarrow v 
\mbox{\ iff\ }
e' v_1\ldots v_n \Downarrow v \ )
$$


\pg{Relation between $\Downarrow$ and $\approx$:}   
\bi
\item $\Downarrow$ expresses computation. It is black-box for whole programs, i.e.,  so it need not deal with binding, etc. (although an {\em implementation} of  $\Downarrow$ could be done with environments, De Bruijn numbers, HOAS, etc.). 
\item Program behavior, e.g., running time, 
is visible in an implementation of  $\Downarrow$.

\item $\approx$  expresses extensional equivalence, after computations have been completed. It is used, e.g., to state the correctness of a compiler, without regard to running time or other intensional factors.
\item Program behavior, e.g., running time, 
is not relevant to or visible in   $\approx $ .
\ei


\pg{Programs as data:}   a representation (or encoding) {\em one-to-one} meta-function
$
Q : \mathit{Terms} \to \mathit{Values}
$.



\pg{L-to-L compiler:} a term $comp$ such that
$
\forall p, q\ ((comp @ Q[p]) \Downarrow Q[q] \mbox{\ implies\ } p \approx q)
$.

\pg{Interpreter:} a program $int$ such that
$
\forall p\ (\  (int\ @\ Q[p]) \approx p\ )
$.



\pg{Self-interpretation:} consequence is that
$
\forall p\ (\ int\ @\ (Q[ int\ @\ Q[p]]) \approx  (int\ @\ Q[p]) \approx p\ )
$.
\medskip

Note: double encoding of the leftmost $p$.



\pg{Specialiser:} a term $spec$ such that $\forall p\forall s\forall q
(spec\ @\ Q[p]\ @\ s) \Downarrow Q[q] \mbox{\ implies\ } q \approx  p@s 
$.
\medskip


(Note: the first $s$ is {\em not} encoded, e.g., no  $Q[s]$.)


\pg{Futamura 1:}  $\forall p\forall s\forall q$
$
(spec\ @\ Q[p]\ @\ s) \Downarrow Q[q]
\mbox{\ implies\ }
 q \approx  p@s 
 $.
\medskip


 
Special case: $(spec\ @\ Q[int]\ @\ Q[source]) \Downarrow Q[target]$, so
$target \approx int \ @\ Q[source] \approx source
$.
 \vspace{5mm}
 
\pg{Futamura 2:}  $
(spec\ @\ Q[spec]\ @\ Q[p]) \Downarrow Q[p\mbox{-}gen]
\mbox{ implies\ }
\forall s (\ 
p\mbox{-}gen@s \Downarrow Q[q]
\mbox{ implies\ }
q \approx p @ s\ )
$.
\medskip


Special case: $(spec\ @\ Q[spec]\ @\ Q[int]) \Downarrow Q[comp]$.
 \vspace{5mm}

\pg{Futamura 3:}  $
(spec\ @\ Q[spec]\ @\ Q[spec]) \Downarrow Q[cogen]¨$
and $(cogen@Q[p]) \Downarrow Q[p\mbox{-}gen]$
imply
$$
\forall s (\ 
p\mbox{-}gen@s \Downarrow Q[q]
\mbox{ implies\ }
q \approx p @ s\ )
$$
Special case: $(cogen\ @\ Q[int]) \Downarrow Q[comp]$.

\newpage


\end{document}
