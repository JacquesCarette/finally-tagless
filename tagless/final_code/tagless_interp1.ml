(* Tagless staged interpreter *)
(* Code accompanying the paper by
    Jacques Carette, Oleg Kiselyov, and Chung-chieh Shan
*)

(* The language is simply typed lambda-calculus with booleans,
   and deBruin encoding of variables.
   The language is isomorphic to the one generated by the following
   datatype definition:
   type var = VZ | VS of var
   type exp = V of var | B of bool | L of exp | A of exp * exp
*)

(* For comparison, we show the tagfull interpreter. We put it into
   a local module so not to pollute the namespace
*)
module Tagfull = struct

type var = VZ | VS of var
type exp = V of var | B of bool | L of exp | A of exp * exp
let rec lookup (x::env) = function
  | VZ -> x
  | VS v -> lookup env v
;;

(*
let rec eval0 env = function 
  | V v -> lookup env v
  | B b -> b 
  | L e -> fun x -> eval0 (x::env) e
  | A (e1,e2) -> (eval0 env e1) (eval0 env e2) 
;;
 3 inefficiencies; env: polym list? what is the result of eval0
*)

(* universal type *)
type u = UB of bool | UA of (u -> u)

let rec eval env = function
  | V v -> lookup env v
  | B b -> UB b
  | L e -> UA (fun x -> eval (x::env) e)
  | A (e1,e2) -> match eval env e1 with UA f -> f (eval env e2)
;;
(* val eval : u list -> exp -> u = <fun> *)

(* note partiality in the A rule, plus partiality in the env *)

let test1 = A (L (V VZ), B true)
let test1r = eval [] test1
(*   val test1r : u = UB true *)

;;

end;;

(* We redo Tagfull using the final approach *)

module Tagless = struct

let varZ (vc,_) = vc
let varS vp (_,envr) = vp envr
let b (bv:bool) env = bv
let lam e env = fun x -> e (x,env)
let app e1 e2 env = (e1 env) (e2 env)

let testf1 = app (lam varZ) (b true)
let testf1r = testf1 ()
(*   val testf1r : bool = true *)
;;

let testf3 = app (lam (varS varZ)) (b true)
(* The following gives the type error!
 let testf3r = testf3 ();;
*)

end;;

(* The following is the staged tagless interpreter *)
(* In CPS, as it was originally designed. It doesn't seem to matter though *)



(* implementation *)
let id x = x;;

let b (bv:bool) env = fun f -> f .<bv>.;;
let varZ (vc,_) = fun f -> f vc;;
let varS vp (_,envr) = fun f -> vp envr f;;
let app e1 e2 env = fun f -> e1 env (fun e1v -> e2 env (fun e2v -> 
  f .<.~e1v .~e2v>.));;
let lam e env = fun f -> f .<fun x -> .~(e (.<x>.,env) id)>.;;

(* tests *)

let t1 = lam varZ;;
let t11 = lam varZ () id;;

let t2 = app (lam varZ) (b true) () id;;

let t3 = (lam (lam (varS varZ))) () id;;

let t4 = app (lam (lam (varS varZ))) (lam varZ) () id;;

let t5 = (app 
	    (app (lam (lam (app (app (varS varZ) (b true)) varZ)))
               (lam (lam varZ)))
	    (b false)) () id;;

(* the following are exprected errors *)
let t6 = (app 
	    (app (lam (lam (app (app (varS varZ) (b true)) varZ)))
               (lam varZ))
	    (b false)) () id;;

let t6' = (lam (app varZ varZ)) () id;;
