(* Tagless staged partial evaluation *)
(* Code accompanying the paper by
    Jacques Carette, Oleg Kiselyov, and Chung-chieh Shan
*)

(* The language is simply typed lambda-calculus with booleans,
   and deBruin encoding of variables.
   The language is isomorphic to the one generated by the following
   datatype definition:
   type var = VZ | VS var
   type exp = V of var | A of exp * exp | L of exp |
              B of bool | I of int
*)

type ('e, 'd, 's) rep = { dynamic: ('e, 'd) code; static: 's option };;

(* implementation *)
(* base *)
let lit x env = { dynamic = .<x>.; static = Some x };;
let litf lit f env =
    { dynamic = .<f>.;
      static = Some (function
      | { static = Some x } -> lit (f x) env
      | { dynamic = x } -> { dynamic = .<f .~x>.; static = None }) };;
let varZ (vc,_) = vc;;
let varS vp (_,envr) = vp envr;;
let app e1 e2 env = match e1 env with
  | { static = Some f } -> f (e2 env)
  | { dynamic = f } -> { dynamic = .< .~f .~((e2 env).dynamic) >.;
                         static = None };;
let lam e env =
    { dynamic = .<fun x -> .~((e ({ dynamic = .<x>.;
                                    static = None }, env)).dynamic)>.;
      static = Some (fun x -> e (x, env)) };;
let iif e0 e1 e2 env = match e0 env with
  | { static = Some b } -> (if b then e1 else e2) env
  | { dynamic = b } -> { dynamic = .< if .~b then .~((e1 env).dynamic)
                                      else .~((e2 env).dynamic) >.;
                         static = None };;

(* extensions *)
(* booleans *)
let band b1 b2 = iif b1 b2 (lit false);;
let bor  b1 b2 = iif b1 (lit true) b2 ;;
let bnot env = litf lit not env;;

(* integers *)
let ( ++ ) env = litf (litf lit) ( + ) env;;
let ( ** ) env = litf (litf lit) ( * ) env;;
let ( -- ) env = litf (litf lit) ( - ) env;;
let ( // ) env = litf (litf lit) ( / ) env;;

(* pairs *)
let p env = litf (litf lit) (fun x y -> (x,y)) env;;
let pfst env = litf lit fst env;;
let psnd env = litf lit snd env;;

(* references *)
let rref env = litf lit ref env;;
let (!!) env = litf lit (fun r -> !r) env;;
let (=:) env = litf (litf lit) (:=) env;;

(* sequencing *)
let seq env = litf (litf lit) (fun a b -> b) env;;

(* even let! *)
let nlet v f env = match v env with
  | { static = Some _ } as x -> f (x, env)
  | { dynamic = c } ->
        { dynamic = .< let x = .~c in
                        .~((f ({ dynamic = .<x>.;
                                 static = None }, env)).dynamic) >.;
          static = None };;

(* tests *)
let t1 = lam varZ;;
let t11 = lam varZ ();;

let t2 = app (lam varZ) (lit true) ();;

let t3 = (lam (lam (varS varZ))) ();;

let t4 = app (lam (lam (varS varZ))) (lam varZ) ();;

let t5 = (app 
	    (app (lam (lam (app (app (varS varZ) (lit true)) varZ)))
               (lam (lam varZ)))
	    (lit false)) ();;

(* the following are exprected errors *)
(* and are commented out for testing 
let t6 = (app 
	    (app (lam (lam (app (app (varS varZ) (lit true)) varZ)))
               (lam varZ))
	    (lit false)) ();;

let t6' = (lam (app varZ varZ)) ();; *)

(* a few new tests *)
let t7 = app (app (++) (lit 5)) (lit 6) () ;;
let t8 = nlet (app (app (++) (lit 5)) (lit 6))
              (app (app ( ** ) varZ) (lit 3)) ();;
