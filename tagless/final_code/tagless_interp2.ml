(* Tagless staged interpreter *)
(* Code accompanying the paper by
    Jacques Carette, Oleg Kiselyov, and Chung-chieh Shan
*)

(* The language is simply typed lambda-calculus with booleans,
   and deBruin encoding of variables.
   The language is isomorphic to the one generated by the following
   datatype definition:
   type var = VZ | VS var
   type exp = V of var | A of exp * exp | L of exp |
              B of bool | I of int
*)


(* implementation *)
(* base *)
let varZ (vc,_) = vc;;
let varS vp (_,envr) = vp envr;;
let app e1 e2 env = .<.~(e1 env) .~(e2 env)>.;;
let lam e env = .<fun x -> .~(e (.<x>.,env))>.;;

(* extensions *)
(* booleans *)
let b (bv:bool) env = .<bv>.;;
let band b1 b2 env = .<.~(b1 env) && .~(b2 env)>. ;;
let bor b1 b2 env = .<.~(b1 env) || .~(b2 env)>. ;;
let bnot b1 env = .<not .~(b1 env)>. ;;

(* integers *)
let i (i:int) env = .<i>.;;
let (++) i j env = .< .~(i env) + .~(j env) >. ;;
let ( ** ) i j env = .< .~(i env) * .~(j env) >. ;;
let ( -- ) i j env = .< .~(i env) - .~(j env) >. ;;
let ( // ) i j env = .< .~(i env) / .~(j env) >. ;;

(* pairs *)
let p a b env = .< (.~(a env), .~(b env)) >. ;;
let pfst p env = .< fst .~(p env) >. ;;
let psnd p env = .< snd .~(p env) >. ;;

(* references *)
let rref a env = .< ref .~(a env)>. ;;
let (!!) a env = .< !(.~(a env)) >. ;;
let ( := ) aref b env = .< .~(aref env) := .~(b env) >. ;;

(* sequencing *)
let seq a b env = .< (.~(a env) ; .~(b env)) >. ;;

(* even let! *)
let nlet v f env = .< let x = .~(v env) in .~(f (.<x>.,env)) >. ;;

(* tests *)
let t1 = lam varZ;;
let t11 = lam varZ ();;

let t2 = app (lam varZ) (b true) ();;

let t3 = (lam (lam (varS varZ))) ();;

let t4 = app (lam (lam (varS varZ))) (lam varZ) ();;

let t5 = (app 
	    (app (lam (lam (app (app (varS varZ) (b true)) varZ)))
               (lam (lam varZ)))
	    (b false)) ();;

(* the following are exprected errors *)
(* and are commented out for testing 
let t6 = (app 
	    (app (lam (lam (app (app (varS varZ) (b true)) varZ)))
               (lam varZ))
	    (b false)) ();;

let t6' = (lam (app varZ varZ)) ();; *)

(* a few new tests *)
let t7 = (i 5 ++ i 6) () ;;
let t8 = nlet (i 5 ++ i 6) (varZ ** i 3) ();;
