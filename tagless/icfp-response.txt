The draft response to the reviewers is immediately below. Next follows
the (very) draft message to Norman, should we chose to send it. Next
follows some other material. Please see notes marked XXX

------------------------------------------------------------------------

Reviewer 1 questions if we solve the original problem. He writes
``Looking at section 1.3 I see a compiler, not an interpreter. Or in
other language, the solution here is to replace a deep embedding (an
interpreter) with a shallow embedding (compiling the object language
into the metalanguage).''
We take the problem as formulated in PasalicICFP02 and XiPOPL03, their
notions of interpreter and staging. We specifically use their running
example and achieve the result they call desirable.



Rev1 writes
``Furthermore, of course, shallow embeddings of this kind are not
exactly new. Even the idea of having multiple interpretations of the
pervasives of a standard language (as in the Symantics structure) has
been exploited by many (see e.g. the Lava and Hawk work, Augustsson's
clever two-level re-interpretation of Haskell (to generate residual
functions in Excel (!)), Rhiger's thesis, and many DSLs.''
XXX: do they strongly typed and tagless. Do Excel functions even
typed? So, our response is: we draw attention to the fact that our
interpretation is typed and tagless (no universal type). Augustsson's
work nor Lava (check!) fit into that category. None of them deal with PE,


Rev3 writes:
the basic idea of this paper...appeared many years ago in: Metacircularity in
the polymorphic lambda-calculus, Frank Pfenning and Peter Lee.
Type-indexed types have been around since at least Harper &
Morrisett's Compiling Polymorphism Using Intensional Type Analysis,
POPL 1995. They also were supported by Generic Haskell.

The reviewer mentions several works -- all use facilities like 
(third-order lambda-calculus in PfenningLee?) and none implemented in
the mainstream ML and Haskell distributions. Generic Haskell si not a
mainstream Haskell distribution.  We do not claim to have
solved the problem of tagless typed (staged) interpretation:
PasalicICFP02 and other works have done so. We believe we are the
first to do so using the facilities available in the mainstream ML
distributions (basically, HM and simple modules, or Haskell98,
specifically, constructor classes). References of teh reviwer
reinforce our point that the problem is believed to require facilities
that go beyond what's available in mainstream ML or Haskell. We seem
to be the first to show a counter-example.


Rev3 writes: ``GADTs are simply more flexible and easier to use.''
that may as well be. However, GADTs are
not available in the released ML distributions; the implementation of
GADT in the released version of GHC is, as publicly stated by Simon
Peyton Jones, is not fully correct.






------------------------------------------------------------------------




It appears our paper raises a question as to what is an acceptable
contribution: should solving a known open problem with existing,
elementary means count as a contribution? Or we must necessarily
strive for a complex solution, and propose new methods?

Indeed most of the components of our solution are well-known. Indeed
the solution is trivial, in the hindsight. Yet the problem of a
tagless interpreter, as formulated in the recent public record -- Pasalic
etal (ICFP02, PEPM07) and Xi etal (POPL03) -- has been declared open
and thought to require argued to require major extension to the
language, such as GADT or dependent types. The extension to tagless
partial evaluation was open too (Walid Tagless) and the solution
proposed there did not eliminate all tags. Again, the fact that our
solution is elementary and uses only existing known tools to give a
previously not known solution to an important problem should not be
counted as a disadvantage.

We did not claim to invent a new method (of partial evaluation or of
interpretation). Rather, we claim that existing, old methods, when
properly combined, can solve problem that was publicly declared to be
unsolvable with the existing, old means.

We aimed solve the problem stated in Walid02 (presented at ICFP),
and Xi (POPL2003), and extended it with partial evaluation. The problem was
claimed to be open and argued to require major extension to
the language, such as dependent types. However useful these
extensions may be, we demonstrated the the stated _open_
problem and its extensions can be solved trivially using
existing means. 

Some parts of our solution have been known before; we mention that in
the paper and reviewers point more references. However, none of the
parts have been combined to solve the open problem stated as open in
the recent published literature Walid03 and WalidTagless.




Ken said: It seems that we should appeal especially to the second reviewer, and
acknowledge that the individual techniques we use are not new (and
thank the reviewers for the references), but we use them together to
solve an important and previously unsolved problem (which, granted, has
never been defined in full generality).  The simplicity ("[not] enough
originality") of our solution speaks in favor of our approach, not
against!

Reviewer 2 wrote: ``For the staging facility for Haskell you emulate
it via a ByteCode GADT. I was rather hoping it could have been
emulated via TemplateHaskell... I realise TH is untyped and a
compile-time staging system. The claim would have been that the TH
code produces will always be type correct.''
As a matter of fact, we have done precisely that last August, with
exactly the same claim. We showed the working code to some people, who
didn't seem to be excited (perhaps due to the use of TH), so we
never mentioned that development in the paper. That code was one of
the motivations of the present paper.



Rev3 wrote: "For example, can you implement a transformation that
eliminates eta-expansions from a term?"

Rev3 wrote: "This continual modification of your framework is disturbing. Is
there a general case that parameterizes the type by three types---the
case for int, the case for bool and the case for arrow?"

