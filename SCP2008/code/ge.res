        Objective Caml version 3.09.1

#               module GEF :
  sig
    module D :
      sig
        module type DOMAIN =
          sig
            type v
            val kind : Domains_sig.domain_kind
            val zero : v
            val one : v
            val plus : v -> v -> v
            val times : v -> v -> v
            val minus : v -> v -> v
            val uminus : v -> v
            val div : v -> v -> v
            val better_than : (v -> v -> bool) option
            val normalizer : (v -> v) option
          end
        module type DOMAINL =
          sig
            type v
            val kind : Domains_sig.domain_kind
            val zero : v
            val one : v
            val plus : v -> v -> v
            val times : v -> v -> v
            val minus : v -> v -> v
            val uminus : v -> v
            val div : v -> v -> v
            val better_than : (v -> v -> bool) option
            val normalizer : (v -> v) option
            type 'a vc = ('a, v) Code.abstract
            val zeroL : 'a vc
            val oneL : 'a vc
            val ( +^ ) : 'a vc -> 'a vc -> 'a vc
            val ( *^ ) : 'a vc -> 'a vc -> 'a vc
            val ( -^ ) : 'a vc -> 'a vc -> 'a vc
            val uminusL : 'a vc -> 'a vc
            val divL : 'a vc -> 'a vc -> 'a vc
            val better_thanL :
              ('a vc -> 'a vc -> ('a, bool) Code.abstract) option
            val normalizerL : ('a vc -> 'a vc) option
          end
        module type CONTAINER2D =
          sig
            module Dom : DOMAINL
            type contr
            type 'a vc = ('a, contr) Code.abstract
            type 'a vo = ('a, Dom.v) Code.abstract
            val getL :
              'a vc ->
              ('a, int) Code.abstract -> ('a, int) Code.abstract -> 'a vo
            val dim1 : 'a vc -> ('a, int) Code.abstract
            val dim2 : 'a vc -> ('a, int) Code.abstract
            val mapper : ('a vo -> 'a vo) option -> 'a vc -> 'a vc
            val copy : 'a vc -> 'a vc
            val init :
              ('a, int) Code.abstract -> ('a, int) Code.abstract -> 'a vc
            val augment :
              'a vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a vc -> ('a, int) Code.abstract -> 'a vc
            val identity :
              ('a, int) Code.abstract -> ('a, int) Code.abstract -> 'a vc
            val swap_rows_stmt :
              'a vc ->
              ('a, int) Code.abstract option ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract -> ('a, unit) Code.abstract
            val swap_cols_stmt :
              'a vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract -> ('a, unit) Code.abstract
            val row_head :
              'a vc ->
              ('a, int) Code.abstract -> ('a, int) Code.abstract -> 'a vo
            val col_head_set :
              'a vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract -> 'a vo -> ('a, unit) Code.abstract
          end
      end
    type ('a, 'b) cmonad =
        (< answer : ('d, 'c) Code.abstract; state : 'e list >,
         ('d, 'b) Code.abstract)
        StateCPSMonad.monad
      constraint 'a = < answer : 'c; classif : 'd; state : 'e; .. >
    type ('a, 'b) omonad =
        (< answer : ('d, 'c) Code.abstract; state : 'e list >,
         ('d, 'b) Code.abstract option)
        StateCPSMonad.monad
      constraint 'a = < answer : 'c; classif : 'd; state : 'e; .. >
    module Iters :
      sig
        val row_iter :
          'a ->
          'b ->
          ('c, int) Code.abstract ->
          ('c, int) Code.abstract ->
          ('a -> ('c, int) Code.abstract -> 'b -> ('c, 'd) Code.abstract) ->
          (('c, int) Code.abstract ->
           ('c, 'd) Code.abstract ->
           (< answer : ('c, 'e) Code.abstract; state : 'f; .. >,
            ('c, 'e) Code.abstract)
           StateCPSMonad.monad) ->
          Prelude.dir -> 'f -> ('f -> ('c, unit) Code.abstract -> 'g) -> 'g
        val col_iter :
          'a ->
          'b ->
          ('c, int) Code.abstract ->
          ('c, int) Code.abstract ->
          ('a -> 'b -> ('c, int) Code.abstract -> 'd) ->
          (('c, int) Code.abstract ->
           'd ->
           (< answer : ('c, 'e) Code.abstract; state : 'f; .. >,
            ('c, 'e) Code.abstract)
           StateCPSMonad.monad) ->
          Prelude.dir -> 'f -> ('f -> ('c, unit) Code.abstract -> 'g) -> 'g
      end
    module TrackRank :
      sig
        type 'a lstate = ('a, int ref) Code.abstract
        type 'a tag_lstate_ = [ `TRan of 'a lstate ]
        type 'a tag_lstate = 'a tag_lstate_
        type ('a, 'b) lm = ('a, 'b) cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> 'd tag_lstate ]; .. >
        val ip :
          ('a -> [> `TRan of 'a ]) * ([> `TRan of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TRan of ('a, int ref) Code.abstract ] list; .. >,
           ('a, int ref) Code.abstract)
          StateCPSMonad.monad
        val succ :
          unit ->
          (< answer : 'a;
             state : [> `TRan of ('b, int ref) Code.abstract ] list; .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        module type RANK =
          sig
            type 'a tag_lstate = 'a tag_lstate_
            val decl :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               int ref)
              lm
            val succ :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               unit)
              lm
            val fin :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               int)
              lm
          end
      end
    module Rank :
      sig
        type 'a lstate = ('a, int ref) Code.abstract
        type 'a tag_lstate_ = [ `TRan of 'a lstate ]
        type 'a tag_lstate = 'a tag_lstate_
        type ('a, 'b) lm = ('a, 'b) cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> 'd tag_lstate ]; .. >
        val ip :
          ('a -> [> `TRan of 'a ]) * ([> `TRan of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TRan of ('a, int ref) Code.abstract ] list; .. >,
           ('a, int ref) Code.abstract)
          StateCPSMonad.monad
        val succ :
          unit ->
          (< answer : 'a;
             state : [> `TRan of ('b, int ref) Code.abstract ] list; .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        module type RANK =
          sig
            type 'a tag_lstate = 'a tag_lstate_
            val decl :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               int ref)
              lm
            val succ :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               unit)
              lm
            val fin :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               int)
              lm
          end
        val fin :
          unit ->
          (< answer : 'a;
             state : [> `TRan of ('b, 'c ref) Code.abstract ] list; .. >,
           ('b, 'c) Code.abstract)
          StateCPSMonad.monad
      end
    module NoRank :
      sig
        type 'a lstate = ('a, int ref) Code.abstract
        type 'a tag_lstate_ = [ `TRan of 'a lstate ]
        type 'a tag_lstate = 'a tag_lstate_
        type ('a, 'b) lm = ('a, 'b) cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> 'd tag_lstate ]; .. >
        val ip :
          ('a -> [> `TRan of 'a ]) * ([> `TRan of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TRan of ('a, int ref) Code.abstract ] list; .. >,
           ('a, int ref) Code.abstract)
          StateCPSMonad.monad
        val succ :
          unit ->
          (< answer : 'a;
             state : [> `TRan of ('b, int ref) Code.abstract ] list; .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        module type RANK =
          sig
            type 'a tag_lstate = 'a tag_lstate_
            val decl :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               int ref)
              lm
            val succ :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               unit)
              lm
            val fin :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               int)
              lm
          end
        val fin : unit -> 'a
      end
    module type PIVOTKIND =
      sig
        type perm_rep
        type 'a ira = ('a, int) Code.abstract
        type 'a fra
        type 'a pra = ('a, perm_rep) Code.abstract
        val add : 'a fra -> 'a pra -> 'a pra
        val empty : 'a ira -> 'a pra
        val rowrep : 'a ira -> 'a ira -> 'a fra
        val colrep : 'a ira -> 'a ira -> 'a fra
      end
    module PermList :
      sig
        type flip_rep = Code.perm
        type perm_rep = Code.perm list
        type 'a ira = ('a, int) Code.abstract
        type 'a fra = ('a, flip_rep) Code.abstract
        type 'a pra = ('a, perm_rep) Code.abstract
        val add :
          ('a, 'b) Code.abstract ->
          ('a, 'b list) Code.abstract -> ('a, 'b list) Code.abstract
        val empty : 'a -> 'b pra
        val rowrep :
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract -> ('a, Code.perm) Code.abstract
        val colrep :
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract -> ('a, Code.perm) Code.abstract
      end
    module RowVectorPerm :
      sig
        type flip_rep = int * int
        type perm_rep = int array
        type 'a ira = ('a, int) Code.abstract
        type 'a fra = ('a, flip_rep) Code.abstract
        type 'a pra = ('a, perm_rep) Code.abstract
        val add :
          ('a, int * int) Code.abstract ->
          ('a, int array) Code.abstract -> ('a, int array) Code.abstract
        val empty : ('a, int) Code.abstract -> ('a, int array) Code.abstract
        val rowrep :
          ('a, 'b) Code.abstract ->
          ('a, 'c) Code.abstract -> ('a, 'b * 'c) Code.abstract
        val colrep :
          ('a, 'b) Code.abstract ->
          ('a, 'c) Code.abstract -> ('a, 'b * 'c) Code.abstract
      end
    module type TRACKPIVOT =
      sig
        type perm_rep
        type 'a ira = ('a, int) Code.abstract
        type 'a fra
        type 'a pra
        type 'a lstate
        type ('a, 'b) lm = ('a, 'b) cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TPivot of 'd lstate ];
              .. >
        val rowrep : 'a ira -> 'a ira -> 'a fra
        val colrep : 'a ira -> 'a ira -> 'a fra
        val decl :
          ('a, int) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TPivot of 'a lstate ];
             .. >,
           unit)
          lm
        val add :
          'a fra ->
          (< answer : 'b; classif : 'a; state : [> `TPivot of 'a lstate ];
             .. >,
           unit)
          omonad
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TPivot of 'b lstate ];
             .. >,
           perm_rep)
          lm
      end
    module PivotCommon :
      functor (PK : PIVOTKIND) ->
        sig
          type perm_rep = PK.perm_rep
          type 'a ira = 'a PK.ira
          type 'a fra = 'a PK.fra
          type 'a pra = 'a PK.pra
          type 'a lstate = ('a, PK.perm_rep ref) Code.abstract
          type ('a, 'b) lm = ('a, 'b) cmonad
            constraint 'a =
              < answer : 'c; classif : 'd; state : [> `TPivot of 'd lstate ];
                .. >
          val rowrep : 'a PK.ira -> 'a PK.ira -> 'a PK.fra
          val colrep : 'a PK.ira -> 'a PK.ira -> 'a PK.fra
          val ip :
            ('a -> [> `TPivot of 'a ]) * ([> `TPivot of 'b ] -> 'b option) *
            string
        end
    module KeepPivot :
      functor (PK : PIVOTKIND) ->
        sig
          type perm_rep = PK.perm_rep
          type 'a ira = 'a PK.ira
          type 'a fra = 'a PK.fra
          type 'a pra = 'a PK.pra
          type 'a lstate = ('a, PK.perm_rep ref) Code.abstract
          type ('a, 'b) lm = ('a, 'b) cmonad
            constraint 'a =
              < answer : 'c; classif : 'd; state : [> `TPivot of 'd lstate ];
                .. >
          val rowrep : 'a PK.ira -> 'a PK.ira -> 'a PK.fra
          val colrep : 'a PK.ira -> 'a PK.ira -> 'a PK.fra
          val ip :
            ('a -> [> `TPivot of 'a ]) * ([> `TPivot of 'b ] -> 'b option) *
            string
          val decl :
            'a PK.ira ->
            (< answer : ('a, 'b) Code.abstract;
               state : [> `TPivot of ('a, PK.perm_rep ref) Code.abstract ]
                       list;
               .. >,
             ('c, unit) Code.abstract)
            StateCPSMonad.monad
          val add :
            'a PK.fra ->
            (< answer : 'b;
               state : [> `TPivot of ('a, PK.perm_rep ref) Code.abstract ]
                       list;
               .. >,
             ('a, unit) Code.abstract option)
            StateCPSMonad.monad
          val fin :
            unit ->
            (< answer : 'a;
               state : [> `TPivot of ('b, 'c ref) Code.abstract ] list; .. >,
             ('b, 'c) Code.abstract)
            StateCPSMonad.monad
        end
    module DiscardPivot :
      sig
        type perm_rep = PermList.perm_rep
        type 'a ira = 'a PermList.ira
        type 'a fra = 'a PermList.fra
        type 'a pra = 'a PermList.pra
        type 'a lstate = ('a, PermList.perm_rep ref) Code.abstract
        type ('a, 'b) lm = ('a, 'b) cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TPivot of 'd lstate ];
              .. >
        val rowrep : 'a PermList.ira -> 'a PermList.ira -> 'a PermList.fra
        val colrep : 'a PermList.ira -> 'a PermList.ira -> 'a PermList.fra
        val ip :
          ('a -> [> `TPivot of 'a ]) * ([> `TPivot of 'b ] -> 'b option) *
          string
        val decl : 'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val add :
          'a ->
          (< answer : 'b; state : 'c; .. >, 'd option) StateCPSMonad.monad
        val fin : unit -> 'a
      end
    module GenLA :
      functor (C : D.CONTAINER2D) ->
        sig
          type 'a wmatrix =
            'a Ge.LAMake(Code).GenLA(C).wmatrix = {
            matrix : 'a C.vc;
            numrow : ('a, int) Code.abstract;
            numcol : ('a, int) Code.abstract;
          }
          type 'a curpos =
            'a Ge.LAMake(Code).GenLA(C).curpos = {
            rowpos : ('a, int) Code.abstract;
            colpos : ('a, int) Code.abstract;
          }
          type 'a curposval =
            'a Ge.LAMake(Code).GenLA(C).curposval = {
            p : 'a curpos;
            curval : ('a, C.Dom.v) Code.abstract;
          }
          module type DETERMINANT =
            sig
              type tdet = C.Dom.v ref
              type 'a lstate
              type ('a, 'b) lm = ('a, 'b) cmonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TDet of 'd lstate ]; .. >
              type ('a, 'b) om = ('a, 'b) omonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TDet of 'd lstate ]; .. >
              val decl :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 unit)
                lm
              val upd_sign :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 unit)
                om
              val zero_sign :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 unit)
                lm
              val acc_magn :
                ('a, C.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a lstate ]; .. >,
                 unit)
                lm
              val get_magn :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 tdet)
                lm
              val set_magn :
                ('a, C.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a lstate ]; .. >,
                 unit)
                lm
              val fin :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 C.Dom.v)
                lm
            end
          module type LOWER =
            sig
              type 'a lstate = ('a, C.contr) Code.abstract
              type ('a, 'b) lm = ('a, 'b) cmonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TLower of 'd lstate ]; .. >
              val decl :
                ('a, C.contr) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TLower of 'a lstate ]; .. >,
                 C.contr)
                lm
              val updt :
                'a C.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'a C.vo ->
                'a C.Dom.vc ->
                (< answer : 'b; classif : 'a;
                   state : [> `TLower of 'a lstate ]; .. >,
                 unit)
                lm option
              val fin :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TLower of 'b lstate ]; .. >,
                 C.contr)
                lm
              val wants_pack : bool
            end
          module type PIVOT =
            functor (D : DETERMINANT) ->
              functor (P : TRACKPIVOT) ->
                functor (L : LOWER) ->
                  sig
                    val findpivot :
                      'a wmatrix ->
                      'a curpos ->
                      (< answer : 'b; classif : 'a;
                         state : [> `TDet of 'a D.lstate
                                  | `TPivot of 'a P.lstate ];
                         .. >,
                       C.Dom.v option)
                      cmonad
                  end
          module NoDet :
            sig
              type tdet = C.Dom.v ref
              type 'a lstate = unit
              val decl :
                unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
              val upd_sign :
                unit ->
                (< answer : 'a; state : 'b; .. >, 'c option)
                StateCPSMonad.monad
              val zero_sign :
                unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
              val acc_magn :
                'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
              val get_magn :
                unit ->
                (< answer : 'a; state : 'b; .. >,
                 ('c, C.Dom.v ref) Code.abstract)
                StateCPSMonad.monad
              val set_magn :
                'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
              val fin : unit -> 'a
              type ('a, 'b) lm = ('a, 'b) cmonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TDet of 'd lstate ]; .. >
              type ('a, 'b) om = ('a, 'b) omonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TDet of 'd lstate ]; .. >
            end
          module AbstractDet :
            sig
              type tdet = C.Dom.v ref
              type 'a lstate =
                  ('a, int ref) Code.abstract * ('a, tdet) Code.abstract
              type ('a, 'b) lm = ('a, 'b) cmonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TDet of 'd lstate ]; .. >
              type ('a, 'b) om = ('a, 'b) omonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TDet of 'd lstate ]; .. >
              val ip :
                ('a -> [> `TDet of 'a ]) * ([> `TDet of 'b ] -> 'b option) *
                string
              val decl :
                unit ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of
                                ('a, int ref) Code.abstract *
                                ('a, C.Dom.v ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, unit) Code.abstract)
                StateCPSMonad.monad
              val upd_sign :
                unit ->
                (< answer : 'a;
                   state : [> `TDet of ('b, int ref) Code.abstract * 'c ]
                           list;
                   .. >,
                 ('b, unit) Code.abstract option)
                StateCPSMonad.monad
              val zero_sign :
                unit ->
                (< answer : 'a;
                   state : [> `TDet of ('b, int ref) Code.abstract * 'c ]
                           list;
                   .. >,
                 ('b, unit) Code.abstract)
                StateCPSMonad.monad
              val get_magn :
                unit ->
                (< answer : 'a; state : [> `TDet of 'b * 'c ] list; .. >, 'c)
                StateCPSMonad.monad
              val set_magn :
                ('a, 'b) Code.abstract ->
                (< answer : 'c;
                   state : [> `TDet of 'd * ('a, 'b ref) Code.abstract ] list;
                   .. >,
                 ('a, unit) Code.abstract)
                StateCPSMonad.monad
              val acc_magn :
                'a C.Dom.vc ->
                (< answer : 'b;
                   state : [> `TDet of 'c * ('a, C.Dom.v ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, unit) Code.abstract)
                StateCPSMonad.monad
              val fin :
                unit ->
                (< answer : 'a;
                   state : [> `TDet of
                                ('b, int ref) Code.abstract *
                                ('b, C.Dom.v ref) Code.abstract ]
                           list;
                   .. >,
                 ('b, C.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
          module type UPDATE =
            functor (D : DETERMINANT) ->
              sig
                type 'a in_val = 'a C.Dom.vc
                val update :
                  'a in_val ->
                  'a in_val ->
                  'a in_val ->
                  'a in_val ->
                  ('a in_val -> ('a, unit) Code.abstract) ->
                  ('a, C.Dom.v ref) Code.abstract ->
                  (< answer : 'b; classif : 'a; state : 'c; .. >, unit)
                  cmonad
                val update_det :
                  'a in_val ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TDet of 'a D.lstate ]; .. >,
                   unit)
                  D.lm
                val upd_kind : Ge.update_kind
              end
          module GE :
            sig
              module DivisionUpdate :
                functor (Det : DETERMINANT) ->
                  sig
                    type 'a in_val = 'a C.Dom.vc
                    val update :
                      'a C.Dom.vc ->
                      'a C.Dom.vc ->
                      'a C.Dom.vc ->
                      'a C.Dom.vc ->
                      ('a C.Dom.vc -> 'b) ->
                      'c ->
                      (< answer : 'd; state : 'e; .. >, 'b)
                      StateCPSMonad.monad
                    val update_det :
                      ('a, C.Dom.v) Code.abstract ->
                      (< answer : 'b; classif : 'a;
                         state : [> `TDet of 'a Det.lstate ]; .. >,
                       unit)
                      Det.lm
                    val upd_kind : Ge.update_kind
                  end
              module FractionFreeUpdate :
                functor (Det : DETERMINANT) ->
                  sig
                    type 'a in_val = 'a C.Dom.vc
                    val update :
                      'a C.Dom.vc ->
                      'a C.Dom.vc ->
                      'a C.Dom.vc ->
                      'a C.Dom.vc ->
                      ('a C.Dom.vc -> 'b) ->
                      ('a, C.Dom.v ref) Code.abstract ->
                      (< answer : 'c; state : 'd; .. >, 'b)
                      StateCPSMonad.monad
                    val update_det :
                      ('a, C.Dom.v) Code.abstract ->
                      (< answer : 'b; classif : 'a;
                         state : [> `TDet of 'a Det.lstate ]; .. >,
                       unit)
                      Det.lm
                    val upd_kind : Ge.update_kind
                  end
              module TrackLower :
                sig
                  type 'a lstate = ('a, C.contr) Code.abstract
                  type ('a, 'b) lm = ('a, 'b) cmonad
                    constraint 'a =
                      < answer : 'c; classif : 'd;
                        state : [> `TLower of 'd lstate ]; .. >
                  val ip :
                    ('a -> [> `TLower of 'a ]) *
                    ([> `TLower of 'b ] -> 'b option) * string
                end
              module SeparateLower :
                sig
                  type 'a lstate = ('a, C.contr) Code.abstract
                  type ('a, 'b) lm = ('a, 'b) cmonad
                    constraint 'a =
                      < answer : 'c; classif : 'd;
                        state : [> `TLower of 'd lstate ]; .. >
                  val ip :
                    ('a -> [> `TLower of 'a ]) *
                    ([> `TLower of 'b ] -> 'b option) * string
                  val decl :
                    ('a, 'b) Code.abstract ->
                    (< answer : ('a, 'c) Code.abstract;
                       state : [> `TLower of ('a, 'b) Code.abstract ] list;
                       .. >,
                     ('a, 'b) Code.abstract)
                    StateCPSMonad.monad
                  val updt :
                    'a C.vc ->
                    ('a, int) Code.abstract ->
                    ('a, int) Code.abstract ->
                    'a C.vo ->
                    'a C.vo ->
                    (< answer : 'b; state : [> `TLower of 'a C.vc ] list;
                       .. >,
                     ('a, unit) Code.abstract)
                    StateCPSMonad.monad option
                  val fin :
                    unit ->
                    (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                     'b)
                    StateCPSMonad.monad
                  val wants_pack : bool
                end
              module PackedLower :
                sig
                  type 'a lstate = ('a, C.contr) Code.abstract
                  type ('a, 'b) lm = ('a, 'b) cmonad
                    constraint 'a =
                      < answer : 'c; classif : 'd;
                        state : [> `TLower of 'd lstate ]; .. >
                  val ip :
                    ('a -> [> `TLower of 'a ]) *
                    ([> `TLower of 'b ] -> 'b option) * string
                  val decl :
                    'a ->
                    (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                     'a)
                    StateCPSMonad.monad
                  val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                  val fin :
                    unit ->
                    (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                     'b)
                    StateCPSMonad.monad
                  val wants_pack : bool
                end
              module NoLower :
                sig
                  type 'a lstate = ('a, C.contr) Code.abstract
                  type ('a, 'b) lm = ('a, 'b) cmonad
                    constraint 'a =
                      < answer : 'c; classif : 'd;
                        state : [> `TLower of 'd lstate ]; .. >
                  val ip :
                    ('a -> [> `TLower of 'a ]) *
                    ([> `TLower of 'b ] -> 'b option) * string
                  val decl :
                    'a ->
                    (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
                  val updt :
                    'a C.vc ->
                    ('a, int) Code.abstract ->
                    ('a, int) Code.abstract ->
                    'a C.vo ->
                    'b ->
                    (< answer : 'c; state : 'd; .. >,
                     ('a, unit) Code.abstract)
                    StateCPSMonad.monad option
                  val fin : unit -> 'a
                  val wants_pack : bool
                end
              module type INPUT =
                sig
                  type inp
                  val get_input :
                    ('a, inp) Code.abstract ->
                    (< answer : 'b; classif : 'a; state : 'c; .. >,
                     ('a, C.contr) Code.abstract * ('a, int) Code.abstract *
                     bool)
                    StateCPSMonad.monad
                end
              module InpJustMatrix :
                sig
                  type inp = C.contr
                  val get_input :
                    'a C.vc ->
                    (< answer : 'b; state : 'c; .. >,
                     'a C.vc * ('a, int) Code.abstract * bool)
                    StateCPSMonad.monad
                end
              module InpMatrixMargin :
                sig
                  type inp = C.contr * int
                  val get_input :
                    ('a, 'b * 'c) Code.abstract ->
                    (< answer : 'd; state : 'e; .. >,
                     ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
                    StateCPSMonad.monad
                end
              module RowPivot :
                functor (Det : DETERMINANT) ->
                  functor (P : TRACKPIVOT) ->
                    functor (L : LOWER) ->
                      sig
                        val optim : 'a -> 'a option
                        val findpivot :
                          'a wmatrix ->
                          'a curpos ->
                          (< answer : ('a, 'b) Code.abstract;
                             state : [> `TDet of 'a Det.lstate
                                      | `TPivot of 'a P.lstate ]
                                     list;
                             .. >,
                           ('a, C.Dom.v option) Code.abstract)
                          StateCPSMonad.monad
                      end
              module FullPivot :
                functor (Det : DETERMINANT) ->
                  functor (P : TRACKPIVOT) ->
                    functor (L : LOWER) ->
                      sig
                        val optim : 'a -> 'a option
                        val findpivot :
                          'a wmatrix ->
                          'a curpos ->
                          (< answer : ('a, 'b) Code.abstract;
                             state : [> `TDet of 'a Det.lstate
                                      | `TPivot of 'a P.lstate ]
                                     list;
                             .. >,
                           ('a, C.Dom.v option) Code.abstract)
                          StateCPSMonad.monad
                      end
              module NoPivot :
                functor (Det : DETERMINANT) ->
                  functor (P : TRACKPIVOT) ->
                    functor (L : LOWER) ->
                      sig
                        val findpivot :
                          'a wmatrix ->
                          'a curpos ->
                          (< answer : 'b; state : 'c; .. >,
                           ('a, C.Dom.v option) Code.abstract)
                          StateCPSMonad.monad
                      end
              module type OUTPUTDEP =
                sig module PivotRep : PIVOTKIND module Det : DETERMINANT end
              module OutJustMatrix :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin : unit -> 'a
                          end
                        module P :
                          sig
                            type perm_rep = PermList.perm_rep
                            type 'a ira = 'a PermList.ira
                            type 'a fra = 'a PermList.fra
                            type 'a pra = 'a PermList.pra
                            type 'a lstate =
                                ('a, PermList.perm_rep ref) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            val rowrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val colrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              'b ->
                              ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                            val add :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'd option)
                              StateCPSMonad.monad
                            val fin : unit -> 'a
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'a)
                              StateCPSMonad.monad
                            val updt :
                              'a C.vc ->
                              ('a, int) Code.abstract ->
                              ('a, int) Code.abstract ->
                              'a C.vo ->
                              'b ->
                              (< answer : 'c; state : 'd; .. >,
                               ('a, unit) Code.abstract)
                              StateCPSMonad.monad option
                            val fin : unit -> 'a
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr
                    val make_result :
                      'a wmatrix ->
                      (< answer : 'b; state : 'c; .. >, 'a C.vc)
                      StateCPSMonad.monad
                  end
              module OutDet :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin : unit -> 'a
                          end
                        module P :
                          sig
                            type perm_rep = PermList.perm_rep
                            type 'a ira = 'a PermList.ira
                            type 'a fra = 'a PermList.fra
                            type 'a pra = 'a PermList.pra
                            type 'a lstate =
                                ('a, PermList.perm_rep ref) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            val rowrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val colrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              'b ->
                              ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                            val add :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'd option)
                              StateCPSMonad.monad
                            val fin : unit -> 'a
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'a)
                              StateCPSMonad.monad
                            val updt :
                              'a C.vc ->
                              ('a, int) Code.abstract ->
                              ('a, int) Code.abstract ->
                              'a C.vo ->
                              'b ->
                              (< answer : 'c; state : 'd; .. >,
                               ('a, unit) Code.abstract)
                              StateCPSMonad.monad option
                            val fin : unit -> 'a
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr * C.Dom.v
                    val make_result :
                      'a wmatrix ->
                      (< answer : ('a, 'b) Code.abstract;
                         state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                       ('a, C.contr * C.Dom.v) Code.abstract)
                      StateCPSMonad.monad
                  end
              module OutRank :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, 'c ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, 'c) Code.abstract)
                              StateCPSMonad.monad
                          end
                        module P :
                          sig
                            type perm_rep = PermList.perm_rep
                            type 'a ira = 'a PermList.ira
                            type 'a fra = 'a PermList.fra
                            type 'a pra = 'a PermList.pra
                            type 'a lstate =
                                ('a, PermList.perm_rep ref) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            val rowrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val colrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              'b ->
                              ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                            val add :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'd option)
                              StateCPSMonad.monad
                            val fin : unit -> 'a
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'a)
                              StateCPSMonad.monad
                            val updt :
                              'a C.vc ->
                              ('a, int) Code.abstract ->
                              ('a, int) Code.abstract ->
                              'a C.vo ->
                              'b ->
                              (< answer : 'c; state : 'd; .. >,
                               ('a, unit) Code.abstract)
                              StateCPSMonad.monad option
                            val fin : unit -> 'a
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr * int
                    val make_result :
                      'a wmatrix ->
                      (< answer : 'b;
                         state : [> `TRan of ('a, 'c ref) Code.abstract ]
                                 list;
                         .. >,
                       ('a, C.contr * 'c) Code.abstract)
                      StateCPSMonad.monad
                  end
              module OutDetRank :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, 'c ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, 'c) Code.abstract)
                              StateCPSMonad.monad
                          end
                        module P :
                          sig
                            type perm_rep = PermList.perm_rep
                            type 'a ira = 'a PermList.ira
                            type 'a fra = 'a PermList.fra
                            type 'a pra = 'a PermList.pra
                            type 'a lstate =
                                ('a, PermList.perm_rep ref) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            val rowrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val colrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              'b ->
                              ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                            val add :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'd option)
                              StateCPSMonad.monad
                            val fin : unit -> 'a
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'a)
                              StateCPSMonad.monad
                            val updt :
                              'a C.vc ->
                              ('a, int) Code.abstract ->
                              ('a, int) Code.abstract ->
                              'a C.vo ->
                              'b ->
                              (< answer : 'c; state : 'd; .. >,
                               ('a, unit) Code.abstract)
                              StateCPSMonad.monad option
                            val fin : unit -> 'a
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr * C.Dom.v * int
                    val make_result :
                      'a wmatrix ->
                      (< answer : ('a, 'b) Code.abstract;
                         state : [> `TDet of 'a OD.Det.lstate
                                  | `TRan of ('a, 'c ref) Code.abstract ]
                                 list;
                         .. >,
                       ('a, C.contr * C.Dom.v * 'c) Code.abstract)
                      StateCPSMonad.monad
                  end
              module OutDetRankPivot :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, 'c ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, 'c) Code.abstract)
                              StateCPSMonad.monad
                          end
                        module P :
                          sig
                            type perm_rep = OD.PivotRep.perm_rep
                            type 'a ira = 'a OD.PivotRep.ira
                            type 'a fra = 'a OD.PivotRep.fra
                            type 'a pra = 'a OD.PivotRep.pra
                            type 'a lstate =
                                ('a, OD.PivotRep.perm_rep ref) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            val rowrep :
                              'a OD.PivotRep.ira ->
                              'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                            val colrep :
                              'a OD.PivotRep.ira ->
                              'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a OD.PivotRep.ira ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TPivot of
                                              ('a, OD.PivotRep.perm_rep ref)
                                              Code.abstract ]
                                         list;
                                 .. >,
                               ('c, unit) Code.abstract)
                              StateCPSMonad.monad
                            val add :
                              'a OD.PivotRep.fra ->
                              (< answer : 'b;
                                 state : [> `TPivot of
                                              ('a, OD.PivotRep.perm_rep ref)
                                              Code.abstract ]
                                         list;
                                 .. >,
                               ('a, unit) Code.abstract option)
                              StateCPSMonad.monad
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TPivot of
                                              ('b, 'c ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, 'c) Code.abstract)
                              StateCPSMonad.monad
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'a)
                              StateCPSMonad.monad
                            val updt :
                              'a C.vc ->
                              ('a, int) Code.abstract ->
                              ('a, int) Code.abstract ->
                              'a C.vo ->
                              'b ->
                              (< answer : 'c; state : 'd; .. >,
                               ('a, unit) Code.abstract)
                              StateCPSMonad.monad option
                            val fin : unit -> 'a
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr * C.Dom.v * int * IF.P.perm_rep
                    val make_result :
                      'a wmatrix ->
                      (< answer : ('a, 'b) Code.abstract;
                         state : [> `TDet of 'a OD.Det.lstate
                                  | `TPivot of ('a, 'c ref) Code.abstract
                                  | `TRan of ('a, 'd ref) Code.abstract ]
                                 list;
                         .. >,
                       ('a, C.contr * C.Dom.v * 'd * 'c) Code.abstract)
                      StateCPSMonad.monad
                  end
              module Out_L_U :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin : unit -> 'a
                          end
                        module P :
                          sig
                            type perm_rep = OD.PivotRep.perm_rep
                            type 'a ira = 'a OD.PivotRep.ira
                            type 'a fra = 'a OD.PivotRep.fra
                            type 'a pra = 'a OD.PivotRep.pra
                            type 'a lstate =
                                ('a, OD.PivotRep.perm_rep ref) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            val rowrep :
                              'a OD.PivotRep.ira ->
                              'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                            val colrep :
                              'a OD.PivotRep.ira ->
                              'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a OD.PivotRep.ira ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TPivot of
                                              ('a, OD.PivotRep.perm_rep ref)
                                              Code.abstract ]
                                         list;
                                 .. >,
                               ('c, unit) Code.abstract)
                              StateCPSMonad.monad
                            val add :
                              'a OD.PivotRep.fra ->
                              (< answer : 'b;
                                 state : [> `TPivot of
                                              ('a, OD.PivotRep.perm_rep ref)
                                              Code.abstract ]
                                         list;
                                 .. >,
                               ('a, unit) Code.abstract option)
                              StateCPSMonad.monad
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TPivot of
                                              ('b, 'c ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, 'c) Code.abstract)
                              StateCPSMonad.monad
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              ('a, 'b) Code.abstract ->
                              (< answer : ('a, 'c) Code.abstract;
                                 state : [> `TLower of ('a, 'b) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, 'b) Code.abstract)
                              StateCPSMonad.monad
                            val updt :
                              'a C.vc ->
                              ('a, int) Code.abstract ->
                              ('a, int) Code.abstract ->
                              'a C.vo ->
                              'a C.vo ->
                              (< answer : 'b;
                                 state : [> `TLower of 'a C.vc ] list; .. >,
                               ('a, unit) Code.abstract)
                              StateCPSMonad.monad option
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TLower of 'b ] list; .. >,
                               'b)
                              StateCPSMonad.monad
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr * C.contr * IF.P.perm_rep
                    val make_result :
                      'a wmatrix ->
                      (< answer : 'b;
                         state : [> `TLower of ('a, 'c) Code.abstract
                                  | `TPivot of ('a, 'd ref) Code.abstract ]
                                 list;
                         .. >,
                       ('a, C.contr * 'c * 'd) Code.abstract)
                      StateCPSMonad.monad
                  end
              module Out_LU_Packed :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin : unit -> 'a
                          end
                        module P :
                          sig
                            type perm_rep = OD.PivotRep.perm_rep
                            type 'a ira = 'a OD.PivotRep.ira
                            type 'a fra = 'a OD.PivotRep.fra
                            type 'a pra = 'a OD.PivotRep.pra
                            type 'a lstate =
                                ('a, OD.PivotRep.perm_rep ref) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            val rowrep :
                              'a OD.PivotRep.ira ->
                              'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                            val colrep :
                              'a OD.PivotRep.ira ->
                              'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a OD.PivotRep.ira ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TPivot of
                                              ('a, OD.PivotRep.perm_rep ref)
                                              Code.abstract ]
                                         list;
                                 .. >,
                               ('c, unit) Code.abstract)
                              StateCPSMonad.monad
                            val add :
                              'a OD.PivotRep.fra ->
                              (< answer : 'b;
                                 state : [> `TPivot of
                                              ('a, OD.PivotRep.perm_rep ref)
                                              Code.abstract ]
                                         list;
                                 .. >,
                               ('a, unit) Code.abstract option)
                              StateCPSMonad.monad
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TPivot of
                                              ('b, 'c ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, 'c) Code.abstract)
                              StateCPSMonad.monad
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b;
                                 state : [> `TLower of 'a ] list; .. >,
                               'a)
                              StateCPSMonad.monad
                            val updt :
                              'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TLower of 'b ] list; .. >,
                               'b)
                              StateCPSMonad.monad
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr * IF.P.perm_rep
                    val make_result :
                      'a ->
                      (< answer : 'b;
                         state : [> `TLower of ('c, 'd) Code.abstract
                                  | `TPivot of ('c, 'e ref) Code.abstract ]
                                 list;
                         .. >,
                       ('c, 'd * 'e) Code.abstract)
                      StateCPSMonad.monad
                  end
              module type INTERNAL_FEATURES =
                sig
                  module R : TrackRank.RANK
                  module P : TRACKPIVOT
                  module L : LOWER
                end
              module type OUTPUT =
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF : INTERNAL_FEATURES
                    type res
                    val make_result :
                      'a wmatrix ->
                      (< answer : 'b; classif : 'a;
                         state : [> `TDet of 'a OD.Det.lstate
                                  | `TLower of 'a IF.L.lstate
                                  | `TPivot of 'a IF.P.lstate
                                  | `TRan of 'a TrackRank.lstate ];
                         .. >,
                       res)
                      cmonad
                  end
              module type FEATURES =
                sig
                  module Det : DETERMINANT
                  module PivotF : PIVOT
                  module PivotRep : PIVOTKIND
                  module Update : UPDATE
                  module Input : INPUT
                  module Output : OUTPUT
                end
              module GenGE :
                functor (F : FEATURES) ->
                  sig
                    module O :
                      sig
                        module IF :
                          sig
                            module R :
                              sig
                                type 'a tag_lstate = 'a TrackRank.tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b TrackRank.tag_lstate ];
                                     .. >,
                                   int ref)
                                  TrackRank.lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b TrackRank.tag_lstate ];
                                     .. >,
                                   unit)
                                  TrackRank.lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b TrackRank.tag_lstate ];
                                     .. >,
                                   int)
                                  TrackRank.lm
                              end
                            module P :
                              sig
                                type perm_rep = F.Output(F).IF.P.perm_rep
                                type 'a ira = ('a, int) Code.abstract
                                type 'a fra = 'a F.Output(F).IF.P.fra
                                type 'a pra = 'a F.Output(F).IF.P.pra
                                type 'a lstate = 'a F.Output(F).IF.P.lstate
                                type ('a, 'b) lm = ('a, 'b) cmonad
                                  constraint 'a =
                                    < answer : 'c; classif : 'd;
                                      state : [> `TPivot of 'd lstate ]; .. >
                                val rowrep : 'a ira -> 'a ira -> 'a fra
                                val colrep : 'a ira -> 'a ira -> 'a fra
                                val decl :
                                  ('a, int) Code.abstract ->
                                  (< answer : 'b; classif : 'a;
                                     state : [> `TPivot of 'a lstate ]; .. >,
                                   unit)
                                  lm
                                val add :
                                  'a fra ->
                                  (< answer : 'b; classif : 'a;
                                     state : [> `TPivot of 'a lstate ]; .. >,
                                   unit)
                                  omonad
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> `TPivot of 'b lstate ]; .. >,
                                   perm_rep)
                                  lm
                              end
                            module L :
                              sig
                                type 'a lstate = ('a, C.contr) Code.abstract
                                type ('a, 'b) lm = ('a, 'b) cmonad
                                  constraint 'a =
                                    < answer : 'c; classif : 'd;
                                      state : [> `TLower of 'd lstate ]; .. >
                                val decl :
                                  ('a, C.contr) Code.abstract ->
                                  (< answer : 'b; classif : 'a;
                                     state : [> `TLower of 'a lstate ]; .. >,
                                   C.contr)
                                  lm
                                val updt :
                                  'a C.vc ->
                                  ('a, int) Code.abstract ->
                                  ('a, int) Code.abstract ->
                                  'a C.vo ->
                                  'a C.Dom.vc ->
                                  (< answer : 'b; classif : 'a;
                                     state : [> `TLower of 'a lstate ]; .. >,
                                   unit)
                                  lm option
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> `TLower of 'b lstate ]; .. >,
                                   C.contr)
                                  lm
                                val wants_pack : bool
                              end
                          end
                        type res = F.Output(F).res
                        val make_result :
                          'a wmatrix ->
                          (< answer : 'b; classif : 'a;
                             state : [> `TDet of 'a F.Det.lstate
                                      | `TLower of 'a IF.L.lstate
                                      | `TPivot of 'a IF.P.lstate
                                      | `TRan of 'a TrackRank.lstate ];
                             .. >,
                           res)
                          cmonad
                      end
                    val wants_pack : bool
                    val can_pack : bool
                    val zerobelow :
                      'a wmatrix ->
                      'a curposval ->
                      ([> `TDet of 'a F.Det.lstate
                        | `TLower of ('a, C.contr) Code.abstract ]
                       as 'b)
                      list ->
                      ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                    val init :
                      ('a, F.Input.inp) Code.abstract ->
                      (< answer : ('a, 'b) Code.abstract;
                         state : [> `TDet of 'a F.Det.lstate
                                  | `TLower of ('a, C.contr) Code.abstract
                                  | `TPivot of 'a F.Output(F).IF.P.lstate
                                  | `TRan of 'a TrackRank.lstate ]
                                 list;
                         .. >,
                       'a wmatrix * ('a, int ref) Code.abstract *
                       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                      StateCPSMonad.monad
                    val forward_elim :
                      'a wmatrix * ('a, int ref) Code.abstract *
                      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                      ([> `TDet of 'a F.Det.lstate
                        | `TLower of ('a, C.contr) Code.abstract
                        | `TPivot of 'a F.Output(F).IF.P.lstate
                        | `TRan of 'a TrackRank.lstate ]
                       as 'b)
                      list ->
                      ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                    val gen :
                      ('a, F.Input.inp) Code.abstract ->
                      (< answer : ('a, 'b) Code.abstract;
                         state : [> `TDet of 'a F.Det.lstate
                                  | `TLower of 'a O.IF.L.lstate
                                  | `TPivot of 'a O.IF.P.lstate
                                  | `TRan of 'a TrackRank.lstate ]
                                 list;
                         .. >,
                       ('a, O.res) Code.abstract)
                      StateCPSMonad.monad
                  end
            end
          module Solve :
            sig
              module type INPUT =
                sig
                  type inp
                  type rhs = C.contr
                  val get_input :
                    ('a, inp) Code.abstract ->
                    (< answer : 'b; classif : 'a; state : 'c; .. >,
                     ('a, C.contr) Code.abstract * ('a, rhs) Code.abstract)
                    StateCPSMonad.monad
                end
              module InpMatrixVector :
                sig
                  type inp = C.contr * C.contr
                  type rhs = C.contr
                  val get_input :
                    ('a, 'b * 'c) Code.abstract ->
                    (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
                     ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
                    StateCPSMonad.monad
                end
              module type OUTPUT =
                sig
                  type res
                  val make_result :
                    ('a, C.contr) Code.abstract ->
                    ('a, C.contr) Code.abstract ->
                    ('a, int) Code.abstract ->
                    ('a, int) Code.abstract ->
                    ('a, int) Code.abstract ->
                    (< answer : 'b; classif : 'a; state : 'c; .. >, res)
                    cmonad
                end
              module OutJustAnswer :
                sig
                  type res = C.contr
                  val make_result :
                    'a C.vc ->
                    'a C.vc ->
                    ('a, int) Code.abstract ->
                    ('a, int) Code.abstract ->
                    ('a, int) Code.abstract ->
                    'b -> ('b -> ('a, C.contr) Code.abstract -> 'c) -> 'c
                end
              module type FEATURES =
                sig
                  module Det : DETERMINANT
                  module PivotF : PIVOT
                  module Input : INPUT
                  module Output : OUTPUT
                end
              module GenSolve :
                functor (F : FEATURES) ->
                  sig
                    module GE' :
                      sig
                        module O :
                          sig
                            module IF :
                              sig
                                module R :
                                  sig
                                    type 'a tag_lstate =
                                        'a TrackRank.tag_lstate_
                                    val decl :
                                      unit ->
                                      (< answer : 'a; classif : 'b;
                                         state : [> 'b TrackRank.tag_lstate ];
                                         .. >,
                                       int ref)
                                      TrackRank.lm
                                    val succ :
                                      unit ->
                                      (< answer : 'a; classif : 'b;
                                         state : [> 'b TrackRank.tag_lstate ];
                                         .. >,
                                       unit)
                                      TrackRank.lm
                                    val fin :
                                      unit ->
                                      (< answer : 'a; classif : 'b;
                                         state : [> 'b TrackRank.tag_lstate ];
                                         .. >,
                                       int)
                                      TrackRank.lm
                                  end
                                module P :
                                  sig
                                    type perm_rep = PermList.perm_rep
                                    type 'a ira = ('a, int) Code.abstract
                                    type 'a fra = 'a PermList.fra
                                    type 'a pra = 'a PermList.pra
                                    type 'a lstate =
                                        ('a, PermList.perm_rep ref)
                                        Code.abstract
                                    type ('a, 'b) lm = ('a, 'b) cmonad
                                      constraint 'a =
                                        < answer : 'c; classif : 'd;
                                          state : [> `TPivot of 'd lstate ];
                                          .. >
                                    val rowrep : 'a ira -> 'a ira -> 'a fra
                                    val colrep : 'a ira -> 'a ira -> 'a fra
                                    val decl :
                                      ('a, int) Code.abstract ->
                                      (< answer : 'b; classif : 'a;
                                         state : [> `TPivot of 'a lstate ];
                                         .. >,
                                       unit)
                                      lm
                                    val add :
                                      'a fra ->
                                      (< answer : 'b; classif : 'a;
                                         state : [> `TPivot of 'a lstate ];
                                         .. >,
                                       unit)
                                      omonad
                                    val fin :
                                      unit ->
                                      (< answer : 'a; classif : 'b;
                                         state : [> `TPivot of 'b lstate ];
                                         .. >,
                                       perm_rep)
                                      lm
                                  end
                                module L :
                                  sig
                                    type 'a lstate =
                                        ('a, C.contr) Code.abstract
                                    type ('a, 'b) lm = ('a, 'b) cmonad
                                      constraint 'a =
                                        < answer : 'c; classif : 'd;
                                          state : [> `TLower of 'd lstate ];
                                          .. >
                                    val decl :
                                      ('a, C.contr) Code.abstract ->
                                      (< answer : 'b; classif : 'a;
                                         state : [> `TLower of 'a lstate ];
                                         .. >,
                                       C.contr)
                                      lm
                                    val updt :
                                      'a C.vc ->
                                      ('a, int) Code.abstract ->
                                      ('a, int) Code.abstract ->
                                      'a C.vo ->
                                      'a C.Dom.vc ->
                                      (< answer : 'b; classif : 'a;
                                         state : [> `TLower of 'a lstate ];
                                         .. >,
                                       unit)
                                      lm option
                                    val fin :
                                      unit ->
                                      (< answer : 'a; classif : 'b;
                                         state : [> `TLower of 'b lstate ];
                                         .. >,
                                       C.contr)
                                      lm
                                    val wants_pack : bool
                                  end
                              end
                            type res = C.contr
                            val make_result :
                              'a wmatrix ->
                              (< answer : 'b; classif : 'a;
                                 state : [> `TDet of 'a F.Det.lstate
                                          | `TLower of 'a IF.L.lstate
                                          | `TPivot of 'a IF.P.lstate
                                          | `TRan of 'a TrackRank.lstate ];
                                 .. >,
                               res)
                              cmonad
                          end
                        val wants_pack : bool
                        val can_pack : bool
                        val zerobelow :
                          'a wmatrix ->
                          'a curposval ->
                          ([> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, C.contr) Code.abstract ]
                           as 'b)
                          list ->
                          ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                        val init :
                          ('a, C.contr * int) Code.abstract ->
                          (< answer : ('a, 'b) Code.abstract;
                             state : [> `TDet of 'a F.Det.lstate
                                      | `TLower of
                                          ('a, C.contr) Code.abstract
                                      | `TPivot of
                                          ('a, PermList.perm_rep ref)
                                          Code.abstract
                                      | `TRan of 'a TrackRank.lstate ]
                                     list;
                             .. >,
                           'a wmatrix * ('a, int ref) Code.abstract *
                           ('a, int ref) Code.abstract *
                           ('a, int) Code.abstract)
                          StateCPSMonad.monad
                        val forward_elim :
                          'a wmatrix * ('a, int ref) Code.abstract *
                          ('a, int ref) Code.abstract *
                          ('a, int) Code.abstract ->
                          ([> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, C.contr) Code.abstract
                            | `TPivot of
                                ('a, PermList.perm_rep ref) Code.abstract
                            | `TRan of 'a TrackRank.lstate ]
                           as 'b)
                          list ->
                          ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                        val gen :
                          ('a, C.contr * int) Code.abstract ->
                          (< answer : ('a, 'b) Code.abstract;
                             state : [> `TDet of 'a F.Det.lstate
                                      | `TLower of 'a O.IF.L.lstate
                                      | `TPivot of 'a O.IF.P.lstate
                                      | `TRan of 'a TrackRank.lstate ]
                                     list;
                             .. >,
                           ('a, O.res) Code.abstract)
                          StateCPSMonad.monad
                      end
                    val init :
                      ('a, F.Input.inp) Code.abstract ->
                      (< answer : 'b; state : 'c; .. >,
                       ('a, C.contr) Code.abstract *
                       ('a, F.Input.rhs) Code.abstract)
                      StateCPSMonad.monad
                    val back_elim :
                      'a C.vc ->
                      ('a, int) Code.abstract ->
                      ('a, int) Code.abstract ->
                      'b -> ('b -> ('a, C.contr) Code.abstract -> 'c) -> 'c
                    val gen :
                      ('a, F.Input.inp) Code.abstract ->
                      (< answer : ('a, 'b) Code.abstract;
                         state : [> `TDet of 'a F.Det.lstate
                                  | `TLower of 'a GE'.O.IF.L.lstate
                                  | `TPivot of 'a GE'.O.IF.P.lstate
                                  | `TRan of 'a TrackRank.lstate ]
                                 list;
                         .. >,
                       ('a, F.Output.res) Code.abstract)
                      StateCPSMonad.monad
                  end
            end
        end
  end
type 'a pr = { pf : 'b. ('b, 'a) code; }
#   val instantiate :
  (('a, 'b) code -> 'c list -> ('d -> 'e -> 'e) -> ('a, 'f) code) ->
  ('a, 'b -> 'f) code = <fun>
#   val runit : 'a pr -> 'a = <fun>
#   * * * * * * * * *     module Z3 :
  sig
    type v = int
    val kind : Domains_sig.domain_kind
    val zero : int
    val one : int
    val plus : int -> int -> int
    val times : int -> int -> int
    val minus : int -> int -> int
    val uminus : int -> int
    val extended_gcd : int -> int -> int * int
    val div : int -> int -> int
    val normalizer : 'a option
    val better_than : 'a option
    type 'a vc = ('a, v) code
    val zeroL : ('a, int) code
    val oneL : ('a, int) code
    val ( +^ ) : ('a, int) code -> ('a, int) code -> ('a, int) code
    val ( *^ ) : ('a, int) code -> ('a, int) code -> ('a, int) code
    val ( -^ ) : ('a, int) code -> ('a, int) code -> ('a, int) code
    val uminusL : ('a, int) code -> ('a, int) code
    val divL : ('a, int) code -> ('a, int) code -> ('a, int) code
    val normalizerL : 'a option
    val better_thanL : 'a option
  end
module Z19 :
  sig
    type v = int
    val kind : Domains_sig.domain_kind
    val zero : int
    val one : int
    val plus : int -> int -> int
    val times : int -> int -> int
    val minus : int -> int -> int
    val uminus : int -> int
    val extended_gcd : int -> int -> int * int
    val div : int -> int -> int
    val normalizer : 'a option
    val better_than : 'a option
    type 'a vc = ('a, v) code
    val zeroL : ('a, int) code
    val oneL : ('a, int) code
    val ( +^ ) : ('a, int) code -> ('a, int) code -> ('a, int) code
    val ( *^ ) : ('a, int) code -> ('a, int) code -> ('a, int) code
    val ( -^ ) : ('a, int) code -> ('a, int) code -> ('a, int) code
    val uminusL : ('a, int) code -> ('a, int) code
    val divL : ('a, int) code -> ('a, int) code -> ('a, int) code
    val normalizerL : 'a option
    val better_thanL : 'a option
  end
module GAC_F :
  sig
    module Dom :
      sig
        type v = Domains_code.FloatDomainL.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v array array
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 : ('a, 'b array) code -> ('a, int) code
    val dim1 : ('a, 'b array array) code -> ('a, int) code
    val mapper :
      ('a vo -> 'a vo) option ->
      ('a, Dom.v array array) code -> ('a, Dom.v array array) code
    val copy : ('a, 'b array array) code -> ('a, 'b array array) code
    val init :
      ('a, int) code -> ('a, int) code -> ('a, Dom.v array array) code
    val augment :
      ('a, 'b array array) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, 'b array array) code
    val identity :
      ('a, int) code -> ('a, int) code -> ('a, Dom.v array array) code
    val swap_rows_stmt :
      ('a, 'b array) code ->
      'c -> ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GVC_F :
  sig
    module Dom :
      sig
        type v = Domains_code.FloatDomainL.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v Domains_code.container2dfromvector
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val dim1 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val mapper :
      (('a, 'b) code -> ('a, 'b) code) option ->
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val copy :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val init :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val augment :
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val identity :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val index_default : ('a, int) code option -> ('a, int) code
    val swap_rows_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code option ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GAC_I :
  sig
    module Dom :
      sig
        type v = Domains_code.IntegerDomainL.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v array array
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 : ('a, 'b array) code -> ('a, int) code
    val dim1 : ('a, 'b array array) code -> ('a, int) code
    val mapper :
      ('a vo -> 'a vo) option ->
      ('a, Dom.v array array) code -> ('a, Dom.v array array) code
    val copy : ('a, 'b array array) code -> ('a, 'b array array) code
    val init :
      ('a, int) code -> ('a, int) code -> ('a, Dom.v array array) code
    val augment :
      ('a, 'b array array) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, 'b array array) code
    val identity :
      ('a, int) code -> ('a, int) code -> ('a, Dom.v array array) code
    val swap_rows_stmt :
      ('a, 'b array) code ->
      'c -> ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GVC_I :
  sig
    module Dom :
      sig
        type v = Domains_code.IntegerDomainL.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v Domains_code.container2dfromvector
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val dim1 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val mapper :
      (('a, 'b) code -> ('a, 'b) code) option ->
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val copy :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val init :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val augment :
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val identity :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val index_default : ('a, int) code option -> ('a, int) code
    val swap_rows_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code option ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GAC_R :
  sig
    module Dom :
      sig
        type v = Domains_code.RationalDomainL.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v array array
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 : ('a, 'b array) code -> ('a, int) code
    val dim1 : ('a, 'b array array) code -> ('a, int) code
    val mapper :
      ('a vo -> 'a vo) option ->
      ('a, Dom.v array array) code -> ('a, Dom.v array array) code
    val copy : ('a, 'b array array) code -> ('a, 'b array array) code
    val init :
      ('a, int) code -> ('a, int) code -> ('a, Dom.v array array) code
    val augment :
      ('a, 'b array array) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, 'b array array) code
    val identity :
      ('a, int) code -> ('a, int) code -> ('a, Dom.v array array) code
    val swap_rows_stmt :
      ('a, 'b array) code ->
      'c -> ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GVC_Z3 :
  sig
    module Dom :
      sig
        type v = Z3.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v Domains_code.container2dfromvector
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val dim1 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val mapper :
      (('a, 'b) code -> ('a, 'b) code) option ->
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val copy :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val init :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val augment :
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val identity :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val index_default : ('a, int) code option -> ('a, int) code
    val swap_rows_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code option ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GVC_Z19 :
  sig
    module Dom :
      sig
        type v = Z19.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v Domains_code.container2dfromvector
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val dim1 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val mapper :
      (('a, 'b) code -> ('a, 'b) code) option ->
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val copy :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val init :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val augment :
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val identity :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val index_default : ('a, int) code option -> ('a, int) code
    val swap_rows_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code option ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GFC_F :
  sig
    module Dom :
      sig
        type v =
            Domains_code.FortranVectorContainer(Domains_code.FloatDomainL).Dom.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr =
        Domains_code.FortranVectorContainer(Domains_code.FloatDomainL).contr
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL : 'a vc -> ('a, int) code -> ('a, int) code -> 'a vo
    val dim1 : 'a vc -> ('a, int) code
    val dim2 : 'a vc -> ('a, int) code
    val mapper : ('a vo -> 'a vo) option -> 'a vc -> 'a vc
    val copy : 'a vc -> 'a vc
    val init : ('a, int) code -> ('a, int) code -> 'a vc
    val augment :
      'a vc ->
      ('a, int) code -> ('a, int) code -> 'a vc -> ('a, int) code -> 'a vc
    val identity : ('a, int) code -> ('a, int) code -> 'a vc
    val swap_rows_stmt :
      'a vc ->
      ('a, int) code option ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      'a vc -> ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head : 'a vc -> ('a, int) code -> ('a, int) code -> 'a vo
    val col_head_set :
      'a vc -> ('a, int) code -> ('a, int) code -> 'a vo -> ('a, unit) code
  end
module G_GAC_F :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GAC_F).wmatrix = {
      matrix : 'a GAC_F.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GAC_F).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GAC_F).curposval = {
      p : 'a curpos;
      curval : ('a, GAC_F.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GAC_F.Dom.v ref
        type 'a lstate
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val decl :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GAC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GAC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GAC_F.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GAC_F.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GAC_F.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GAC_F.contr)
          lm
        val updt :
          'a GAC_F.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GAC_F.vo ->
          'a GAC_F.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GAC_F.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GAC_F.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GAC_F.Dom.v ref
        type 'a lstate = unit
        val decl : unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val upd_sign :
          unit ->
          (< answer : 'a; state : 'b; .. >, 'c option) StateCPSMonad.monad
        val zero_sign :
          unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val acc_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val get_magn :
          unit ->
          (< answer : 'a; state : 'b; .. >,
           ('c, GAC_F.Dom.v ref) Code.abstract)
          StateCPSMonad.monad
        val set_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val fin : unit -> 'a
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
      end
    module AbstractDet :
      sig
        type tdet = GAC_F.Dom.v ref
        type 'a lstate =
            ('a, int ref) Code.abstract * ('a, tdet) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val ip :
          ('a -> [> `TDet of 'a ]) * ([> `TDet of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_F.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('c, unit) Code.abstract)
          StateCPSMonad.monad
        val upd_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract option)
          StateCPSMonad.monad
        val zero_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        val get_magn :
          unit ->
          (< answer : 'a; state : [> `TDet of 'b * 'c ] list; .. >, 'c)
          StateCPSMonad.monad
        val set_magn :
          ('a, 'b) Code.abstract ->
          (< answer : 'c;
             state : [> `TDet of 'd * ('a, 'b ref) Code.abstract ] list; .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val acc_magn :
          'a GAC_F.Dom.vc ->
          (< answer : 'b;
             state : [> `TDet of 'c * ('a, GAC_F.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val fin :
          unit ->
          (< answer : 'a;
             state : [> `TDet of
                          ('b, int ref) Code.abstract *
                          ('b, GAC_F.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('b, GAC_F.Dom.v) Code.abstract)
          StateCPSMonad.monad
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GAC_F.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GAC_F.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GAC_F.Dom.vc
              val update :
                'a GAC_F.Dom.vc ->
                'a GAC_F.Dom.vc ->
                'a GAC_F.Dom.vc ->
                'a GAC_F.Dom.vc ->
                ('a GAC_F.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GAC_F.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GAC_F.Dom.vc
              val update :
                'a GAC_F.Dom.vc ->
                'a GAC_F.Dom.vc ->
                'a GAC_F.Dom.vc ->
                'a GAC_F.Dom.vc ->
                ('a GAC_F.Dom.vc -> 'b) ->
                ('a, GAC_F.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GAC_F.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GAC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GAC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GAC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GAC_F.vo ->
              'a GAC_F.vo ->
              (< answer : 'b; state : [> `TLower of 'a GAC_F.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GAC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GAC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GAC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GAC_F.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GAC_F.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GAC_F.contr
            val get_input :
              'a GAC_F.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GAC_F.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GAC_F.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GAC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GAC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GAC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GAC_F.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr * GAC_F.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GAC_F.contr * GAC_F.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GAC_F.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr * GAC_F.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_F.contr * GAC_F.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr * GAC_F.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_F.contr * GAC_F.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_F.vo ->
                        'a GAC_F.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GAC_F.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr * GAC_F.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_F.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            lm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GAC_F.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GAC_F.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GAC_F.contr)
                            lm
                          val updt :
                            'a GAC_F.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GAC_F.vo ->
                            'a GAC_F.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GAC_F.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GAC_F.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GAC_F.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GAC_F.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GAC_F.contr * GAC_F.contr
            type rhs = GAC_F.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GAC_F.contr) Code.abstract ->
              ('a, GAC_F.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GAC_F.contr
            val make_result :
              'a GAC_F.vc ->
              'a GAC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GAC_F.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                lm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GAC_F.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GAC_F.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GAC_F.contr)
                                lm
                              val updt :
                                'a GAC_F.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GAC_F.vo ->
                                'a GAC_F.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GAC_F.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GAC_F.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GAC_F.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GAC_F.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GAC_F.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GAC_F.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GAC_F.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GAC_F.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GAC_F.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GAC_F.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GVC_F :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GVC_F).wmatrix = {
      matrix : 'a GVC_F.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GVC_F).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GVC_F).curposval = {
      p : 'a curpos;
      curval : ('a, GVC_F.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GVC_F.Dom.v ref
        type 'a lstate
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val decl :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_F.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GVC_F.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GVC_F.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GVC_F.contr)
          lm
        val updt :
          'a GVC_F.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GVC_F.vo ->
          'a GVC_F.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GVC_F.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GVC_F.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GVC_F.Dom.v ref
        type 'a lstate = unit
        val decl : unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val upd_sign :
          unit ->
          (< answer : 'a; state : 'b; .. >, 'c option) StateCPSMonad.monad
        val zero_sign :
          unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val acc_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val get_magn :
          unit ->
          (< answer : 'a; state : 'b; .. >,
           ('c, GVC_F.Dom.v ref) Code.abstract)
          StateCPSMonad.monad
        val set_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val fin : unit -> 'a
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
      end
    module AbstractDet :
      sig
        type tdet = GVC_F.Dom.v ref
        type 'a lstate =
            ('a, int ref) Code.abstract * ('a, tdet) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val ip :
          ('a -> [> `TDet of 'a ]) * ([> `TDet of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_F.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('c, unit) Code.abstract)
          StateCPSMonad.monad
        val upd_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract option)
          StateCPSMonad.monad
        val zero_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        val get_magn :
          unit ->
          (< answer : 'a; state : [> `TDet of 'b * 'c ] list; .. >, 'c)
          StateCPSMonad.monad
        val set_magn :
          ('a, 'b) Code.abstract ->
          (< answer : 'c;
             state : [> `TDet of 'd * ('a, 'b ref) Code.abstract ] list; .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val acc_magn :
          'a GVC_F.Dom.vc ->
          (< answer : 'b;
             state : [> `TDet of 'c * ('a, GVC_F.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val fin :
          unit ->
          (< answer : 'a;
             state : [> `TDet of
                          ('b, int ref) Code.abstract *
                          ('b, GVC_F.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('b, GVC_F.Dom.v) Code.abstract)
          StateCPSMonad.monad
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GVC_F.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GVC_F.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_F.Dom.vc
              val update :
                'a GVC_F.Dom.vc ->
                'a GVC_F.Dom.vc ->
                'a GVC_F.Dom.vc ->
                'a GVC_F.Dom.vc ->
                ('a GVC_F.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_F.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_F.Dom.vc
              val update :
                'a GVC_F.Dom.vc ->
                'a GVC_F.Dom.vc ->
                'a GVC_F.Dom.vc ->
                'a GVC_F.Dom.vc ->
                ('a GVC_F.Dom.vc -> 'b) ->
                ('a, GVC_F.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_F.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GVC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GVC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GVC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_F.vo ->
              'a GVC_F.vo ->
              (< answer : 'b; state : [> `TLower of 'a GVC_F.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GVC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GVC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GVC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_F.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_F.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GVC_F.contr
            val get_input :
              'a GVC_F.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GVC_F.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GVC_F.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GVC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GVC_F.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr * GVC_F.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GVC_F.contr * GVC_F.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GVC_F.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr * GVC_F.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_F.contr * GVC_F.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr * GVC_F.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_F.contr * GVC_F.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_F.vo ->
                        'a GVC_F.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GVC_F.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr * GVC_F.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_F.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            lm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GVC_F.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GVC_F.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GVC_F.contr)
                            lm
                          val updt :
                            'a GVC_F.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GVC_F.vo ->
                            'a GVC_F.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GVC_F.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_F.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GVC_F.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GVC_F.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_F.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GVC_F.contr * GVC_F.contr
            type rhs = GVC_F.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GVC_F.contr) Code.abstract ->
              ('a, GVC_F.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GVC_F.contr
            val make_result :
              'a GVC_F.vc ->
              'a GVC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GVC_F.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                lm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GVC_F.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GVC_F.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GVC_F.contr)
                                lm
                              val updt :
                                'a GVC_F.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GVC_F.vo ->
                                'a GVC_F.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GVC_F.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GVC_F.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_F.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GVC_F.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GVC_F.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_F.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GVC_F.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GVC_F.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GVC_F.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GVC_F.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GAC_I :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GAC_I).wmatrix = {
      matrix : 'a GAC_I.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GAC_I).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GAC_I).curposval = {
      p : 'a curpos;
      curval : ('a, GAC_I.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GAC_I.Dom.v ref
        type 'a lstate
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val decl :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GAC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GAC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GAC_I.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GAC_I.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GAC_I.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GAC_I.contr)
          lm
        val updt :
          'a GAC_I.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GAC_I.vo ->
          'a GAC_I.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GAC_I.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GAC_I.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GAC_I.Dom.v ref
        type 'a lstate = unit
        val decl : unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val upd_sign :
          unit ->
          (< answer : 'a; state : 'b; .. >, 'c option) StateCPSMonad.monad
        val zero_sign :
          unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val acc_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val get_magn :
          unit ->
          (< answer : 'a; state : 'b; .. >,
           ('c, GAC_I.Dom.v ref) Code.abstract)
          StateCPSMonad.monad
        val set_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val fin : unit -> 'a
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
      end
    module AbstractDet :
      sig
        type tdet = GAC_I.Dom.v ref
        type 'a lstate =
            ('a, int ref) Code.abstract * ('a, tdet) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val ip :
          ('a -> [> `TDet of 'a ]) * ([> `TDet of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_I.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('c, unit) Code.abstract)
          StateCPSMonad.monad
        val upd_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract option)
          StateCPSMonad.monad
        val zero_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        val get_magn :
          unit ->
          (< answer : 'a; state : [> `TDet of 'b * 'c ] list; .. >, 'c)
          StateCPSMonad.monad
        val set_magn :
          ('a, 'b) Code.abstract ->
          (< answer : 'c;
             state : [> `TDet of 'd * ('a, 'b ref) Code.abstract ] list; .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val acc_magn :
          'a GAC_I.Dom.vc ->
          (< answer : 'b;
             state : [> `TDet of 'c * ('a, GAC_I.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val fin :
          unit ->
          (< answer : 'a;
             state : [> `TDet of
                          ('b, int ref) Code.abstract *
                          ('b, GAC_I.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('b, GAC_I.Dom.v) Code.abstract)
          StateCPSMonad.monad
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GAC_I.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GAC_I.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GAC_I.Dom.vc
              val update :
                'a GAC_I.Dom.vc ->
                'a GAC_I.Dom.vc ->
                'a GAC_I.Dom.vc ->
                'a GAC_I.Dom.vc ->
                ('a GAC_I.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GAC_I.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GAC_I.Dom.vc
              val update :
                'a GAC_I.Dom.vc ->
                'a GAC_I.Dom.vc ->
                'a GAC_I.Dom.vc ->
                'a GAC_I.Dom.vc ->
                ('a GAC_I.Dom.vc -> 'b) ->
                ('a, GAC_I.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GAC_I.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GAC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GAC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GAC_I.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GAC_I.vo ->
              'a GAC_I.vo ->
              (< answer : 'b; state : [> `TLower of 'a GAC_I.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GAC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GAC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GAC_I.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GAC_I.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GAC_I.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GAC_I.contr
            val get_input :
              'a GAC_I.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GAC_I.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GAC_I.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GAC_I.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GAC_I.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GAC_I.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GAC_I.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr * GAC_I.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GAC_I.contr * GAC_I.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GAC_I.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr * GAC_I.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_I.contr * GAC_I.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr * GAC_I.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_I.contr * GAC_I.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_I.vo ->
                        'a GAC_I.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GAC_I.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr * GAC_I.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_I.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            lm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GAC_I.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GAC_I.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GAC_I.contr)
                            lm
                          val updt :
                            'a GAC_I.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GAC_I.vo ->
                            'a GAC_I.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GAC_I.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GAC_I.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GAC_I.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GAC_I.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GAC_I.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GAC_I.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GAC_I.contr * GAC_I.contr
            type rhs = GAC_I.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GAC_I.contr) Code.abstract ->
              ('a, GAC_I.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GAC_I.contr
            val make_result :
              'a GAC_I.vc ->
              'a GAC_I.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GAC_I.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                lm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GAC_I.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GAC_I.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GAC_I.contr)
                                lm
                              val updt :
                                'a GAC_I.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GAC_I.vo ->
                                'a GAC_I.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GAC_I.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GAC_I.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GAC_I.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GAC_I.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GAC_I.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GAC_I.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GAC_I.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GAC_I.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GAC_I.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GAC_I.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GVC_I :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GVC_I).wmatrix = {
      matrix : 'a GVC_I.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GVC_I).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GVC_I).curposval = {
      p : 'a curpos;
      curval : ('a, GVC_I.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GVC_I.Dom.v ref
        type 'a lstate
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val decl :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_I.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GVC_I.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GVC_I.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GVC_I.contr)
          lm
        val updt :
          'a GVC_I.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GVC_I.vo ->
          'a GVC_I.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GVC_I.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GVC_I.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GVC_I.Dom.v ref
        type 'a lstate = unit
        val decl : unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val upd_sign :
          unit ->
          (< answer : 'a; state : 'b; .. >, 'c option) StateCPSMonad.monad
        val zero_sign :
          unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val acc_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val get_magn :
          unit ->
          (< answer : 'a; state : 'b; .. >,
           ('c, GVC_I.Dom.v ref) Code.abstract)
          StateCPSMonad.monad
        val set_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val fin : unit -> 'a
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
      end
    module AbstractDet :
      sig
        type tdet = GVC_I.Dom.v ref
        type 'a lstate =
            ('a, int ref) Code.abstract * ('a, tdet) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val ip :
          ('a -> [> `TDet of 'a ]) * ([> `TDet of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_I.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('c, unit) Code.abstract)
          StateCPSMonad.monad
        val upd_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract option)
          StateCPSMonad.monad
        val zero_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        val get_magn :
          unit ->
          (< answer : 'a; state : [> `TDet of 'b * 'c ] list; .. >, 'c)
          StateCPSMonad.monad
        val set_magn :
          ('a, 'b) Code.abstract ->
          (< answer : 'c;
             state : [> `TDet of 'd * ('a, 'b ref) Code.abstract ] list; .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val acc_magn :
          'a GVC_I.Dom.vc ->
          (< answer : 'b;
             state : [> `TDet of 'c * ('a, GVC_I.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val fin :
          unit ->
          (< answer : 'a;
             state : [> `TDet of
                          ('b, int ref) Code.abstract *
                          ('b, GVC_I.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('b, GVC_I.Dom.v) Code.abstract)
          StateCPSMonad.monad
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GVC_I.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GVC_I.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_I.Dom.vc
              val update :
                'a GVC_I.Dom.vc ->
                'a GVC_I.Dom.vc ->
                'a GVC_I.Dom.vc ->
                'a GVC_I.Dom.vc ->
                ('a GVC_I.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_I.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_I.Dom.vc
              val update :
                'a GVC_I.Dom.vc ->
                'a GVC_I.Dom.vc ->
                'a GVC_I.Dom.vc ->
                'a GVC_I.Dom.vc ->
                ('a GVC_I.Dom.vc -> 'b) ->
                ('a, GVC_I.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_I.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GVC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GVC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GVC_I.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_I.vo ->
              'a GVC_I.vo ->
              (< answer : 'b; state : [> `TLower of 'a GVC_I.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GVC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GVC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GVC_I.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_I.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_I.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GVC_I.contr
            val get_input :
              'a GVC_I.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GVC_I.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GVC_I.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_I.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_I.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GVC_I.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GVC_I.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr * GVC_I.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GVC_I.contr * GVC_I.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GVC_I.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr * GVC_I.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_I.contr * GVC_I.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr * GVC_I.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_I.contr * GVC_I.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_I.vo ->
                        'a GVC_I.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GVC_I.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr * GVC_I.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_I.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            lm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GVC_I.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GVC_I.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GVC_I.contr)
                            lm
                          val updt :
                            'a GVC_I.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GVC_I.vo ->
                            'a GVC_I.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GVC_I.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_I.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GVC_I.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GVC_I.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_I.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GVC_I.contr * GVC_I.contr
            type rhs = GVC_I.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GVC_I.contr) Code.abstract ->
              ('a, GVC_I.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GVC_I.contr
            val make_result :
              'a GVC_I.vc ->
              'a GVC_I.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GVC_I.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                lm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GVC_I.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GVC_I.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GVC_I.contr)
                                lm
                              val updt :
                                'a GVC_I.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GVC_I.vo ->
                                'a GVC_I.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GVC_I.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GVC_I.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_I.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GVC_I.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GVC_I.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_I.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GVC_I.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GVC_I.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GVC_I.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GVC_I.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GAC_R :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GAC_R).wmatrix = {
      matrix : 'a GAC_R.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GAC_R).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GAC_R).curposval = {
      p : 'a curpos;
      curval : ('a, GAC_R.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GAC_R.Dom.v ref
        type 'a lstate
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val decl :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GAC_R.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GAC_R.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GAC_R.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GAC_R.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GAC_R.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GAC_R.contr)
          lm
        val updt :
          'a GAC_R.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GAC_R.vo ->
          'a GAC_R.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GAC_R.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GAC_R.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GAC_R.Dom.v ref
        type 'a lstate = unit
        val decl : unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val upd_sign :
          unit ->
          (< answer : 'a; state : 'b; .. >, 'c option) StateCPSMonad.monad
        val zero_sign :
          unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val acc_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val get_magn :
          unit ->
          (< answer : 'a; state : 'b; .. >,
           ('c, GAC_R.Dom.v ref) Code.abstract)
          StateCPSMonad.monad
        val set_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val fin : unit -> 'a
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
      end
    module AbstractDet :
      sig
        type tdet = GAC_R.Dom.v ref
        type 'a lstate =
            ('a, int ref) Code.abstract * ('a, tdet) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val ip :
          ('a -> [> `TDet of 'a ]) * ([> `TDet of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_R.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('c, unit) Code.abstract)
          StateCPSMonad.monad
        val upd_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract option)
          StateCPSMonad.monad
        val zero_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        val get_magn :
          unit ->
          (< answer : 'a; state : [> `TDet of 'b * 'c ] list; .. >, 'c)
          StateCPSMonad.monad
        val set_magn :
          ('a, 'b) Code.abstract ->
          (< answer : 'c;
             state : [> `TDet of 'd * ('a, 'b ref) Code.abstract ] list; .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val acc_magn :
          'a GAC_R.Dom.vc ->
          (< answer : 'b;
             state : [> `TDet of 'c * ('a, GAC_R.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val fin :
          unit ->
          (< answer : 'a;
             state : [> `TDet of
                          ('b, int ref) Code.abstract *
                          ('b, GAC_R.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('b, GAC_R.Dom.v) Code.abstract)
          StateCPSMonad.monad
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GAC_R.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GAC_R.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GAC_R.Dom.vc
              val update :
                'a GAC_R.Dom.vc ->
                'a GAC_R.Dom.vc ->
                'a GAC_R.Dom.vc ->
                'a GAC_R.Dom.vc ->
                ('a GAC_R.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GAC_R.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GAC_R.Dom.vc
              val update :
                'a GAC_R.Dom.vc ->
                'a GAC_R.Dom.vc ->
                'a GAC_R.Dom.vc ->
                'a GAC_R.Dom.vc ->
                ('a GAC_R.Dom.vc -> 'b) ->
                ('a, GAC_R.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GAC_R.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GAC_R.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GAC_R.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GAC_R.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GAC_R.vo ->
              'a GAC_R.vo ->
              (< answer : 'b; state : [> `TLower of 'a GAC_R.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GAC_R.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GAC_R.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GAC_R.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GAC_R.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GAC_R.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GAC_R.contr
            val get_input :
              'a GAC_R.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GAC_R.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GAC_R.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GAC_R.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GAC_R.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GAC_R.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_R.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_R.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GAC_R.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_R.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_R.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr * GAC_R.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GAC_R.contr * GAC_R.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_R.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_R.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GAC_R.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_R.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_R.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr * GAC_R.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_R.contr * GAC_R.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_R.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_R.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr * GAC_R.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_R.contr * GAC_R.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_R.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_R.vo ->
                        'a GAC_R.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GAC_R.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr * GAC_R.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_R.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            lm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GAC_R.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GAC_R.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GAC_R.contr)
                            lm
                          val updt :
                            'a GAC_R.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GAC_R.vo ->
                            'a GAC_R.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GAC_R.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GAC_R.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GAC_R.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GAC_R.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GAC_R.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GAC_R.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GAC_R.contr * GAC_R.contr
            type rhs = GAC_R.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GAC_R.contr) Code.abstract ->
              ('a, GAC_R.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GAC_R.contr
            val make_result :
              'a GAC_R.vc ->
              'a GAC_R.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GAC_R.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                lm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GAC_R.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GAC_R.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GAC_R.contr)
                                lm
                              val updt :
                                'a GAC_R.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GAC_R.vo ->
                                'a GAC_R.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GAC_R.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GAC_R.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GAC_R.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GAC_R.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GAC_R.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GAC_R.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GAC_R.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GAC_R.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GAC_R.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GAC_R.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GVC_Z3 :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GVC_Z3).wmatrix = {
      matrix : 'a GVC_Z3.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GVC_Z3).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GVC_Z3).curposval = {
      p : 'a curpos;
      curval : ('a, GVC_Z3.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GVC_Z3.Dom.v ref
        type 'a lstate
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val decl :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_Z3.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_Z3.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_Z3.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GVC_Z3.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GVC_Z3.contr)
          lm
        val updt :
          'a GVC_Z3.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GVC_Z3.vo ->
          'a GVC_Z3.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GVC_Z3.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GVC_Z3.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GVC_Z3.Dom.v ref
        type 'a lstate = unit
        val decl : unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val upd_sign :
          unit ->
          (< answer : 'a; state : 'b; .. >, 'c option) StateCPSMonad.monad
        val zero_sign :
          unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val acc_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val get_magn :
          unit ->
          (< answer : 'a; state : 'b; .. >,
           ('c, GVC_Z3.Dom.v ref) Code.abstract)
          StateCPSMonad.monad
        val set_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val fin : unit -> 'a
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
      end
    module AbstractDet :
      sig
        type tdet = GVC_Z3.Dom.v ref
        type 'a lstate =
            ('a, int ref) Code.abstract * ('a, tdet) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val ip :
          ('a -> [> `TDet of 'a ]) * ([> `TDet of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_Z3.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('c, unit) Code.abstract)
          StateCPSMonad.monad
        val upd_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract option)
          StateCPSMonad.monad
        val zero_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        val get_magn :
          unit ->
          (< answer : 'a; state : [> `TDet of 'b * 'c ] list; .. >, 'c)
          StateCPSMonad.monad
        val set_magn :
          ('a, 'b) Code.abstract ->
          (< answer : 'c;
             state : [> `TDet of 'd * ('a, 'b ref) Code.abstract ] list; .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val acc_magn :
          'a GVC_Z3.Dom.vc ->
          (< answer : 'b;
             state : [> `TDet of 'c * ('a, GVC_Z3.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val fin :
          unit ->
          (< answer : 'a;
             state : [> `TDet of
                          ('b, int ref) Code.abstract *
                          ('b, GVC_Z3.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('b, GVC_Z3.Dom.v) Code.abstract)
          StateCPSMonad.monad
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GVC_Z3.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GVC_Z3.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_Z3.Dom.vc
              val update :
                'a GVC_Z3.Dom.vc ->
                'a GVC_Z3.Dom.vc ->
                'a GVC_Z3.Dom.vc ->
                'a GVC_Z3.Dom.vc ->
                ('a GVC_Z3.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_Z3.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_Z3.Dom.vc
              val update :
                'a GVC_Z3.Dom.vc ->
                'a GVC_Z3.Dom.vc ->
                'a GVC_Z3.Dom.vc ->
                'a GVC_Z3.Dom.vc ->
                ('a GVC_Z3.Dom.vc -> 'b) ->
                ('a, GVC_Z3.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_Z3.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GVC_Z3.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_Z3.vo ->
              'a GVC_Z3.vo ->
              (< answer : 'b; state : [> `TLower of 'a GVC_Z3.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GVC_Z3.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_Z3.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_Z3.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GVC_Z3.contr
            val get_input :
              'a GVC_Z3.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GVC_Z3.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GVC_Z3.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_Z3.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_Z3.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GVC_Z3.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z3.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z3.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GVC_Z3.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z3.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z3.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr * GVC_Z3.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GVC_Z3.contr * GVC_Z3.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z3.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z3.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GVC_Z3.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z3.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z3.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr * GVC_Z3.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_Z3.contr * GVC_Z3.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z3.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z3.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr * GVC_Z3.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_Z3.contr * GVC_Z3.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z3.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z3.vo ->
                        'a GVC_Z3.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GVC_Z3.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr * GVC_Z3.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_Z3.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            lm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GVC_Z3.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GVC_Z3.contr)
                            lm
                          val updt :
                            'a GVC_Z3.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GVC_Z3.vo ->
                            'a GVC_Z3.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GVC_Z3.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_Z3.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GVC_Z3.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_Z3.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GVC_Z3.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_Z3.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GVC_Z3.contr * GVC_Z3.contr
            type rhs = GVC_Z3.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GVC_Z3.contr) Code.abstract ->
              ('a, GVC_Z3.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GVC_Z3.contr
            val make_result :
              'a GVC_Z3.vc ->
              'a GVC_Z3.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GVC_Z3.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                lm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GVC_Z3.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GVC_Z3.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GVC_Z3.contr)
                                lm
                              val updt :
                                'a GVC_Z3.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GVC_Z3.vo ->
                                'a GVC_Z3.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GVC_Z3.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GVC_Z3.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_Z3.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GVC_Z3.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GVC_Z3.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_Z3.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GVC_Z3.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GVC_Z3.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GVC_Z3.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GVC_Z3.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GVC_Z19 :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GVC_Z19).wmatrix = {
      matrix : 'a GVC_Z19.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GVC_Z19).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GVC_Z19).curposval = {
      p : 'a curpos;
      curval : ('a, GVC_Z19.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GVC_Z19.Dom.v ref
        type 'a lstate
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val decl :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_Z19.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_Z19.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_Z19.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GVC_Z19.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GVC_Z19.contr)
          lm
        val updt :
          'a GVC_Z19.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GVC_Z19.vo ->
          'a GVC_Z19.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GVC_Z19.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GVC_Z19.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GVC_Z19.Dom.v ref
        type 'a lstate = unit
        val decl : unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val upd_sign :
          unit ->
          (< answer : 'a; state : 'b; .. >, 'c option) StateCPSMonad.monad
        val zero_sign :
          unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val acc_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val get_magn :
          unit ->
          (< answer : 'a; state : 'b; .. >,
           ('c, GVC_Z19.Dom.v ref) Code.abstract)
          StateCPSMonad.monad
        val set_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val fin : unit -> 'a
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
      end
    module AbstractDet :
      sig
        type tdet = GVC_Z19.Dom.v ref
        type 'a lstate =
            ('a, int ref) Code.abstract * ('a, tdet) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val ip :
          ('a -> [> `TDet of 'a ]) * ([> `TDet of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_Z19.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('c, unit) Code.abstract)
          StateCPSMonad.monad
        val upd_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract option)
          StateCPSMonad.monad
        val zero_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        val get_magn :
          unit ->
          (< answer : 'a; state : [> `TDet of 'b * 'c ] list; .. >, 'c)
          StateCPSMonad.monad
        val set_magn :
          ('a, 'b) Code.abstract ->
          (< answer : 'c;
             state : [> `TDet of 'd * ('a, 'b ref) Code.abstract ] list; .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val acc_magn :
          'a GVC_Z19.Dom.vc ->
          (< answer : 'b;
             state : [> `TDet of 'c * ('a, GVC_Z19.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val fin :
          unit ->
          (< answer : 'a;
             state : [> `TDet of
                          ('b, int ref) Code.abstract *
                          ('b, GVC_Z19.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('b, GVC_Z19.Dom.v) Code.abstract)
          StateCPSMonad.monad
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GVC_Z19.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GVC_Z19.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_Z19.Dom.vc
              val update :
                'a GVC_Z19.Dom.vc ->
                'a GVC_Z19.Dom.vc ->
                'a GVC_Z19.Dom.vc ->
                'a GVC_Z19.Dom.vc ->
                ('a GVC_Z19.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_Z19.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_Z19.Dom.vc
              val update :
                'a GVC_Z19.Dom.vc ->
                'a GVC_Z19.Dom.vc ->
                'a GVC_Z19.Dom.vc ->
                'a GVC_Z19.Dom.vc ->
                ('a GVC_Z19.Dom.vc -> 'b) ->
                ('a, GVC_Z19.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_Z19.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GVC_Z19.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_Z19.vo ->
              'a GVC_Z19.vo ->
              (< answer : 'b; state : [> `TLower of 'a GVC_Z19.vc ] list;
                 .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GVC_Z19.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_Z19.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_Z19.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GVC_Z19.contr
            val get_input :
              'a GVC_Z19.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GVC_Z19.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GVC_Z19.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_Z19.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_Z19.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GVC_Z19.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z19.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z19.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GVC_Z19.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z19.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z19.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr * GVC_Z19.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GVC_Z19.contr * GVC_Z19.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z19.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z19.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GVC_Z19.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z19.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z19.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr * GVC_Z19.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_Z19.contr * GVC_Z19.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z19.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z19.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr * GVC_Z19.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_Z19.contr * GVC_Z19.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z19.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z19.vo ->
                        'a GVC_Z19.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GVC_Z19.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr * GVC_Z19.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_Z19.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            lm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GVC_Z19.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GVC_Z19.contr)
                            lm
                          val updt :
                            'a GVC_Z19.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GVC_Z19.vo ->
                            'a GVC_Z19.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GVC_Z19.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_Z19.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GVC_Z19.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_Z19.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GVC_Z19.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_Z19.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GVC_Z19.contr * GVC_Z19.contr
            type rhs = GVC_Z19.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GVC_Z19.contr) Code.abstract ->
              ('a, GVC_Z19.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GVC_Z19.contr
            val make_result :
              'a GVC_Z19.vc ->
              'a GVC_Z19.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GVC_Z19.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                lm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GVC_Z19.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GVC_Z19.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GVC_Z19.contr)
                                lm
                              val updt :
                                'a GVC_Z19.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GVC_Z19.vo ->
                                'a GVC_Z19.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GVC_Z19.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GVC_Z19.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_Z19.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GVC_Z19.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of
                                    ('a, GVC_Z19.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_Z19.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GVC_Z19.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GVC_Z19.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GVC_Z19.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GVC_Z19.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GFC_F :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GFC_F).wmatrix = {
      matrix : 'a GFC_F.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GFC_F).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GFC_F).curposval = {
      p : 'a curpos;
      curval : ('a, GFC_F.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GFC_F.Dom.v ref
        type 'a lstate
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val decl :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GFC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GFC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GFC_F.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GFC_F.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GFC_F.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GFC_F.contr)
          lm
        val updt :
          'a GFC_F.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GFC_F.vo ->
          'a GFC_F.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GFC_F.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GFC_F.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GFC_F.Dom.v ref
        type 'a lstate = unit
        val decl : unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val upd_sign :
          unit ->
          (< answer : 'a; state : 'b; .. >, 'c option) StateCPSMonad.monad
        val zero_sign :
          unit -> 'a -> ('a -> ('b, unit) Code.abstract -> 'c) -> 'c
        val acc_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val get_magn :
          unit ->
          (< answer : 'a; state : 'b; .. >,
           ('c, GFC_F.Dom.v ref) Code.abstract)
          StateCPSMonad.monad
        val set_magn :
          'a -> 'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
        val fin : unit -> 'a
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
      end
    module AbstractDet :
      sig
        type tdet = GFC_F.Dom.v ref
        type 'a lstate =
            ('a, int ref) Code.abstract * ('a, tdet) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        val ip :
          ('a -> [> `TDet of 'a ]) * ([> `TDet of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GFC_F.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('c, unit) Code.abstract)
          StateCPSMonad.monad
        val upd_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract option)
          StateCPSMonad.monad
        val zero_sign :
          unit ->
          (< answer : 'a;
             state : [> `TDet of ('b, int ref) Code.abstract * 'c ] list;
             .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        val get_magn :
          unit ->
          (< answer : 'a; state : [> `TDet of 'b * 'c ] list; .. >, 'c)
          StateCPSMonad.monad
        val set_magn :
          ('a, 'b) Code.abstract ->
          (< answer : 'c;
             state : [> `TDet of 'd * ('a, 'b ref) Code.abstract ] list; .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val acc_magn :
          'a GFC_F.Dom.vc ->
          (< answer : 'b;
             state : [> `TDet of 'c * ('a, GFC_F.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('a, unit) Code.abstract)
          StateCPSMonad.monad
        val fin :
          unit ->
          (< answer : 'a;
             state : [> `TDet of
                          ('b, int ref) Code.abstract *
                          ('b, GFC_F.Dom.v ref) Code.abstract ]
                     list;
             .. >,
           ('b, GFC_F.Dom.v) Code.abstract)
          StateCPSMonad.monad
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GFC_F.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GFC_F.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GFC_F.Dom.vc
              val update :
                'a GFC_F.Dom.vc ->
                'a GFC_F.Dom.vc ->
                'a GFC_F.Dom.vc ->
                'a GFC_F.Dom.vc ->
                ('a GFC_F.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GFC_F.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GFC_F.Dom.vc
              val update :
                'a GFC_F.Dom.vc ->
                'a GFC_F.Dom.vc ->
                'a GFC_F.Dom.vc ->
                'a GFC_F.Dom.vc ->
                ('a GFC_F.Dom.vc -> 'b) ->
                ('a, GFC_F.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GFC_F.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GFC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GFC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GFC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GFC_F.vo ->
              'a GFC_F.vo ->
              (< answer : 'b; state : [> `TLower of 'a GFC_F.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GFC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GFC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GFC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GFC_F.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GFC_F.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GFC_F.contr
            val get_input :
              'a GFC_F.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GFC_F.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GFC_F.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GFC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GFC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GFC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GFC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GFC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GFC_F.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GFC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GFC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr * GFC_F.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GFC_F.contr * GFC_F.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GFC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GFC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GFC_F.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        'b -> ('b -> ('c, unit) Code.abstract -> 'd) -> 'd
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GFC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GFC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr * GFC_F.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GFC_F.contr * GFC_F.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GFC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GFC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr * GFC_F.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GFC_F.contr * GFC_F.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GFC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GFC_F.vo ->
                        'a GFC_F.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GFC_F.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr * GFC_F.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GFC_F.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('c, unit) Code.abstract)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            lm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GFC_F.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GFC_F.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GFC_F.contr)
                            lm
                          val updt :
                            'a GFC_F.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GFC_F.vo ->
                            'a GFC_F.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GFC_F.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GFC_F.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GFC_F.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GFC_F.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GFC_F.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GFC_F.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GFC_F.contr * GFC_F.contr
            type rhs = GFC_F.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GFC_F.contr) Code.abstract ->
              ('a, GFC_F.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GFC_F.contr
            val make_result :
              'a GFC_F.vc ->
              'a GFC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GFC_F.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                lm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GFC_F.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GFC_F.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GFC_F.contr)
                                lm
                              val updt :
                                'a GFC_F.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GFC_F.vo ->
                                'a GFC_F.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GFC_F.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GFC_F.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GFC_F.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GFC_F.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GFC_F.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GFC_F.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GFC_F.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GFC_F.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GFC_F.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GFC_F.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module GenFA1 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GAC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA2 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_F.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA3 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * int
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GAC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA4 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v * int
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_F.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA11 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GAC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA12 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_F.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA13 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * int
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GAC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA14 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v * int
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_F.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA24 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v * int * Code.perm list
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_F.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA25 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = int array
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, int * int) Code.abstract
                type 'a pra = ('a, int array) Code.abstract
                type 'a lstate = ('a, int array ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v * int * int array
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_F.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, int array ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, int array ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA26 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GAC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA5 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GAC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA6 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_F.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA7 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * int
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GAC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA8 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v * int
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_F.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_F.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA9 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * Code.perm list
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GAC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA31 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.contr * Code.perm list
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GAC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA32 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * Code.perm list
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GAC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV1 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GVC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV2 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr * GVC_F.Dom.v
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_F.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_F.Dom.v ref) Code.abstract
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_F.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV3 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr * int
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GVC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV4 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr * GVC_F.Dom.v * int
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_F.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_F.Dom.v ref) Code.abstract
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_F.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV5 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr * GVC_F.Dom.v * int
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_F.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_F.Dom.v ref) Code.abstract
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_F.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_F.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV6 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr * GVC_F.contr * Code.perm list
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GVC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV7 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr * Code.perm list
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of unit | `TLower of ('a, GVC_F.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIA1 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val updt :
                  'a GAC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_I.vo ->
                  'a GAC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_I.contr
        val make_result :
          'a G_GAC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_I.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_I.wmatrix ->
      'a G_GAC_I.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_I.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_I.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
- : unit = ()
module GenIA2 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val updt :
                  'a GAC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_I.vo ->
                  'a GAC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_I.contr * GAC_I.Dom.v
        val make_result :
          'a G_GAC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_I.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_I.wmatrix ->
      'a G_GAC_I.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_I.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_I.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIA3 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val updt :
                  'a GAC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_I.vo ->
                  'a GAC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_I.contr * int
        val make_result :
          'a G_GAC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_I.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_I.wmatrix ->
      'a G_GAC_I.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_I.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_I.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIA4 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val updt :
                  'a GAC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_I.vo ->
                  'a GAC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_I.contr * GAC_I.Dom.v * int
        val make_result :
          'a G_GAC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_I.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_I.wmatrix ->
      'a G_GAC_I.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_I.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_I.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
- : unit = ()
- : unit = ()
module GenIV1 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val updt :
                  'a GVC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_I.vo ->
                  'a GVC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_I.contr
        val make_result :
          'a G_GVC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_I.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_I.wmatrix ->
      'a G_GVC_I.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_I.Dom.v ref) Code.abstract
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_I.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIV2 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val updt :
                  'a GVC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_I.vo ->
                  'a GVC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_I.contr * GVC_I.Dom.v
        val make_result :
          'a G_GVC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_I.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_I.wmatrix ->
      'a G_GVC_I.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_I.Dom.v ref) Code.abstract
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_I.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIV3 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val updt :
                  'a GVC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_I.vo ->
                  'a GVC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_I.contr * int
        val make_result :
          'a G_GVC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_I.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_I.wmatrix ->
      'a G_GVC_I.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_I.Dom.v ref) Code.abstract
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_I.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIV4 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val updt :
                  'a GVC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_I.vo ->
                  'a GVC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_I.contr * GVC_I.Dom.v * int
        val make_result :
          'a G_GVC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_I.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_I.wmatrix ->
      'a G_GVC_I.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_I.Dom.v ref) Code.abstract
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_I.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIV5 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val updt :
                  'a GVC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_I.vo ->
                  'a GVC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_I.contr * GVC_I.Dom.v * int
        val make_result :
          'a G_GVC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_I.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_I.wmatrix ->
      'a G_GVC_I.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_I.Dom.v ref) Code.abstract
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_I.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIV6 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val updt :
                  'a GVC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_I.vo ->
                  'a GVC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_I.contr * GVC_I.Dom.v * int * Code.perm list
        val make_result :
          'a G_GVC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_I.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_I.wmatrix ->
      'a G_GVC_I.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_I.Dom.v ref) Code.abstract
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GVC_I.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_I.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_I.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenRA1 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_R.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_R.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val updt :
                  'a GAC_R.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_R.vo ->
                  'a GAC_R.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_R.contr
        val make_result :
          'a G_GAC_R.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_R.wmatrix ->
      'a G_GAC_R.curposval ->
      ([> `TDet of unit | `TLower of ('a, GAC_R.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GAC_R.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GAC_R.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenRA2 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_R.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_R.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val updt :
                  'a GAC_R.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_R.vo ->
                  'a GAC_R.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_R.contr * GAC_R.Dom.v
        val make_result :
          'a G_GAC_R.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_R.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_R.wmatrix ->
      'a G_GAC_R.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_R.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_R.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_R.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_R.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_R.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_R.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_R.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenRA3 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_R.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_R.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val updt :
                  'a GAC_R.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_R.vo ->
                  'a GAC_R.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_R.contr * int
        val make_result :
          'a G_GAC_R.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of unit
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_R.wmatrix ->
      'a G_GAC_R.curposval ->
      ([> `TDet of unit | `TLower of ('a, GAC_R.contr) Code.abstract ] as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of ('a, GAC_R.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of unit
        | `TLower of ('a, GAC_R.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of unit
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenRA4 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_R.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_R.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val updt :
                  'a GAC_R.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_R.vo ->
                  'a GAC_R.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_R.contr * GAC_R.Dom.v * int
        val make_result :
          'a G_GAC_R.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GAC_R.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_R.wmatrix ->
      'a G_GAC_R.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_R.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_R.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_R.Dom.v ref) Code.abstract
                  | `TLower of ('a, GAC_R.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract * ('a, GAC_R.Dom.v ref) Code.abstract
        | `TLower of ('a, GAC_R.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GAC_R.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenZp3 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_Z3.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_Z3.contr)
                  lm
                val updt :
                  'a GVC_Z3.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_Z3.vo ->
                  'a GVC_Z3.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_Z3.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_Z3.contr * GVC_Z3.Dom.v * int * Code.perm list
        val make_result :
          'a G_GVC_Z3.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_Z3.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_Z3.wmatrix ->
      'a G_GVC_Z3.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract *
            ('a, GVC_Z3.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_Z3.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_Z3.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_Z3.Dom.v ref) Code.abstract
                  | `TLower of ('a, GVC_Z3.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_Z3.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_Z3.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract *
            ('a, GVC_Z3.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_Z3.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_Z3.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_Z3.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenZp19 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  lm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_Z19.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_Z19.contr)
                  lm
                val updt :
                  'a GVC_Z19.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_Z19.vo ->
                  'a GVC_Z19.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_Z19.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_Z19.contr * GVC_Z19.Dom.v * int * Code.perm list
        val make_result :
          'a G_GVC_Z19.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          ('a, int ref) Code.abstract *
                          ('a, GVC_Z19.Dom.v ref) Code.abstract
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_Z19.wmatrix ->
      'a G_GVC_Z19.curposval ->
      ([> `TDet of
            ('a, int ref) Code.abstract *
            ('a, GVC_Z19.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_Z19.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_Z19.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_Z19.Dom.v ref) Code.abstract
                  | `TLower of ('a, GVC_Z19.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_Z19.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_Z19.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of
            ('a, int ref) Code.abstract *
            ('a, GVC_Z19.Dom.v ref) Code.abstract
        | `TLower of ('a, GVC_Z19.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_Z19.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      ('a, int ref) Code.abstract *
                      ('a, GVC_Z19.Dom.v ref) Code.abstract
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
val resFA1 : ('a, GAC_F.contr -> GenFA1.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_10 = (! t_2) in
    let t_11 = (! t_3) in
    let t_12 = (ref (None)) in
    let t_18 =
     begin
      for j_15 = t_10 to (t_7 - 1) do
       let t_16 = (t_5.(j_15)).(t_11) in
       if (t_16 <> 0.) then
        (match (! t_12) with
         | Some (i_17) ->
            if ((abs_float (snd i_17)) < (abs_float t_16)) then
             (t_12 := (Some (j_15, t_16)))
            else ()
         | None -> (t_12 := (Some (j_15, t_16))))
       else ()
      done;
      (match (! t_12) with
       | Some (i_13) ->
          if ((fst i_13) <> t_10) then
           let t_14 = t_5.(t_10) in
           t_5.(t_10) <- t_5.(fst i_13);
           t_5.(fst i_13) <- t_14
          else ();
          (Some (snd i_13))
       | None -> (None))
     end in
    (match t_18 with
     | Some (i_19) ->
        begin
         for j_20 = (t_10 + 1) to (t_7 - 1) do
          let t_21 = (t_5.(j_20)).(t_11) in
          if (t_21 <> 0.) then begin
           for j_22 = (t_11 + 1) to (t_6 - 1) do
            (t_5.(j_20)).(j_22) <-
             ((t_5.(j_20)).(j_22) -. ((t_21 /. i_19) *. (t_5.(t_10)).(j_22)))
           done;
           (t_5.(j_20)).(t_11) <- 0.
          end else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   t_5>.
val resFA2 : ('a, GAC_F.contr -> GenFA2.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref 1.) in
   let t_9 = (ref 1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_12 = (! t_2) in
    let t_13 = (! t_3) in
    let t_14 = (ref (None)) in
    let t_20 =
     begin
      for j_17 = t_12 to (t_7 - 1) do
       let t_18 = (t_5.(j_17)).(t_13) in
       if (t_18 <> 0.) then
        (match (! t_14) with
         | Some (i_19) ->
            if ((abs_float (snd i_19)) < (abs_float t_18)) then
             (t_14 := (Some (j_17, t_18)))
            else ()
         | None -> (t_14 := (Some (j_17, t_18))))
       else ()
      done;
      (match (! t_14) with
       | Some (i_15) ->
          if ((fst i_15) <> t_12) then begin
           let t_16 = t_5.(t_12) in
           t_5.(t_12) <- t_5.(fst i_15);
           t_5.(fst i_15) <- t_16;
           (t_9 := (~- (! t_9)))
          end else ();
          (Some (snd i_15))
       | None -> (None))
     end in
    (match t_20 with
     | Some (i_21) ->
        begin
         for j_22 = (t_12 + 1) to (t_7 - 1) do
          let t_23 = (t_5.(j_22)).(t_13) in
          if (t_23 <> 0.) then begin
           for j_24 = (t_13 + 1) to (t_6 - 1) do
            (t_5.(j_22)).(j_24) <-
             ((t_5.(j_22)).(j_24) -. ((t_23 /. i_21) *. (t_5.(t_12)).(j_24)))
           done;
           (t_5.(j_22)).(t_13) <- 0.
          end else ()
         done;
         (t_8 := ((! t_8) *. i_21))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_9 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_5,
    if ((! t_9) = 0) then 0.
    else if ((! t_9) = 1) then (! t_8)
    else (~-. (! t_8)))>.
val resFA3 : ('a, GAC_F.contr -> GenFA3.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_10 = (! t_2) in
    let t_11 = (! t_3) in
    let t_12 = (ref (None)) in
    let t_18 =
     begin
      for j_15 = t_10 to (t_7 - 1) do
       let t_16 = (t_5.(j_15)).(t_11) in
       if (t_16 <> 0.) then
        (match (! t_12) with
         | Some (i_17) ->
            if ((abs_float (snd i_17)) < (abs_float t_16)) then
             (t_12 := (Some (j_15, t_16)))
            else ()
         | None -> (t_12 := (Some (j_15, t_16))))
       else ()
      done;
      (match (! t_12) with
       | Some (i_13) ->
          if ((fst i_13) <> t_10) then
           let t_14 = t_5.(t_10) in
           t_5.(t_10) <- t_5.(fst i_13);
           t_5.(fst i_13) <- t_14
          else ();
          (Some (snd i_13))
       | None -> (None))
     end in
    (match t_18 with
     | Some (i_19) ->
        begin
         for j_20 = (t_10 + 1) to (t_7 - 1) do
          let t_21 = (t_5.(j_20)).(t_11) in
          if (t_21 <> 0.) then begin
           for j_22 = (t_11 + 1) to (t_6 - 1) do
            (t_5.(j_20)).(j_22) <-
             ((t_5.(j_20)).(j_22) -. ((t_21 /. i_19) *. (t_5.(t_10)).(j_22)))
           done;
           (t_5.(j_20)).(t_11) <- 0.
          end else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   (t_5, (! t_2))>.
val resFA4 : ('a, GAC_F.contr -> GenFA4.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref 1.) in
   let t_9 = (ref 1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_12 = (! t_2) in
    let t_13 = (! t_3) in
    let t_14 = (ref (None)) in
    let t_20 =
     begin
      for j_17 = t_12 to (t_7 - 1) do
       let t_18 = (t_5.(j_17)).(t_13) in
       if (t_18 <> 0.) then
        (match (! t_14) with
         | Some (i_19) ->
            if ((abs_float (snd i_19)) < (abs_float t_18)) then
             (t_14 := (Some (j_17, t_18)))
            else ()
         | None -> (t_14 := (Some (j_17, t_18))))
       else ()
      done;
      (match (! t_14) with
       | Some (i_15) ->
          if ((fst i_15) <> t_12) then begin
           let t_16 = t_5.(t_12) in
           t_5.(t_12) <- t_5.(fst i_15);
           t_5.(fst i_15) <- t_16;
           (t_9 := (~- (! t_9)))
          end else ();
          (Some (snd i_15))
       | None -> (None))
     end in
    (match t_20 with
     | Some (i_21) ->
        begin
         for j_22 = (t_12 + 1) to (t_7 - 1) do
          let t_23 = (t_5.(j_22)).(t_13) in
          if (t_23 <> 0.) then begin
           for j_24 = (t_13 + 1) to (t_6 - 1) do
            (t_5.(j_22)).(j_24) <-
             ((t_5.(j_22)).(j_24) -. ((t_23 /. i_21) *. (t_5.(t_12)).(j_24)))
           done;
           (t_5.(j_22)).(t_13) <- 0.
          end else ()
         done;
         (t_8 := ((! t_8) *. i_21))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_9 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_5,
    if ((! t_9) = 0) then 0.
    else if ((! t_9) = 1) then (! t_8)
    else (~-. (! t_8)), (! t_2))>.
val resFV1 : ('a, GVC_F.contr -> GenFV1.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_4 = {arr = (Array.copy a_1.arr)} (a_1) in
   let t_5 = a_1.m in
   let t_6 = a_1.n in
   while (((! t_3) < t_5) && ((! t_2) < t_6)) do
    let t_11 = (! t_2) in
    let t_12 = (! t_3) in
    let t_13 = (ref (None)) in
    let t_24 =
     begin
      for j_21 = t_11 to (t_6 - 1) do
       let t_22 = (t_4.arr).((j_21 * t_4.m) + t_12) in
       if (t_22 <> 0.) then
        (match (! t_13) with
         | Some (i_23) ->
            if ((abs_float (snd i_23)) < (abs_float t_22)) then
             (t_13 := (Some (j_21, t_22)))
            else ()
         | None -> (t_13 := (Some (j_21, t_22))))
       else ()
      done;
      (match (! t_13) with
       | Some (i_14) ->
          if ((fst i_14) <> t_11) then
           let a_15 = t_4.arr
           and m_16 = t_4.m in
           let i1_17 = (t_11 * m_16)
           and i2_18 = ((fst i_14) * m_16) in
           for i_19 = t_12 to (m_16 - 1) do
            let t_20 = a_15.(i1_17 + i_19) in
            a_15.(i1_17 + i_19) <- a_15.(i2_18 + i_19);
            a_15.(i2_18 + i_19) <- t_20
           done
          else ();
          (Some (snd i_14))
       | None -> (None))
     end in
    (match t_24 with
     | Some (i_25) ->
        begin
         for j_26 = (t_11 + 1) to (t_6 - 1) do
          let t_27 = (t_4.arr).((j_26 * t_4.m) + t_12) in
          if (t_27 <> 0.) then begin
           for j_28 = (t_12 + 1) to (t_5 - 1) do
            (t_4.arr).((j_26 * t_4.m) + j_28) <-
             ((t_4.arr).((j_26 * t_4.m) + j_28) -.
               ((t_27 /. i_25) *. (t_4.arr).((t_11 * t_4.m) + j_28)))
           done;
           (t_4.arr).((j_26 * t_4.m) + t_12) <- 0.
          end else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   t_4>.
val resFV2 : ('a, GVC_F.contr -> GenFV2.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_4 = {arr = (Array.copy a_1.arr)} (a_1) in
   let t_5 = a_1.m in
   let t_6 = a_1.n in
   let t_7 = (ref 1.) in
   let t_8 = (ref 1) in
   while (((! t_3) < t_5) && ((! t_2) < t_6)) do
    let t_13 = (! t_2) in
    let t_14 = (! t_3) in
    let t_15 = (ref (None)) in
    let t_26 =
     begin
      for j_23 = t_13 to (t_6 - 1) do
       let t_24 = (t_4.arr).((j_23 * t_4.m) + t_14) in
       if (t_24 <> 0.) then
        (match (! t_15) with
         | Some (i_25) ->
            if ((abs_float (snd i_25)) < (abs_float t_24)) then
             (t_15 := (Some (j_23, t_24)))
            else ()
         | None -> (t_15 := (Some (j_23, t_24))))
       else ()
      done;
      (match (! t_15) with
       | Some (i_16) ->
          if ((fst i_16) <> t_13) then begin
           let a_17 = t_4.arr
           and m_18 = t_4.m in
           let i1_19 = (t_13 * m_18)
           and i2_20 = ((fst i_16) * m_18) in
           for i_21 = t_14 to (m_18 - 1) do
            let t_22 = a_17.(i1_19 + i_21) in
            a_17.(i1_19 + i_21) <- a_17.(i2_20 + i_21);
            a_17.(i2_20 + i_21) <- t_22
           done;
           (t_8 := (~- (! t_8)))
          end else ();
          (Some (snd i_16))
       | None -> (None))
     end in
    (match t_26 with
     | Some (i_27) ->
        begin
         for j_28 = (t_13 + 1) to (t_6 - 1) do
          let t_29 = (t_4.arr).((j_28 * t_4.m) + t_14) in
          if (t_29 <> 0.) then begin
           for j_30 = (t_14 + 1) to (t_5 - 1) do
            (t_4.arr).((j_28 * t_4.m) + j_30) <-
             ((t_4.arr).((j_28 * t_4.m) + j_30) -.
               ((t_29 /. i_27) *. (t_4.arr).((t_13 * t_4.m) + j_30)))
           done;
           (t_4.arr).((j_28 * t_4.m) + t_14) <- 0.
          end else ()
         done;
         (t_7 := ((! t_7) *. i_27))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_8 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_4,
    if ((! t_8) = 0) then 0.
    else if ((! t_8) = 1) then (! t_7)
    else (~-. (! t_7)))>.
val resFV3 : ('a, GVC_F.contr -> GenFV3.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_4 = {arr = (Array.copy a_1.arr)} (a_1) in
   let t_5 = a_1.m in
   let t_6 = a_1.n in
   while (((! t_3) < t_5) && ((! t_2) < t_6)) do
    let t_11 = (! t_2) in
    let t_12 = (! t_3) in
    let t_13 = (ref (None)) in
    let t_24 =
     begin
      for j_21 = t_11 to (t_6 - 1) do
       let t_22 = (t_4.arr).((j_21 * t_4.m) + t_12) in
       if (t_22 <> 0.) then
        (match (! t_13) with
         | Some (i_23) ->
            if ((abs_float (snd i_23)) < (abs_float t_22)) then
             (t_13 := (Some (j_21, t_22)))
            else ()
         | None -> (t_13 := (Some (j_21, t_22))))
       else ()
      done;
      (match (! t_13) with
       | Some (i_14) ->
          if ((fst i_14) <> t_11) then
           let a_15 = t_4.arr
           and m_16 = t_4.m in
           let i1_17 = (t_11 * m_16)
           and i2_18 = ((fst i_14) * m_16) in
           for i_19 = t_12 to (m_16 - 1) do
            let t_20 = a_15.(i1_17 + i_19) in
            a_15.(i1_17 + i_19) <- a_15.(i2_18 + i_19);
            a_15.(i2_18 + i_19) <- t_20
           done
          else ();
          (Some (snd i_14))
       | None -> (None))
     end in
    (match t_24 with
     | Some (i_25) ->
        begin
         for j_26 = (t_11 + 1) to (t_6 - 1) do
          let t_27 = (t_4.arr).((j_26 * t_4.m) + t_12) in
          if (t_27 <> 0.) then begin
           for j_28 = (t_12 + 1) to (t_5 - 1) do
            (t_4.arr).((j_26 * t_4.m) + j_28) <-
             ((t_4.arr).((j_26 * t_4.m) + j_28) -.
               ((t_27 /. i_25) *. (t_4.arr).((t_11 * t_4.m) + j_28)))
           done;
           (t_4.arr).((j_26 * t_4.m) + t_12) <- 0.
          end else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   (t_4, (! t_2))>.
val resFV4 : ('a, GVC_F.contr -> GenFV4.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_4 = {arr = (Array.copy a_1.arr)} (a_1) in
   let t_5 = a_1.m in
   let t_6 = a_1.n in
   let t_7 = (ref 1.) in
   let t_8 = (ref 1) in
   while (((! t_3) < t_5) && ((! t_2) < t_6)) do
    let t_13 = (! t_2) in
    let t_14 = (! t_3) in
    let t_15 = (ref (None)) in
    let t_26 =
     begin
      for j_23 = t_13 to (t_6 - 1) do
       let t_24 = (t_4.arr).((j_23 * t_4.m) + t_14) in
       if (t_24 <> 0.) then
        (match (! t_15) with
         | Some (i_25) ->
            if ((abs_float (snd i_25)) < (abs_float t_24)) then
             (t_15 := (Some (j_23, t_24)))
            else ()
         | None -> (t_15 := (Some (j_23, t_24))))
       else ()
      done;
      (match (! t_15) with
       | Some (i_16) ->
          if ((fst i_16) <> t_13) then begin
           let a_17 = t_4.arr
           and m_18 = t_4.m in
           let i1_19 = (t_13 * m_18)
           and i2_20 = ((fst i_16) * m_18) in
           for i_21 = t_14 to (m_18 - 1) do
            let t_22 = a_17.(i1_19 + i_21) in
            a_17.(i1_19 + i_21) <- a_17.(i2_20 + i_21);
            a_17.(i2_20 + i_21) <- t_22
           done;
           (t_8 := (~- (! t_8)))
          end else ();
          (Some (snd i_16))
       | None -> (None))
     end in
    (match t_26 with
     | Some (i_27) ->
        begin
         for j_28 = (t_13 + 1) to (t_6 - 1) do
          let t_29 = (t_4.arr).((j_28 * t_4.m) + t_14) in
          if (t_29 <> 0.) then begin
           for j_30 = (t_14 + 1) to (t_5 - 1) do
            (t_4.arr).((j_28 * t_4.m) + j_30) <-
             ((t_4.arr).((j_28 * t_4.m) + j_30) -.
               ((t_29 /. i_27) *. (t_4.arr).((t_13 * t_4.m) + j_30)))
           done;
           (t_4.arr).((j_28 * t_4.m) + t_14) <- 0.
          end else ()
         done;
         (t_7 := ((! t_7) *. i_27))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_8 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_4,
    if ((! t_8) = 0) then 0.
    else if ((! t_8) = 1) then (! t_7)
    else (~-. (! t_7)), (! t_2))>.
val resFV5 : ('a, GVC_F.contr -> GenFV5.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_4 = {arr = (Array.copy a_1.arr)} (a_1) in
   let t_5 = a_1.m in
   let t_6 = a_1.n in
   let t_7 = (ref 1.) in
   let t_8 = (ref 1) in
   while (((! t_3) < t_5) && ((! t_2) < t_6)) do
    let t_13 = (! t_2) in
    let t_14 = (! t_3) in
    let t_15 = (ref (None)) in
    let t_34 =
     begin
      for j_30 = t_13 to (t_6 - 1) do
       for j_31 = t_14 to (t_5 - 1) do
        let t_32 = (t_4.arr).((j_30 * t_4.m) + j_31) in
        if (t_32 <> 0.) then
         (match (! t_15) with
          | Some (i_33) ->
             if ((abs_float (snd i_33)) < (abs_float t_32)) then
              (t_15 := (Some ((j_30, j_31), t_32)))
             else ()
          | None -> (t_15 := (Some ((j_30, j_31), t_32))))
        else ()
       done
      done;
      (match (! t_15) with
       | Some (i_16) ->
          if ((snd (fst i_16)) <> t_14) then begin
           let a_23 = t_4.arr
           and nm_24 = (t_4.n * t_4.m)
           and m_25 = t_4.m in
           let rec loop_26 =
            fun i1_27 ->
             fun i2_28 ->
              if (i2_28 < nm_24) then
               let t_29 = a_23.(i1_27) in
               a_23.(i1_27) <- a_23.(i2_28);
               a_23.(i2_28) <- t_29;
               (loop_26 (i1_27 + m_25) (i2_28 + m_25))
              else () in
           (loop_26 t_14 (snd (fst i_16)));
           (t_8 := (~- (! t_8)))
          end else ();
          if ((fst (fst i_16)) <> t_13) then begin
           let a_17 = t_4.arr
           and m_18 = t_4.m in
           let i1_19 = (t_13 * m_18)
           and i2_20 = ((snd (fst i_16)) * m_18) in
           for i_21 = t_14 to (m_18 - 1) do
            let t_22 = a_17.(i1_19 + i_21) in
            a_17.(i1_19 + i_21) <- a_17.(i2_20 + i_21);
            a_17.(i2_20 + i_21) <- t_22
           done;
           (t_8 := (~- (! t_8)))
          end else ();
          (Some (snd i_16))
       | None -> (None))
     end in
    (match t_34 with
     | Some (i_35) ->
        begin
         for j_36 = (t_13 + 1) to (t_6 - 1) do
          let t_37 = (t_4.arr).((j_36 * t_4.m) + t_14) in
          if (t_37 <> 0.) then begin
           for j_38 = (t_14 + 1) to (t_5 - 1) do
            (t_4.arr).((j_36 * t_4.m) + j_38) <-
             ((t_4.arr).((j_36 * t_4.m) + j_38) -.
               ((t_37 /. i_35) *. (t_4.arr).((t_13 * t_4.m) + j_38)))
           done;
           (t_4.arr).((j_36 * t_4.m) + t_14) <- 0.
          end else ()
         done;
         (t_7 := ((! t_7) *. i_35))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_8 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_4,
    if ((! t_8) = 0) then 0.
    else if ((! t_8) = 1) then (! t_7)
    else (~-. (! t_7)), (! t_2))>.
val resIA1 : ('a, GAC_I.contr -> GenIA1.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref 1) in
   let t_9 = (ref 1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_12 = (! t_2) in
    let t_13 = (! t_3) in
    let t_14 = (ref (None)) in
    let t_20 =
     begin
      for j_17 = t_12 to (t_7 - 1) do
       let t_18 = (t_5.(j_17)).(t_13) in
       if (t_18 <> 0) then
        (match (! t_14) with
         | Some (i_19) ->
            if ((abs (snd i_19)) > (abs t_18)) then
             (t_14 := (Some (j_17, t_18)))
            else ()
         | None -> (t_14 := (Some (j_17, t_18))))
       else ()
      done;
      (match (! t_14) with
       | Some (i_15) ->
          if ((fst i_15) <> t_12) then begin
           let t_16 = t_5.(t_12) in
           t_5.(t_12) <- t_5.(fst i_15);
           t_5.(fst i_15) <- t_16;
           (t_9 := (~- (! t_9)))
          end else ();
          (Some (snd i_15))
       | None -> (None))
     end in
    (match t_20 with
     | Some (i_21) ->
        begin
         for j_22 = (t_12 + 1) to (t_7 - 1) do
          let t_23 = (t_5.(j_22)).(t_13) in
          if (t_23 <> 0) then begin
           for j_24 = (t_13 + 1) to (t_6 - 1) do
            (t_5.(j_22)).(j_24) <-
             ((((t_5.(j_22)).(j_24) * i_21) - ((t_5.(t_12)).(j_24) * t_23)) /
               (! t_8))
           done;
           (t_5.(j_22)).(t_13) <- 0
          end else ()
         done;
         (t_8 := i_21)
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_9 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   t_5>.
val resIA2 : ('a, GAC_I.contr -> GenIA2.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref 1) in
   let t_9 = (ref 1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_12 = (! t_2) in
    let t_13 = (! t_3) in
    let t_14 = (ref (None)) in
    let t_20 =
     begin
      for j_17 = t_12 to (t_7 - 1) do
       let t_18 = (t_5.(j_17)).(t_13) in
       if (t_18 <> 0) then
        (match (! t_14) with
         | Some (i_19) ->
            if ((abs (snd i_19)) > (abs t_18)) then
             (t_14 := (Some (j_17, t_18)))
            else ()
         | None -> (t_14 := (Some (j_17, t_18))))
       else ()
      done;
      (match (! t_14) with
       | Some (i_15) ->
          if ((fst i_15) <> t_12) then begin
           let t_16 = t_5.(t_12) in
           t_5.(t_12) <- t_5.(fst i_15);
           t_5.(fst i_15) <- t_16;
           (t_9 := (~- (! t_9)))
          end else ();
          (Some (snd i_15))
       | None -> (None))
     end in
    (match t_20 with
     | Some (i_21) ->
        begin
         for j_22 = (t_12 + 1) to (t_7 - 1) do
          let t_23 = (t_5.(j_22)).(t_13) in
          if (t_23 <> 0) then begin
           for j_24 = (t_13 + 1) to (t_6 - 1) do
            (t_5.(j_22)).(j_24) <-
             ((((t_5.(j_22)).(j_24) * i_21) - ((t_5.(t_12)).(j_24) * t_23)) /
               (! t_8))
           done;
           (t_5.(j_22)).(t_13) <- 0
          end else ()
         done;
         (t_8 := i_21)
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_9 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_5,
    if ((! t_9) = 0) then 0
    else if ((! t_9) = 1) then (! t_8)
    else (~- (! t_8)))>.
val resIA3 : ('a, GAC_I.contr -> GenIA3.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref 1) in
   let t_9 = (ref 1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_12 = (! t_2) in
    let t_13 = (! t_3) in
    let t_14 = (ref (None)) in
    let t_20 =
     begin
      for j_17 = t_12 to (t_7 - 1) do
       let t_18 = (t_5.(j_17)).(t_13) in
       if (t_18 <> 0) then
        (match (! t_14) with
         | Some (i_19) ->
            if ((abs (snd i_19)) > (abs t_18)) then
             (t_14 := (Some (j_17, t_18)))
            else ()
         | None -> (t_14 := (Some (j_17, t_18))))
       else ()
      done;
      (match (! t_14) with
       | Some (i_15) ->
          if ((fst i_15) <> t_12) then begin
           let t_16 = t_5.(t_12) in
           t_5.(t_12) <- t_5.(fst i_15);
           t_5.(fst i_15) <- t_16;
           (t_9 := (~- (! t_9)))
          end else ();
          (Some (snd i_15))
       | None -> (None))
     end in
    (match t_20 with
     | Some (i_21) ->
        begin
         for j_22 = (t_12 + 1) to (t_7 - 1) do
          let t_23 = (t_5.(j_22)).(t_13) in
          if (t_23 <> 0) then begin
           for j_24 = (t_13 + 1) to (t_6 - 1) do
            (t_5.(j_22)).(j_24) <-
             ((((t_5.(j_22)).(j_24) * i_21) - ((t_5.(t_12)).(j_24) * t_23)) /
               (! t_8))
           done;
           (t_5.(j_22)).(t_13) <- 0
          end else ()
         done;
         (t_8 := i_21)
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_9 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_5, (! t_2))>.
val resIA4 : ('a, GAC_I.contr -> GenIA4.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref 1) in
   let t_9 = (ref 1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_12 = (! t_2) in
    let t_13 = (! t_3) in
    let t_14 = (ref (None)) in
    let t_20 =
     begin
      for j_17 = t_12 to (t_7 - 1) do
       let t_18 = (t_5.(j_17)).(t_13) in
       if (t_18 <> 0) then
        (match (! t_14) with
         | Some (i_19) ->
            if ((abs (snd i_19)) > (abs t_18)) then
             (t_14 := (Some (j_17, t_18)))
            else ()
         | None -> (t_14 := (Some (j_17, t_18))))
       else ()
      done;
      (match (! t_14) with
       | Some (i_15) ->
          if ((fst i_15) <> t_12) then begin
           let t_16 = t_5.(t_12) in
           t_5.(t_12) <- t_5.(fst i_15);
           t_5.(fst i_15) <- t_16;
           (t_9 := (~- (! t_9)))
          end else ();
          (Some (snd i_15))
       | None -> (None))
     end in
    (match t_20 with
     | Some (i_21) ->
        begin
         for j_22 = (t_12 + 1) to (t_7 - 1) do
          let t_23 = (t_5.(j_22)).(t_13) in
          if (t_23 <> 0) then begin
           for j_24 = (t_13 + 1) to (t_6 - 1) do
            (t_5.(j_22)).(j_24) <-
             ((((t_5.(j_22)).(j_24) * i_21) - ((t_5.(t_12)).(j_24) * t_23)) /
               (! t_8))
           done;
           (t_5.(j_22)).(t_13) <- 0
          end else ()
         done;
         (t_8 := i_21)
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_9 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_5,
    if ((! t_9) = 0) then 0
    else if ((! t_9) = 1) then (! t_8)
    else (~- (! t_8)), (! t_2))>.
val resIV1 : ('a, GVC_I.contr -> GenIV1.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_4 = {arr = (Array.copy a_1.arr)} (a_1) in
   let t_5 = a_1.m in
   let t_6 = a_1.n in
   let t_7 = (ref 1) in
   let t_8 = (ref 1) in
   while (((! t_3) < t_5) && ((! t_2) < t_6)) do
    let t_13 = (! t_2) in
    let t_14 = (! t_3) in
    let t_15 = (ref (None)) in
    let t_26 =
     begin
      for j_23 = t_13 to (t_6 - 1) do
       let t_24 = (t_4.arr).((j_23 * t_4.m) + t_14) in
       if (t_24 <> 0) then
        (match (! t_15) with
         | Some (i_25) ->
            if ((abs (snd i_25)) > (abs t_24)) then
             (t_15 := (Some (j_23, t_24)))
            else ()
         | None -> (t_15 := (Some (j_23, t_24))))
       else ()
      done;
      (match (! t_15) with
       | Some (i_16) ->
          if ((fst i_16) <> t_13) then begin
           let a_17 = t_4.arr
           and m_18 = t_4.m in
           let i1_19 = (t_13 * m_18)
           and i2_20 = ((fst i_16) * m_18) in
           for i_21 = t_14 to (m_18 - 1) do
            let t_22 = a_17.(i1_19 + i_21) in
            a_17.(i1_19 + i_21) <- a_17.(i2_20 + i_21);
            a_17.(i2_20 + i_21) <- t_22
           done;
           (t_8 := (~- (! t_8)))
          end else ();
          (Some (snd i_16))
       | None -> (None))
     end in
    (match t_26 with
     | Some (i_27) ->
        begin
         for j_28 = (t_13 + 1) to (t_6 - 1) do
          let t_29 = (t_4.arr).((j_28 * t_4.m) + t_14) in
          if (t_29 <> 0) then begin
           for j_30 = (t_14 + 1) to (t_5 - 1) do
            (t_4.arr).((j_28 * t_4.m) + j_30) <-
             ((((t_4.arr).((j_28 * t_4.m) + j_30) * i_27) -
                ((t_4.arr).((t_13 * t_4.m) + j_30) * t_29)) / (! t_7))
           done;
           (t_4.arr).((j_28 * t_4.m) + t_14) <- 0
          end else ()
         done;
         (t_7 := i_27)
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_8 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   t_4>.
val resIV2 : ('a, GVC_I.contr -> GenIV2.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_4 = {arr = (Array.copy a_1.arr)} (a_1) in
   let t_5 = a_1.m in
   let t_6 = a_1.n in
   let t_7 = (ref 1) in
   let t_8 = (ref 1) in
   while (((! t_3) < t_5) && ((! t_2) < t_6)) do
    let t_13 = (! t_2) in
    let t_14 = (! t_3) in
    let t_15 = (ref (None)) in
    let t_26 =
     begin
      for j_23 = t_13 to (t_6 - 1) do
       let t_24 = (t_4.arr).((j_23 * t_4.m) + t_14) in
       if (t_24 <> 0) then
        (match (! t_15) with
         | Some (i_25) ->
            if ((abs (snd i_25)) > (abs t_24)) then
             (t_15 := (Some (j_23, t_24)))
            else ()
         | None -> (t_15 := (Some (j_23, t_24))))
       else ()
      done;
      (match (! t_15) with
       | Some (i_16) ->
          if ((fst i_16) <> t_13) then begin
           let a_17 = t_4.arr
           and m_18 = t_4.m in
           let i1_19 = (t_13 * m_18)
           and i2_20 = ((fst i_16) * m_18) in
           for i_21 = t_14 to (m_18 - 1) do
            let t_22 = a_17.(i1_19 + i_21) in
            a_17.(i1_19 + i_21) <- a_17.(i2_20 + i_21);
            a_17.(i2_20 + i_21) <- t_22
           done;
           (t_8 := (~- (! t_8)))
          end else ();
          (Some (snd i_16))
       | None -> (None))
     end in
    (match t_26 with
     | Some (i_27) ->
        begin
         for j_28 = (t_13 + 1) to (t_6 - 1) do
          let t_29 = (t_4.arr).((j_28 * t_4.m) + t_14) in
          if (t_29 <> 0) then begin
           for j_30 = (t_14 + 1) to (t_5 - 1) do
            (t_4.arr).((j_28 * t_4.m) + j_30) <-
             ((((t_4.arr).((j_28 * t_4.m) + j_30) * i_27) -
                ((t_4.arr).((t_13 * t_4.m) + j_30) * t_29)) / (! t_7))
           done;
           (t_4.arr).((j_28 * t_4.m) + t_14) <- 0
          end else ()
         done;
         (t_7 := i_27)
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_8 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_4,
    if ((! t_8) = 0) then 0
    else if ((! t_8) = 1) then (! t_7)
    else (~- (! t_7)))>.
val resIV3 : ('a, GVC_I.contr -> GenIV3.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_4 = {arr = (Array.copy a_1.arr)} (a_1) in
   let t_5 = a_1.m in
   let t_6 = a_1.n in
   let t_7 = (ref 1) in
   let t_8 = (ref 1) in
   while (((! t_3) < t_5) && ((! t_2) < t_6)) do
    let t_13 = (! t_2) in
    let t_14 = (! t_3) in
    let t_15 = (ref (None)) in
    let t_26 =
     begin
      for j_23 = t_13 to (t_6 - 1) do
       let t_24 = (t_4.arr).((j_23 * t_4.m) + t_14) in
       if (t_24 <> 0) then
        (match (! t_15) with
         | Some (i_25) ->
            if ((abs (snd i_25)) > (abs t_24)) then
             (t_15 := (Some (j_23, t_24)))
            else ()
         | None -> (t_15 := (Some (j_23, t_24))))
       else ()
      done;
      (match (! t_15) with
       | Some (i_16) ->
          if ((fst i_16) <> t_13) then begin
           let a_17 = t_4.arr
           and m_18 = t_4.m in
           let i1_19 = (t_13 * m_18)
           and i2_20 = ((fst i_16) * m_18) in
           for i_21 = t_14 to (m_18 - 1) do
            let t_22 = a_17.(i1_19 + i_21) in
            a_17.(i1_19 + i_21) <- a_17.(i2_20 + i_21);
            a_17.(i2_20 + i_21) <- t_22
           done;
           (t_8 := (~- (! t_8)))
          end else ();
          (Some (snd i_16))
       | None -> (None))
     end in
    (match t_26 with
     | Some (i_27) ->
        begin
         for j_28 = (t_13 + 1) to (t_6 - 1) do
          let t_29 = (t_4.arr).((j_28 * t_4.m) + t_14) in
          if (t_29 <> 0) then begin
           for j_30 = (t_14 + 1) to (t_5 - 1) do
            (t_4.arr).((j_28 * t_4.m) + j_30) <-
             ((((t_4.arr).((j_28 * t_4.m) + j_30) * i_27) -
                ((t_4.arr).((t_13 * t_4.m) + j_30) * t_29)) / (! t_7))
           done;
           (t_4.arr).((j_28 * t_4.m) + t_14) <- 0
          end else ()
         done;
         (t_7 := i_27)
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_8 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_4, (! t_2))>.
val resIV4 : ('a, GVC_I.contr -> GenIV4.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_4 = {arr = (Array.copy a_1.arr)} (a_1) in
   let t_5 = a_1.m in
   let t_6 = a_1.n in
   let t_7 = (ref 1) in
   let t_8 = (ref 1) in
   while (((! t_3) < t_5) && ((! t_2) < t_6)) do
    let t_13 = (! t_2) in
    let t_14 = (! t_3) in
    let t_15 = (ref (None)) in
    let t_26 =
     begin
      for j_23 = t_13 to (t_6 - 1) do
       let t_24 = (t_4.arr).((j_23 * t_4.m) + t_14) in
       if (t_24 <> 0) then
        (match (! t_15) with
         | Some (i_25) ->
            if ((abs (snd i_25)) > (abs t_24)) then
             (t_15 := (Some (j_23, t_24)))
            else ()
         | None -> (t_15 := (Some (j_23, t_24))))
       else ()
      done;
      (match (! t_15) with
       | Some (i_16) ->
          if ((fst i_16) <> t_13) then begin
           let a_17 = t_4.arr
           and m_18 = t_4.m in
           let i1_19 = (t_13 * m_18)
           and i2_20 = ((fst i_16) * m_18) in
           for i_21 = t_14 to (m_18 - 1) do
            let t_22 = a_17.(i1_19 + i_21) in
            a_17.(i1_19 + i_21) <- a_17.(i2_20 + i_21);
            a_17.(i2_20 + i_21) <- t_22
           done;
           (t_8 := (~- (! t_8)))
          end else ();
          (Some (snd i_16))
       | None -> (None))
     end in
    (match t_26 with
     | Some (i_27) ->
        begin
         for j_28 = (t_13 + 1) to (t_6 - 1) do
          let t_29 = (t_4.arr).((j_28 * t_4.m) + t_14) in
          if (t_29 <> 0) then begin
           for j_30 = (t_14 + 1) to (t_5 - 1) do
            (t_4.arr).((j_28 * t_4.m) + j_30) <-
             ((((t_4.arr).((j_28 * t_4.m) + j_30) * i_27) -
                ((t_4.arr).((t_13 * t_4.m) + j_30) * t_29)) / (! t_7))
           done;
           (t_4.arr).((j_28 * t_4.m) + t_14) <- 0
          end else ()
         done;
         (t_7 := i_27)
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_8 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_4,
    if ((! t_8) = 0) then 0
    else if ((! t_8) = 1) then (! t_7)
    else (~- (! t_7)), (! t_2))>.
val resIV5 : ('a, GVC_I.contr -> GenIV5.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_4 = {arr = (Array.copy a_1.arr)} (a_1) in
   let t_5 = a_1.m in
   let t_6 = a_1.n in
   let t_7 = (ref 1) in
   let t_8 = (ref 1) in
   while (((! t_3) < t_5) && ((! t_2) < t_6)) do
    let t_13 = (! t_2) in
    let t_14 = (! t_3) in
    let t_15 = (ref (None)) in
    let t_34 =
     begin
      for j_30 = t_13 to (t_6 - 1) do
       for j_31 = t_14 to (t_5 - 1) do
        let t_32 = (t_4.arr).((j_30 * t_4.m) + j_31) in
        if (t_32 <> 0) then
         (match (! t_15) with
          | Some (i_33) ->
             if ((abs (snd i_33)) > (abs t_32)) then
              (t_15 := (Some ((j_30, j_31), t_32)))
             else ()
          | None -> (t_15 := (Some ((j_30, j_31), t_32))))
        else ()
       done
      done;
      (match (! t_15) with
       | Some (i_16) ->
          if ((snd (fst i_16)) <> t_14) then begin
           let a_23 = t_4.arr
           and nm_24 = (t_4.n * t_4.m)
           and m_25 = t_4.m in
           let rec loop_26 =
            fun i1_27 ->
             fun i2_28 ->
              if (i2_28 < nm_24) then
               let t_29 = a_23.(i1_27) in
               a_23.(i1_27) <- a_23.(i2_28);
               a_23.(i2_28) <- t_29;
               (loop_26 (i1_27 + m_25) (i2_28 + m_25))
              else () in
           (loop_26 t_14 (snd (fst i_16)));
           (t_8 := (~- (! t_8)))
          end else ();
          if ((fst (fst i_16)) <> t_13) then begin
           let a_17 = t_4.arr
           and m_18 = t_4.m in
           let i1_19 = (t_13 * m_18)
           and i2_20 = ((snd (fst i_16)) * m_18) in
           for i_21 = t_14 to (m_18 - 1) do
            let t_22 = a_17.(i1_19 + i_21) in
            a_17.(i1_19 + i_21) <- a_17.(i2_20 + i_21);
            a_17.(i2_20 + i_21) <- t_22
           done;
           (t_8 := (~- (! t_8)))
          end else ();
          (Some (snd i_16))
       | None -> (None))
     end in
    (match t_34 with
     | Some (i_35) ->
        begin
         for j_36 = (t_13 + 1) to (t_6 - 1) do
          let t_37 = (t_4.arr).((j_36 * t_4.m) + t_14) in
          if (t_37 <> 0) then begin
           for j_38 = (t_14 + 1) to (t_5 - 1) do
            (t_4.arr).((j_36 * t_4.m) + j_38) <-
             ((((t_4.arr).((j_36 * t_4.m) + j_38) * i_35) -
                ((t_4.arr).((t_13 * t_4.m) + j_38) * t_37)) / (! t_7))
           done;
           (t_4.arr).((j_36 * t_4.m) + t_14) <- 0
          end else ()
         done;
         (t_7 := i_35)
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_8 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_4,
    if ((! t_8) = 0) then 0
    else if ((! t_8) = 1) then (! t_7)
    else (~- (! t_7)), (! t_2))>.
val resIV6 : ('a, GVC_I.contr -> GenIV6.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_4 = {arr = (Array.copy a_1.arr)} (a_1) in
   let t_5 = a_1.m in
   let t_6 = a_1.n in
   let t_7 = (ref 1) in
   let t_8 = (ref 1) in
   let t_9 = (ref ([])) in
   while (((! t_3) < t_5) && ((! t_2) < t_6)) do
    let t_14 = (! t_2) in
    let t_15 = (! t_3) in
    let t_16 = (ref (None)) in
    let t_35 =
     begin
      for j_31 = t_14 to (t_6 - 1) do
       for j_32 = t_15 to (t_5 - 1) do
        let t_33 = (t_4.arr).((j_31 * t_4.m) + j_32) in
        if (t_33 <> 0) then
         (match (! t_16) with
          | Some (i_34) ->
             if ((abs (snd i_34)) > (abs t_33)) then
              (t_16 := (Some ((j_31, j_32), t_33)))
             else ()
          | None -> (t_16 := (Some ((j_31, j_32), t_33))))
        else ()
       done
      done;
      (match (! t_16) with
       | Some (i_17) ->
          if ((snd (fst i_17)) <> t_15) then begin
           begin
            let a_24 = t_4.arr
            and nm_25 = (t_4.n * t_4.m)
            and m_26 = t_4.m in
            let rec loop_27 =
             fun i1_28 ->
              fun i2_29 ->
               if (i2_29 < nm_25) then
                let t_30 = a_24.(i1_28) in
                a_24.(i1_28) <- a_24.(i2_29);
                a_24.(i2_29) <- t_30;
                (loop_27 (i1_28 + m_26) (i2_29 + m_26))
               else () in
            (loop_27 t_15 (snd (fst i_17)));
            (t_8 := (~- (! t_8)))
           end;
           (t_9 := ((ColSwap ((snd (fst i_17)), t_14)) :: (! t_9)))
          end else ();
          if ((fst (fst i_17)) <> t_14) then begin
           begin
            let a_18 = t_4.arr
            and m_19 = t_4.m in
            let i1_20 = (t_14 * m_19)
            and i2_21 = ((snd (fst i_17)) * m_19) in
            for i_22 = t_15 to (m_19 - 1) do
             let t_23 = a_18.(i1_20 + i_22) in
             a_18.(i1_20 + i_22) <- a_18.(i2_21 + i_22);
             a_18.(i2_21 + i_22) <- t_23
            done;
            (t_8 := (~- (! t_8)))
           end;
           (t_9 := ((RowSwap ((fst (fst i_17)), t_14)) :: (! t_9)))
          end else ();
          (Some (snd i_17))
       | None -> (None))
     end in
    (match t_35 with
     | Some (i_36) ->
        begin
         for j_37 = (t_14 + 1) to (t_6 - 1) do
          let t_38 = (t_4.arr).((j_37 * t_4.m) + t_15) in
          if (t_38 <> 0) then begin
           for j_39 = (t_15 + 1) to (t_5 - 1) do
            (t_4.arr).((j_37 * t_4.m) + j_39) <-
             ((((t_4.arr).((j_37 * t_4.m) + j_39) * i_36) -
                ((t_4.arr).((t_14 * t_4.m) + j_39) * t_38)) / (! t_7))
           done;
           (t_4.arr).((j_37 * t_4.m) + t_15) <- 0
          end else ()
         done;
         (t_7 := i_36)
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_8 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_4,
    if ((! t_8) = 0) then 0
    else if ((! t_8) = 1) then (! t_7)
    else (~- (! t_7)), (! t_2), (! t_9))>.
val resFA11 : ('a, GAC_F.contr -> GenFA11.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_10 = (! t_2) in
    let t_11 = (! t_3) in
    let t_12 = (ref (None)) in
    let t_21 =
     begin
      for j_17 = t_10 to (t_7 - 1) do
       for j_18 = t_11 to (t_6 - 1) do
        let t_19 = (t_5.(j_17)).(j_18) in
        if (t_19 <> 0.) then
         (match (! t_12) with
          | Some (i_20) ->
             if ((abs_float (snd i_20)) < (abs_float t_19)) then
              (t_12 := (Some ((j_17, j_18), t_19)))
             else ()
          | None -> (t_12 := (Some ((j_17, j_18), t_19))))
        else ()
       done
      done;
      (match (! t_12) with
       | Some (i_13) ->
          if ((snd (fst i_13)) <> t_11) then
           for r_15 = 0 to ((Array.length t_5) - 1) do
            let t_16 = (t_5.(r_15)).(t_11) in
            (t_5.(r_15)).(t_11) <- (t_5.(r_15)).(snd (fst i_13));
            (t_5.(r_15)).(snd (fst i_13)) <- t_16
           done
          else ();
          if ((fst (fst i_13)) <> t_10) then
           let t_14 = t_5.(t_10) in
           t_5.(t_10) <- t_5.(snd (fst i_13));
           t_5.(snd (fst i_13)) <- t_14
          else ();
          (Some (snd i_13))
       | None -> (None))
     end in
    (match t_21 with
     | Some (i_22) ->
        begin
         for j_23 = (t_10 + 1) to (t_7 - 1) do
          let t_24 = (t_5.(j_23)).(t_11) in
          if (t_24 <> 0.) then begin
           for j_25 = (t_11 + 1) to (t_6 - 1) do
            (t_5.(j_23)).(j_25) <-
             ((t_5.(j_23)).(j_25) -. ((t_24 /. i_22) *. (t_5.(t_10)).(j_25)))
           done;
           (t_5.(j_23)).(t_11) <- 0.
          end else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   t_5>.
val resFA12 : ('a, GAC_F.contr -> GenFA12.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref 1.) in
   let t_9 = (ref 1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_12 = (! t_2) in
    let t_13 = (! t_3) in
    let t_14 = (ref (None)) in
    let t_23 =
     begin
      for j_19 = t_12 to (t_7 - 1) do
       for j_20 = t_13 to (t_6 - 1) do
        let t_21 = (t_5.(j_19)).(j_20) in
        if (t_21 <> 0.) then
         (match (! t_14) with
          | Some (i_22) ->
             if ((abs_float (snd i_22)) < (abs_float t_21)) then
              (t_14 := (Some ((j_19, j_20), t_21)))
             else ()
          | None -> (t_14 := (Some ((j_19, j_20), t_21))))
        else ()
       done
      done;
      (match (! t_14) with
       | Some (i_15) ->
          if ((snd (fst i_15)) <> t_13) then begin
           for r_17 = 0 to ((Array.length t_5) - 1) do
            let t_18 = (t_5.(r_17)).(t_13) in
            (t_5.(r_17)).(t_13) <- (t_5.(r_17)).(snd (fst i_15));
            (t_5.(r_17)).(snd (fst i_15)) <- t_18
           done;
           (t_9 := (~- (! t_9)))
          end else ();
          if ((fst (fst i_15)) <> t_12) then begin
           let t_16 = t_5.(t_12) in
           t_5.(t_12) <- t_5.(snd (fst i_15));
           t_5.(snd (fst i_15)) <- t_16;
           (t_9 := (~- (! t_9)))
          end else ();
          (Some (snd i_15))
       | None -> (None))
     end in
    (match t_23 with
     | Some (i_24) ->
        begin
         for j_25 = (t_12 + 1) to (t_7 - 1) do
          let t_26 = (t_5.(j_25)).(t_13) in
          if (t_26 <> 0.) then begin
           for j_27 = (t_13 + 1) to (t_6 - 1) do
            (t_5.(j_25)).(j_27) <-
             ((t_5.(j_25)).(j_27) -. ((t_26 /. i_24) *. (t_5.(t_12)).(j_27)))
           done;
           (t_5.(j_25)).(t_13) <- 0.
          end else ()
         done;
         (t_8 := ((! t_8) *. i_24))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_9 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_5,
    if ((! t_9) = 0) then 0.
    else if ((! t_9) = 1) then (! t_8)
    else (~-. (! t_8)))>.
val resFA13 : ('a, GAC_F.contr -> GenFA13.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_10 = (! t_2) in
    let t_11 = (! t_3) in
    let t_12 = (ref (None)) in
    let t_21 =
     begin
      for j_17 = t_10 to (t_7 - 1) do
       for j_18 = t_11 to (t_6 - 1) do
        let t_19 = (t_5.(j_17)).(j_18) in
        if (t_19 <> 0.) then
         (match (! t_12) with
          | Some (i_20) ->
             if ((abs_float (snd i_20)) < (abs_float t_19)) then
              (t_12 := (Some ((j_17, j_18), t_19)))
             else ()
          | None -> (t_12 := (Some ((j_17, j_18), t_19))))
        else ()
       done
      done;
      (match (! t_12) with
       | Some (i_13) ->
          if ((snd (fst i_13)) <> t_11) then
           for r_15 = 0 to ((Array.length t_5) - 1) do
            let t_16 = (t_5.(r_15)).(t_11) in
            (t_5.(r_15)).(t_11) <- (t_5.(r_15)).(snd (fst i_13));
            (t_5.(r_15)).(snd (fst i_13)) <- t_16
           done
          else ();
          if ((fst (fst i_13)) <> t_10) then
           let t_14 = t_5.(t_10) in
           t_5.(t_10) <- t_5.(snd (fst i_13));
           t_5.(snd (fst i_13)) <- t_14
          else ();
          (Some (snd i_13))
       | None -> (None))
     end in
    (match t_21 with
     | Some (i_22) ->
        begin
         for j_23 = (t_10 + 1) to (t_7 - 1) do
          let t_24 = (t_5.(j_23)).(t_11) in
          if (t_24 <> 0.) then begin
           for j_25 = (t_11 + 1) to (t_6 - 1) do
            (t_5.(j_23)).(j_25) <-
             ((t_5.(j_23)).(j_25) -. ((t_24 /. i_22) *. (t_5.(t_10)).(j_25)))
           done;
           (t_5.(j_23)).(t_11) <- 0.
          end else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   (t_5, (! t_2))>.
val resFA14 : ('a, GAC_F.contr -> GenFA14.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref 1.) in
   let t_9 = (ref 1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_12 = (! t_2) in
    let t_13 = (! t_3) in
    let t_14 = (ref (None)) in
    let t_23 =
     begin
      for j_19 = t_12 to (t_7 - 1) do
       for j_20 = t_13 to (t_6 - 1) do
        let t_21 = (t_5.(j_19)).(j_20) in
        if (t_21 <> 0.) then
         (match (! t_14) with
          | Some (i_22) ->
             if ((abs_float (snd i_22)) < (abs_float t_21)) then
              (t_14 := (Some ((j_19, j_20), t_21)))
             else ()
          | None -> (t_14 := (Some ((j_19, j_20), t_21))))
        else ()
       done
      done;
      (match (! t_14) with
       | Some (i_15) ->
          if ((snd (fst i_15)) <> t_13) then begin
           for r_17 = 0 to ((Array.length t_5) - 1) do
            let t_18 = (t_5.(r_17)).(t_13) in
            (t_5.(r_17)).(t_13) <- (t_5.(r_17)).(snd (fst i_15));
            (t_5.(r_17)).(snd (fst i_15)) <- t_18
           done;
           (t_9 := (~- (! t_9)))
          end else ();
          if ((fst (fst i_15)) <> t_12) then begin
           let t_16 = t_5.(t_12) in
           t_5.(t_12) <- t_5.(snd (fst i_15));
           t_5.(snd (fst i_15)) <- t_16;
           (t_9 := (~- (! t_9)))
          end else ();
          (Some (snd i_15))
       | None -> (None))
     end in
    (match t_23 with
     | Some (i_24) ->
        begin
         for j_25 = (t_12 + 1) to (t_7 - 1) do
          let t_26 = (t_5.(j_25)).(t_13) in
          if (t_26 <> 0.) then begin
           for j_27 = (t_13 + 1) to (t_6 - 1) do
            (t_5.(j_25)).(j_27) <-
             ((t_5.(j_25)).(j_27) -. ((t_26 /. i_24) *. (t_5.(t_12)).(j_27)))
           done;
           (t_5.(j_25)).(t_13) <- 0.
          end else ()
         done;
         (t_8 := ((! t_8) *. i_24))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_9 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_5,
    if ((! t_9) = 0) then 0.
    else if ((! t_9) = 1) then (! t_8)
    else (~-. (! t_8)), (! t_2))>.
val resFA24 : ('a, GAC_F.contr -> GenFA24.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref 1.) in
   let t_9 = (ref 1) in
   let t_10 = (ref ([])) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_13 = (! t_2) in
    let t_14 = (! t_3) in
    let t_15 = (ref (None)) in
    let t_21 =
     begin
      for j_18 = t_13 to (t_7 - 1) do
       let t_19 = (t_5.(j_18)).(t_14) in
       if (t_19 <> 0.) then
        (match (! t_15) with
         | Some (i_20) ->
            if ((abs_float (snd i_20)) < (abs_float t_19)) then
             (t_15 := (Some (j_18, t_19)))
            else ()
         | None -> (t_15 := (Some (j_18, t_19))))
       else ()
      done;
      (match (! t_15) with
       | Some (i_16) ->
          if ((fst i_16) <> t_13) then begin
           begin
            let t_17 = t_5.(t_13) in
            t_5.(t_13) <- t_5.(fst i_16);
            t_5.(fst i_16) <- t_17;
            (t_9 := (~- (! t_9)))
           end;
           (t_10 := ((RowSwap ((fst i_16), t_13)) :: (! t_10)))
          end else ();
          (Some (snd i_16))
       | None -> (None))
     end in
    (match t_21 with
     | Some (i_22) ->
        begin
         for j_23 = (t_13 + 1) to (t_7 - 1) do
          let t_24 = (t_5.(j_23)).(t_14) in
          if (t_24 <> 0.) then begin
           for j_25 = (t_14 + 1) to (t_6 - 1) do
            (t_5.(j_23)).(j_25) <-
             ((t_5.(j_23)).(j_25) -. ((t_24 /. i_22) *. (t_5.(t_13)).(j_25)))
           done;
           (t_5.(j_23)).(t_14) <- 0.
          end else ()
         done;
         (t_8 := ((! t_8) *. i_22))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_9 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_5,
    if ((! t_9) = 0) then 0.
    else if ((! t_9) = 1) then (! t_8)
    else (~-. (! t_8)), (! t_2), (! t_10))>.
val resFA25 : ('a, GAC_F.contr -> GenFA25.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref 1.) in
   let t_9 = (ref 1) in
   let t_11 = (ref (Array.init t_7 (fun i_10 -> i_10))) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_14 = (! t_2) in
    let t_15 = (! t_3) in
    let t_16 = (ref (None)) in
    let t_26 =
     begin
      for j_23 = t_14 to (t_7 - 1) do
       let t_24 = (t_5.(j_23)).(t_15) in
       if (t_24 <> 0.) then
        (match (! t_16) with
         | Some (i_25) ->
            if ((abs_float (snd i_25)) < (abs_float t_24)) then
             (t_16 := (Some (j_23, t_24)))
            else ()
         | None -> (t_16 := (Some (j_23, t_24))))
       else ()
      done;
      (match (! t_16) with
       | Some (i_17) ->
          if ((fst i_17) <> t_14) then begin
           begin
            let t_18 = t_5.(t_14) in
            t_5.(t_14) <- t_5.(fst i_17);
            t_5.(fst i_17) <- t_18;
            (t_9 := (~- (! t_9)))
           end;
           (t_11 :=
             let (x_19, y_20) = ((fst i_17), t_14) in
             let b_21 = (! t_11)
             and t_22 = (! t_11).(x_19) in
             b_21.(x_19) <- b_21.(y_20);
             b_21.(y_20) <- t_22;
             b_21)
          end else ();
          (Some (snd i_17))
       | None -> (None))
     end in
    (match t_26 with
     | Some (i_27) ->
        begin
         for j_28 = (t_14 + 1) to (t_7 - 1) do
          let t_29 = (t_5.(j_28)).(t_15) in
          if (t_29 <> 0.) then begin
           for j_30 = (t_15 + 1) to (t_6 - 1) do
            (t_5.(j_28)).(j_30) <-
             ((t_5.(j_28)).(j_30) -. ((t_29 /. i_27) *. (t_5.(t_14)).(j_30)))
           done;
           (t_5.(j_28)).(t_15) <- 0.
          end else ()
         done;
         (t_8 := ((! t_8) *. i_27))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_9 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_5,
    if ((! t_9) = 0) then 0.
    else if ((! t_9) = 1) then (! t_8)
    else (~-. (! t_8)), (! t_2), (! t_11))>.
val resFA26 : ('a, GAC_F.contr -> GenFA26.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_10 = (! t_2) in
    let t_11 = (! t_3) in
    let t_12 = (ref (None)) in
    let t_18 =
     begin
      for j_15 = t_10 to (t_7 - 1) do
       let t_16 = (t_5.(j_15)).(t_11) in
       if (t_16 <> 0.) then
        (match (! t_12) with
         | Some (i_17) ->
            if ((abs_float (snd i_17)) < (abs_float t_16)) then
             (t_12 := (Some (j_15, t_16)))
            else ()
         | None -> (t_12 := (Some (j_15, t_16))))
       else ()
      done;
      (match (! t_12) with
       | Some (i_13) ->
          if ((fst i_13) <> t_10) then
           let t_14 = t_5.(t_10) in
           t_5.(t_10) <- t_5.(fst i_13);
           t_5.(fst i_13) <- t_14
          else ();
          (Some (snd i_13))
       | None -> (None))
     end in
    (match t_18 with
     | Some (i_19) ->
        begin
         for j_20 = (t_10 + 1) to (t_7 - 1) do
          let t_21 = (t_5.(j_20)).(t_11) in
          if (t_21 <> 0.) then begin
           for j_22 = (t_11 + 1) to (t_6 - 1) do
            (t_5.(j_20)).(j_22) <-
             ((t_5.(j_20)).(j_22) -. ((t_21 /. i_19) *. (t_5.(t_10)).(j_22)))
           done;
           (t_5.(j_20)).(t_11) <- 0.
          end else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   t_5>.
val resRA1 : ('a, GAC_R.contr -> GenRA1.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_10 = (! t_2) in
    let t_11 = (! t_3) in
    let t_12 = (ref (None)) in
    let t_19 =
     begin
      let t_15 = (t_5.(t_10)).(t_11) in
      if (t_15 <> (* cross-stage persistent value (as id: zero) *)) then
       (t_12 := (Some (t_10, t_15)))
      else
       let rec loop_16 =
        fun j_17 ->
         if (j_17 < t_7) then
          let t_18 = (t_5.(j_17)).(t_11) in
          if (t_18 = (* cross-stage persistent value (as id: zero) *)) then
           (loop_16 (j_17 + 1))
          else (t_12 := (Some (j_17, t_18)))
         else () in
       (loop_16 (t_10 + 1));
      (match (! t_12) with
       | Some (i_13) ->
          if ((fst i_13) <> t_10) then
           let t_14 = t_5.(t_10) in
           t_5.(t_10) <- t_5.(fst i_13);
           t_5.(fst i_13) <- t_14
          else ();
          (Some (snd i_13))
       | None -> (None))
     end in
    (match t_19 with
     | Some (i_20) ->
        begin
         for j_21 = (t_10 + 1) to (t_7 - 1) do
          let t_22 = (t_5.(j_21)).(t_11) in
          if (t_22 <> (* cross-stage persistent value (as id: zero) *)) then begin
           for j_23 = (t_11 + 1) to (t_6 - 1) do
            (t_5.(j_21)).(j_23) <-
             (((* cross-stage persistent value (as id: Num.sub_num) *))
               (t_5.(j_21)).(j_23)
               (((* cross-stage persistent value (as id: Num.mult_num) *))
                 (((* cross-stage persistent value (as id: Num.div_num) *))
                   t_22 i_20) (t_5.(t_10)).(j_23)))
           done;
           (t_5.(j_21)).(t_11) <-
            (* cross-stage persistent value (as id: zero) *)
          end else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   t_5>.
val resRA2 : ('a, GAC_R.contr -> GenRA2.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref (* cross-stage persistent value (as id: one) *)) in
   let t_9 = (ref 1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_12 = (! t_2) in
    let t_13 = (! t_3) in
    let t_14 = (ref (None)) in
    let t_21 =
     begin
      let t_17 = (t_5.(t_12)).(t_13) in
      if (t_17 <> (* cross-stage persistent value (as id: zero) *)) then
       (t_14 := (Some (t_12, t_17)))
      else
       let rec loop_18 =
        fun j_19 ->
         if (j_19 < t_7) then
          let t_20 = (t_5.(j_19)).(t_13) in
          if (t_20 = (* cross-stage persistent value (as id: zero) *)) then
           (loop_18 (j_19 + 1))
          else (t_14 := (Some (j_19, t_20)))
         else () in
       (loop_18 (t_12 + 1));
      (match (! t_14) with
       | Some (i_15) ->
          if ((fst i_15) <> t_12) then begin
           let t_16 = t_5.(t_12) in
           t_5.(t_12) <- t_5.(fst i_15);
           t_5.(fst i_15) <- t_16;
           (t_9 := (~- (! t_9)))
          end else ();
          (Some (snd i_15))
       | None -> (None))
     end in
    (match t_21 with
     | Some (i_22) ->
        begin
         for j_23 = (t_12 + 1) to (t_7 - 1) do
          let t_24 = (t_5.(j_23)).(t_13) in
          if (t_24 <> (* cross-stage persistent value (as id: zero) *)) then begin
           for j_25 = (t_13 + 1) to (t_6 - 1) do
            (t_5.(j_23)).(j_25) <-
             (((* cross-stage persistent value (as id: Num.sub_num) *))
               (t_5.(j_23)).(j_25)
               (((* cross-stage persistent value (as id: Num.mult_num) *))
                 (((* cross-stage persistent value (as id: Num.div_num) *))
                   t_24 i_22) (t_5.(t_12)).(j_25)))
           done;
           (t_5.(j_23)).(t_13) <-
            (* cross-stage persistent value (as id: zero) *)
          end else ()
         done;
         (t_8 :=
           (((* cross-stage persistent value (as id: Num.mult_num) *))
             (! t_8) i_22))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_9 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_5,
    if ((! t_9) = 0) then (* cross-stage persistent value (as id: zero) *)
    else if ((! t_9) = 1) then (! t_8)
    else
     (((* cross-stage persistent value (as id: Num.minus_num) *)) (! t_8)))>.
val resRA3 : ('a, GAC_R.contr -> GenRA3.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_10 = (! t_2) in
    let t_11 = (! t_3) in
    let t_12 = (ref (None)) in
    let t_19 =
     begin
      let t_15 = (t_5.(t_10)).(t_11) in
      if (t_15 <> (* cross-stage persistent value (as id: zero) *)) then
       (t_12 := (Some (t_10, t_15)))
      else
       let rec loop_16 =
        fun j_17 ->
         if (j_17 < t_7) then
          let t_18 = (t_5.(j_17)).(t_11) in
          if (t_18 = (* cross-stage persistent value (as id: zero) *)) then
           (loop_16 (j_17 + 1))
          else (t_12 := (Some (j_17, t_18)))
         else () in
       (loop_16 (t_10 + 1));
      (match (! t_12) with
       | Some (i_13) ->
          if ((fst i_13) <> t_10) then
           let t_14 = t_5.(t_10) in
           t_5.(t_10) <- t_5.(fst i_13);
           t_5.(fst i_13) <- t_14
          else ();
          (Some (snd i_13))
       | None -> (None))
     end in
    (match t_19 with
     | Some (i_20) ->
        begin
         for j_21 = (t_10 + 1) to (t_7 - 1) do
          let t_22 = (t_5.(j_21)).(t_11) in
          if (t_22 <> (* cross-stage persistent value (as id: zero) *)) then begin
           for j_23 = (t_11 + 1) to (t_6 - 1) do
            (t_5.(j_21)).(j_23) <-
             (((* cross-stage persistent value (as id: Num.sub_num) *))
               (t_5.(j_21)).(j_23)
               (((* cross-stage persistent value (as id: Num.mult_num) *))
                 (((* cross-stage persistent value (as id: Num.div_num) *))
                   t_22 i_20) (t_5.(t_10)).(j_23)))
           done;
           (t_5.(j_21)).(t_11) <-
            (* cross-stage persistent value (as id: zero) *)
          end else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   (t_5, (! t_2))>.
val resRA4 : ('a, GAC_R.contr -> GenRA4.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref (* cross-stage persistent value (as id: one) *)) in
   let t_9 = (ref 1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_12 = (! t_2) in
    let t_13 = (! t_3) in
    let t_14 = (ref (None)) in
    let t_21 =
     begin
      let t_17 = (t_5.(t_12)).(t_13) in
      if (t_17 <> (* cross-stage persistent value (as id: zero) *)) then
       (t_14 := (Some (t_12, t_17)))
      else
       let rec loop_18 =
        fun j_19 ->
         if (j_19 < t_7) then
          let t_20 = (t_5.(j_19)).(t_13) in
          if (t_20 = (* cross-stage persistent value (as id: zero) *)) then
           (loop_18 (j_19 + 1))
          else (t_14 := (Some (j_19, t_20)))
         else () in
       (loop_18 (t_12 + 1));
      (match (! t_14) with
       | Some (i_15) ->
          if ((fst i_15) <> t_12) then begin
           let t_16 = t_5.(t_12) in
           t_5.(t_12) <- t_5.(fst i_15);
           t_5.(fst i_15) <- t_16;
           (t_9 := (~- (! t_9)))
          end else ();
          (Some (snd i_15))
       | None -> (None))
     end in
    (match t_21 with
     | Some (i_22) ->
        begin
         for j_23 = (t_12 + 1) to (t_7 - 1) do
          let t_24 = (t_5.(j_23)).(t_13) in
          if (t_24 <> (* cross-stage persistent value (as id: zero) *)) then begin
           for j_25 = (t_13 + 1) to (t_6 - 1) do
            (t_5.(j_23)).(j_25) <-
             (((* cross-stage persistent value (as id: Num.sub_num) *))
               (t_5.(j_23)).(j_25)
               (((* cross-stage persistent value (as id: Num.mult_num) *))
                 (((* cross-stage persistent value (as id: Num.div_num) *))
                   t_24 i_22) (t_5.(t_12)).(j_25)))
           done;
           (t_5.(j_23)).(t_13) <-
            (* cross-stage persistent value (as id: zero) *)
          end else ()
         done;
         (t_8 :=
           (((* cross-stage persistent value (as id: Num.mult_num) *))
             (! t_8) i_22))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_9 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_5,
    if ((! t_9) = 0) then (* cross-stage persistent value (as id: zero) *)
    else if ((! t_9) = 1) then (! t_8)
    else
     (((* cross-stage persistent value (as id: Num.minus_num) *)) (! t_8)),
    (! t_2))>.
val resFA5 : ('a, GAC_F.contr * int -> GenFA5.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy (fst a_1))) in
   let t_6 = (Array.length (fst a_1).(0)) in
   let t_7 = (snd a_1) in
   let t_8 = (Array.length (fst a_1)) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_11 = (! t_2) in
    let t_12 = (! t_3) in
    let t_13 = (ref (None)) in
    let t_19 =
     begin
      for j_16 = t_11 to (t_8 - 1) do
       let t_17 = (t_5.(j_16)).(t_12) in
       if (t_17 <> 0.) then
        (match (! t_13) with
         | Some (i_18) ->
            if ((abs_float (snd i_18)) < (abs_float t_17)) then
             (t_13 := (Some (j_16, t_17)))
            else ()
         | None -> (t_13 := (Some (j_16, t_17))))
       else ()
      done;
      (match (! t_13) with
       | Some (i_14) ->
          if ((fst i_14) <> t_11) then
           let t_15 = t_5.(t_11) in
           t_5.(t_11) <- t_5.(fst i_14);
           t_5.(fst i_14) <- t_15
          else ();
          (Some (snd i_14))
       | None -> (None))
     end in
    (match t_19 with
     | Some (i_20) ->
        begin
         for j_21 = (t_11 + 1) to (t_8 - 1) do
          let t_22 = (t_5.(j_21)).(t_12) in
          if (t_22 <> 0.) then begin
           for j_23 = (t_12 + 1) to (t_6 - 1) do
            (t_5.(j_21)).(j_23) <-
             ((t_5.(j_21)).(j_23) -. ((t_22 /. i_20) *. (t_5.(t_11)).(j_23)))
           done;
           (t_5.(j_21)).(t_12) <- 0.
          end else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   t_5>.
val resFA6 : ('a, GAC_F.contr * int -> GenFA6.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy (fst a_1))) in
   let t_6 = (Array.length (fst a_1).(0)) in
   let t_7 = (snd a_1) in
   let t_8 = (Array.length (fst a_1)) in
   let t_9 = (ref 1.) in
   let t_10 = (ref 1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_13 = (! t_2) in
    let t_14 = (! t_3) in
    let t_15 = (ref (None)) in
    let t_21 =
     begin
      for j_18 = t_13 to (t_8 - 1) do
       let t_19 = (t_5.(j_18)).(t_14) in
       if (t_19 <> 0.) then
        (match (! t_15) with
         | Some (i_20) ->
            if ((abs_float (snd i_20)) < (abs_float t_19)) then
             (t_15 := (Some (j_18, t_19)))
            else ()
         | None -> (t_15 := (Some (j_18, t_19))))
       else ()
      done;
      (match (! t_15) with
       | Some (i_16) ->
          if ((fst i_16) <> t_13) then begin
           let t_17 = t_5.(t_13) in
           t_5.(t_13) <- t_5.(fst i_16);
           t_5.(fst i_16) <- t_17;
           (t_10 := (~- (! t_10)))
          end else ();
          (Some (snd i_16))
       | None -> (None))
     end in
    (match t_21 with
     | Some (i_22) ->
        begin
         for j_23 = (t_13 + 1) to (t_8 - 1) do
          let t_24 = (t_5.(j_23)).(t_14) in
          if (t_24 <> 0.) then begin
           for j_25 = (t_14 + 1) to (t_6 - 1) do
            (t_5.(j_23)).(j_25) <-
             ((t_5.(j_23)).(j_25) -. ((t_24 /. i_22) *. (t_5.(t_13)).(j_25)))
           done;
           (t_5.(j_23)).(t_14) <- 0.
          end else ()
         done;
         (t_9 := ((! t_9) *. i_22))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_10 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_5,
    if ((! t_10) = 0) then 0.
    else if ((! t_10) = 1) then (! t_9)
    else (~-. (! t_9)))>.
val resFA7 : ('a, GAC_F.contr * int -> GenFA7.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy (fst a_1))) in
   let t_6 = (Array.length (fst a_1).(0)) in
   let t_7 = (snd a_1) in
   let t_8 = (Array.length (fst a_1)) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_11 = (! t_2) in
    let t_12 = (! t_3) in
    let t_13 = (ref (None)) in
    let t_19 =
     begin
      for j_16 = t_11 to (t_8 - 1) do
       let t_17 = (t_5.(j_16)).(t_12) in
       if (t_17 <> 0.) then
        (match (! t_13) with
         | Some (i_18) ->
            if ((abs_float (snd i_18)) < (abs_float t_17)) then
             (t_13 := (Some (j_16, t_17)))
            else ()
         | None -> (t_13 := (Some (j_16, t_17))))
       else ()
      done;
      (match (! t_13) with
       | Some (i_14) ->
          if ((fst i_14) <> t_11) then
           let t_15 = t_5.(t_11) in
           t_5.(t_11) <- t_5.(fst i_14);
           t_5.(fst i_14) <- t_15
          else ();
          (Some (snd i_14))
       | None -> (None))
     end in
    (match t_19 with
     | Some (i_20) ->
        begin
         for j_21 = (t_11 + 1) to (t_8 - 1) do
          let t_22 = (t_5.(j_21)).(t_12) in
          if (t_22 <> 0.) then begin
           for j_23 = (t_12 + 1) to (t_6 - 1) do
            (t_5.(j_21)).(j_23) <-
             ((t_5.(j_21)).(j_23) -. ((t_22 /. i_20) *. (t_5.(t_11)).(j_23)))
           done;
           (t_5.(j_21)).(t_12) <- 0.
          end else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   (t_5, (! t_2))>.
val resFA8 : ('a, GAC_F.contr * int -> GenFA8.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy (fst a_1))) in
   let t_6 = (Array.length (fst a_1).(0)) in
   let t_7 = (snd a_1) in
   let t_8 = (Array.length (fst a_1)) in
   let t_9 = (ref 1.) in
   let t_10 = (ref 1) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_13 = (! t_2) in
    let t_14 = (! t_3) in
    let t_15 = (ref (None)) in
    let t_21 =
     begin
      for j_18 = t_13 to (t_8 - 1) do
       let t_19 = (t_5.(j_18)).(t_14) in
       if (t_19 <> 0.) then
        (match (! t_15) with
         | Some (i_20) ->
            if ((abs_float (snd i_20)) < (abs_float t_19)) then
             (t_15 := (Some (j_18, t_19)))
            else ()
         | None -> (t_15 := (Some (j_18, t_19))))
       else ()
      done;
      (match (! t_15) with
       | Some (i_16) ->
          if ((fst i_16) <> t_13) then begin
           let t_17 = t_5.(t_13) in
           t_5.(t_13) <- t_5.(fst i_16);
           t_5.(fst i_16) <- t_17;
           (t_10 := (~- (! t_10)))
          end else ();
          (Some (snd i_16))
       | None -> (None))
     end in
    (match t_21 with
     | Some (i_22) ->
        begin
         for j_23 = (t_13 + 1) to (t_8 - 1) do
          let t_24 = (t_5.(j_23)).(t_14) in
          if (t_24 <> 0.) then begin
           for j_25 = (t_14 + 1) to (t_6 - 1) do
            (t_5.(j_23)).(j_25) <-
             ((t_5.(j_23)).(j_25) -. ((t_24 /. i_22) *. (t_5.(t_13)).(j_25)))
           done;
           (t_5.(j_23)).(t_14) <- 0.
          end else ()
         done;
         (t_9 := ((! t_9) *. i_22))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_10 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_5,
    if ((! t_10) = 0) then 0.
    else if ((! t_10) = 1) then (! t_9)
    else (~-. (! t_9)), (! t_2))>.
val resFA9 : ('a, GAC_F.contr -> GenFA9.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref ([])) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_9 = (! t_2) in
    let t_10 = (! t_3) in
    let t_11 = (ref (None)) in
    let t_17 =
     begin
      for j_14 = t_9 to (t_7 - 1) do
       let t_15 = (t_5.(j_14)).(t_10) in
       if (t_15 <> 0.) then
        (match (! t_11) with
         | Some (i_16) ->
            if ((abs_float (snd i_16)) < (abs_float t_15)) then
             (t_11 := (Some (j_14, t_15)))
            else ()
         | None -> (t_11 := (Some (j_14, t_15))))
       else ()
      done;
      (match (! t_11) with
       | Some (i_12) ->
          if ((fst i_12) <> t_9) then begin
           let t_13 = t_5.(t_9) in
           t_5.(t_9) <- t_5.(fst i_12);
           t_5.(fst i_12) <- t_13;
           (t_8 := ((RowSwap ((fst i_12), t_9)) :: (! t_8)))
          end else ();
          (Some (snd i_12))
       | None -> (None))
     end in
    (match t_17 with
     | Some (i_18) ->
        begin
         for j_19 = (t_9 + 1) to (t_7 - 1) do
          let t_20 = (t_5.(j_19)).(t_10) in
          if (t_20 <> 0.) then
           for j_21 = (t_10 + 1) to (t_6 - 1) do
            (t_5.(j_19)).(j_21) <-
             ((t_5.(j_19)).(j_21) -. ((t_20 /. i_18) *. (t_5.(t_9)).(j_21)))
           done
          else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   (t_5, (! t_8))>.
val resFA31 : ('a, GAC_F.contr -> GenFA31.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref ([])) in
   let t_11 =
    (Array.init t_7
      (fun i_9 ->
        (Array.init t_6 (fun j_10 -> if (i_9 = j_10) then 1. else 0.)))) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_12 = (! t_2) in
    let t_13 = (! t_3) in
    let t_14 = (ref (None)) in
    let t_20 =
     begin
      for j_17 = t_12 to (t_7 - 1) do
       let t_18 = (t_5.(j_17)).(t_13) in
       if (t_18 <> 0.) then
        (match (! t_14) with
         | Some (i_19) ->
            if ((abs_float (snd i_19)) < (abs_float t_18)) then
             (t_14 := (Some (j_17, t_18)))
            else ()
         | None -> (t_14 := (Some (j_17, t_18))))
       else ()
      done;
      (match (! t_14) with
       | Some (i_15) ->
          if ((fst i_15) <> t_12) then begin
           let t_16 = t_5.(t_12) in
           t_5.(t_12) <- t_5.(fst i_15);
           t_5.(fst i_15) <- t_16;
           (t_8 := ((RowSwap ((fst i_15), t_12)) :: (! t_8)))
          end else ();
          (Some (snd i_15))
       | None -> (None))
     end in
    (match t_20 with
     | Some (i_21) ->
        begin
         for j_22 = (t_12 + 1) to (t_7 - 1) do
          let t_23 = (t_5.(j_22)).(t_13) in
          if (t_23 <> 0.) then begin
           for j_24 = (t_13 + 1) to (t_6 - 1) do
            (t_5.(j_22)).(j_24) <-
             ((t_5.(j_22)).(j_24) -. ((t_23 /. i_21) *. (t_5.(t_12)).(j_24)))
           done;
           (t_11.(j_22)).(t_13) <- (t_23 /. i_21);
           (t_5.(j_22)).(t_13) <- 0.
          end else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   (t_5, t_11, (! t_8))>.
val resFA32 : ('a, GAC_F.contr -> GenFA32.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
   let t_6 = (Array.length a_1.(0)) in
   let t_7 = (Array.length a_1) in
   let t_8 = (ref ([])) in
   while (((! t_3) < t_6) && ((! t_2) < t_7)) do
    let t_9 = (! t_2) in
    let t_10 = (! t_3) in
    let t_11 = (ref (None)) in
    let t_17 =
     begin
      for j_14 = t_9 to (t_7 - 1) do
       let t_15 = (t_5.(j_14)).(t_10) in
       if (t_15 <> 0.) then
        (match (! t_11) with
         | Some (i_16) ->
            if ((abs_float (snd i_16)) < (abs_float t_15)) then
             (t_11 := (Some (j_14, t_15)))
            else ()
         | None -> (t_11 := (Some (j_14, t_15))))
       else ()
      done;
      (match (! t_11) with
       | Some (i_12) ->
          if ((fst i_12) <> t_9) then begin
           let t_13 = t_5.(t_9) in
           t_5.(t_9) <- t_5.(fst i_12);
           t_5.(fst i_12) <- t_13;
           (t_8 := ((RowSwap ((fst i_12), t_9)) :: (! t_8)))
          end else ();
          (Some (snd i_12))
       | None -> (None))
     end in
    (match t_17 with
     | Some (i_18) ->
        begin
         for j_19 = (t_9 + 1) to (t_7 - 1) do
          let t_20 = (t_5.(j_19)).(t_10) in
          if (t_20 <> 0.) then
           for j_21 = (t_10 + 1) to (t_6 - 1) do
            (t_5.(j_19)).(j_21) <-
             ((t_5.(j_19)).(j_21) -. ((t_20 /. i_18) *. (t_5.(t_9)).(j_21)))
           done
          else ()
         done;
         ()
        end;
        (t_2 := ((! t_2) + 1))
     | None -> ());
    (t_3 := ((! t_3) + 1))
   done;
   (t_5, (! t_8))>.
val resZp3 : ('a, GVC_Z3.contr -> GenZp3.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_4 = {arr = (Array.copy a_1.arr)} (a_1) in
   let t_5 = a_1.m in
   let t_6 = a_1.n in
   let t_7 = (ref 1) in
   let t_8 = (ref 1) in
   let t_9 = (ref ([])) in
   while (((! t_3) < t_5) && ((! t_2) < t_6)) do
    let t_14 = (! t_2) in
    let t_15 = (! t_3) in
    let t_16 = (ref (None)) in
    let t_28 =
     begin
      let t_24 = (t_4.arr).((t_15 * t_4.m) + t_14) in
      if (t_24 <> 0) then (t_16 := (Some (t_14, t_24)))
      else
       let rec loop_25 =
        fun j_26 ->
         if (j_26 < t_6) then
          let t_27 = (t_4.arr).((j_26 * t_4.m) + t_15) in
          if (t_27 = 0) then (loop_25 (j_26 + 1))
          else (t_16 := (Some (j_26, t_27)))
         else () in
       (loop_25 (t_14 + 1));
      (match (! t_16) with
       | Some (i_17) ->
          if ((fst i_17) <> t_14) then begin
           begin
            let a_18 = t_4.arr
            and m_19 = t_4.m in
            let i1_20 = (t_14 * m_19)
            and i2_21 = ((fst i_17) * m_19) in
            for i_22 = t_15 to (m_19 - 1) do
             let t_23 = a_18.(i1_20 + i_22) in
             a_18.(i1_20 + i_22) <- a_18.(i2_21 + i_22);
             a_18.(i2_21 + i_22) <- t_23
            done;
            (t_8 := (~- (! t_8)))
           end;
           (t_9 := ((RowSwap ((fst i_17), t_14)) :: (! t_9)))
          end else ();
          (Some (snd i_17))
       | None -> (None))
     end in
    (match t_28 with
     | Some (i_29) ->
        begin
         for j_30 = (t_14 + 1) to (t_6 - 1) do
          let t_31 = (t_4.arr).((j_30 * t_4.m) + t_15) in
          if (t_31 <> 0) then begin
           for j_32 = (t_15 + 1) to (t_5 - 1) do
            (t_4.arr).((j_30 * t_4.m) + j_32) <-
             (((* cross-stage persistent value (as id: minus) *))
               (t_4.arr).((j_30 * t_4.m) + j_32)
               (((* cross-stage persistent value (as id: times) *))
                 (((* cross-stage persistent value (as id: div) *)) t_31
                   i_29) (t_4.arr).((t_14 * t_4.m) + j_32)))
           done;
           (t_4.arr).((j_30 * t_4.m) + t_15) <- 0
          end else ()
         done;
         (t_7 :=
           (((* cross-stage persistent value (as id: times) *)) (! t_7) i_29))
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_8 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_4,
    if ((! t_8) = 0) then 0
    else if ((! t_8) = 1) then (! t_7)
    else (((* cross-stage persistent value (as id: uminus) *)) (! t_7)),
    (! t_2), (! t_9))>.
val resZp19 : ('a, GVC_Z19.contr -> GenZp19.O.res) code =
  .<fun a_1 ->
   let t_2 = (ref 0) in
   let t_3 = (ref 0) in
   let t_4 = {arr = (Array.copy a_1.arr)} (a_1) in
   let t_5 = a_1.m in
   let t_6 = a_1.n in
   let t_7 = (ref 1) in
   let t_8 = (ref 1) in
   let t_9 = (ref ([])) in
   while (((! t_3) < t_5) && ((! t_2) < t_6)) do
    let t_14 = (! t_2) in
    let t_15 = (! t_3) in
    let t_16 = (ref (None)) in
    let t_28 =
     begin
      let t_24 = (t_4.arr).((t_15 * t_4.m) + t_14) in
      if (t_24 <> 0) then (t_16 := (Some (t_14, t_24)))
      else
       let rec loop_25 =
        fun j_26 ->
         if (j_26 < t_6) then
          let t_27 = (t_4.arr).((j_26 * t_4.m) + t_15) in
          if (t_27 = 0) then (loop_25 (j_26 + 1))
          else (t_16 := (Some (j_26, t_27)))
         else () in
       (loop_25 (t_14 + 1));
      (match (! t_16) with
       | Some (i_17) ->
          if ((fst i_17) <> t_14) then begin
           begin
            let a_18 = t_4.arr
            and m_19 = t_4.m in
            let i1_20 = (t_14 * m_19)
            and i2_21 = ((fst i_17) * m_19) in
            for i_22 = t_15 to (m_19 - 1) do
             let t_23 = a_18.(i1_20 + i_22) in
             a_18.(i1_20 + i_22) <- a_18.(i2_21 + i_22);
             a_18.(i2_21 + i_22) <- t_23
            done;
            (t_8 := (~- (! t_8)))
           end;
           (t_9 := ((RowSwap ((fst i_17), t_14)) :: (! t_9)))
          end else ();
          (Some (snd i_17))
       | None -> (None))
     end in
    (match t_28 with
     | Some (i_29) ->
        begin
         for j_30 = (t_14 + 1) to (t_6 - 1) do
          let t_31 = (t_4.arr).((j_30 * t_4.m) + t_15) in
          if (t_31 <> 0) then begin
           for j_32 = (t_15 + 1) to (t_5 - 1) do
            (t_4.arr).((j_30 * t_4.m) + j_32) <-
             (((* cross-stage persistent value (as id: div) *))
               (((* cross-stage persistent value (as id: minus) *))
                 (((* cross-stage persistent value (as id: times) *))
                   (t_4.arr).((j_30 * t_4.m) + j_32) i_29)
                 (((* cross-stage persistent value (as id: times) *))
                   (t_4.arr).((t_14 * t_4.m) + j_32) t_31)) (! t_7))
           done;
           (t_4.arr).((j_30 * t_4.m) + t_15) <- 0
          end else ()
         done;
         (t_7 := i_29)
        end;
        (t_2 := ((! t_2) + 1))
     | None -> (t_8 := 0));
    (t_3 := ((! t_3) + 1))
   done;
   (t_4,
    if ((! t_8) = 0) then 0
    else if ((! t_8) = 1) then (! t_7)
    else (((* cross-stage persistent value (as id: uminus) *)) (! t_7)),
    (! t_2), (! t_9))>.
val rFA1 : GAC_F.contr -> GenFA1.O.res = <fun>
val rFA2 : float array array -> float array array * float = <fun>
val rFA3 : float array array -> float array array * int = <fun>
val rFA4 : float array array -> float array array * float * int = <fun>
val rFV1 :
  float Domains_code.container2dfromvector ->
  float Domains_code.container2dfromvector = <fun>
val rFV2 :
  float Domains_code.container2dfromvector ->
  float Domains_code.container2dfromvector * float = <fun>
val rFV3 :
  float Domains_code.container2dfromvector ->
  float Domains_code.container2dfromvector * int = <fun>
val rFV4 :
  float Domains_code.container2dfromvector ->
  float Domains_code.container2dfromvector * float * int = <fun>
val rFV5 :
  float Domains_code.container2dfromvector ->
  float Domains_code.container2dfromvector * float * int = <fun>
val rIA1 : int array array -> int array array = <fun>
val rIA2 : int array array -> int array array * int = <fun>
val rIA3 : int array array -> int array array * int = <fun>
val rIA4 : int array array -> int array array * int * int = <fun>
val rIV1 :
  int Domains_code.container2dfromvector ->
  int Domains_code.container2dfromvector = <fun>
val rIV2 :
  int Domains_code.container2dfromvector ->
  int Domains_code.container2dfromvector * int = <fun>
val rIV3 :
  int Domains_code.container2dfromvector ->
  int Domains_code.container2dfromvector * int = <fun>
val rIV4 :
  int Domains_code.container2dfromvector ->
  int Domains_code.container2dfromvector * int * int = <fun>
val rIV5 : GVC_I.contr -> GVC_I.contr * GVC_I.Dom.v * int = <fun>
val rIV6 : GVC_I.contr -> GVC_I.contr * GVC_I.Dom.v * int * Code.perm list =
  <fun>
val rFA11 : GAC_F.contr -> GAC_F.Dom.v array array = <fun>
val rFA12 : GAC_F.contr -> GAC_F.contr * GAC_F.Dom.v = <fun>
val rFA13 : GAC_F.contr -> GAC_F.contr * int = <fun>
val rFA14 : GAC_F.contr -> GAC_F.contr * GAC_F.Dom.v * int = <fun>
val rFA24 : GAC_F.contr -> GAC_F.contr * GAC_F.Dom.v * int * Code.perm list =
  <fun>
val rFA25 : GAC_F.contr -> GAC_F.contr * GAC_F.Dom.v * int * int array =
  <fun>
val rFA26 : GAC_F.contr -> GAC_F.Dom.v array array = <fun>
val rRA1 : GAC_R.contr -> GAC_R.Dom.v array array = <fun>
val rRA2 : GAC_R.contr -> GAC_R.contr * GAC_R.Dom.v = <fun>
val rRA3 : GAC_R.contr -> GAC_R.contr * int = <fun>
val rRA4 : GAC_R.contr -> GAC_R.contr * GAC_R.Dom.v * int = <fun>
val rFA5 : GAC_F.contr * int -> GAC_F.Dom.v array array = <fun>
val rFA6 : GAC_F.contr * int -> GAC_F.contr * GAC_F.Dom.v = <fun>
val rFA7 : GAC_F.contr * int -> GAC_F.contr * int = <fun>
val rFA8 : GAC_F.contr * int -> GAC_F.contr * GAC_F.Dom.v * int = <fun>
val rFA9 : GAC_F.contr -> GAC_F.contr * Code.perm list = <fun>
val rFA31 : GAC_F.contr -> GAC_F.contr * GAC_F.contr * Code.perm list = <fun>
val rFA32 : GAC_F.contr -> GAC_F.contr * Code.perm list = <fun>
val rZp3 : GVC_Z3.contr -> GVC_Z3.contr * GVC_Z3.Dom.v * int * Code.perm list =
  <fun>
val rZp19 :
  GVC_Z19.contr -> GVC_Z19.contr * GVC_Z19.Dom.v * int * Code.perm list =
  <fun>
val ia0 : int array array = [|[|1|]|]
val ia1 : int array array = [|[|1; 2; 3|]; [|4; 13; 5|]; [|-1; 3; 0|]|]
val ia2 : int array array =
  [|[|1; 2; 3; 0|]; [|4; 13; 5; 0|]; [|-1; 3; 0; 0|]|]
val ia3 : int array array =
  [|[|1; 2; 3|]; [|4; 13; 5|]; [|-1; 3; 0|]; [|0; 0; 0|]|]
val ia4 : int array array = [|[|0; 2; 3|]; [|0; 13; 5|]; [|0; 3; 0|]|]
val ia5 : int array array list =
  [[|[|1|]|]; [|[|1; 2; 3|]; [|4; 13; 5|]; [|-1; 3; 0|]|];
   [|[|1; 2; 3; 0|]; [|4; 13; 5; 0|]; [|-1; 3; 0; 0|]|];
   [|[|1; 2; 3|]; [|4; 13; 5|]; [|-1; 3; 0|]; [|0; 0; 0|]|];
   [|[|0; 2; 3|]; [|0; 13; 5|]; [|0; 3; 0|]|]]
val resI11 : int array array list =
  [[|[|1|]|]; [|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]|];
   [|[|1; 2; 3; 0|]; [|0; 5; -7; 0|]; [|0; 0; 50; 0|]|];
   [|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]; [|0; 0; 0|]|];
   [|[|0; 2; 3|]; [|0; 0; -9|]; [|0; 0; 0|]|]]
val resI12 : (int array array * int) list =
  [([|[|1|]|], 1); ([|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]|], 50);
   ([|[|1; 2; 3; 0|]; [|0; 5; -7; 0|]; [|0; 0; 50; 0|]|], 50);
   ([|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]; [|0; 0; 0|]|], 50);
   ([|[|0; 2; 3|]; [|0; 0; -9|]; [|0; 0; 0|]|], 0)]
val resI13 : (int array array * int) list =
  [([|[|1|]|], 1); ([|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]|], 3);
   ([|[|1; 2; 3; 0|]; [|0; 5; -7; 0|]; [|0; 0; 50; 0|]|], 3);
   ([|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]; [|0; 0; 0|]|], 3);
   ([|[|0; 2; 3|]; [|0; 0; -9|]; [|0; 0; 0|]|], 2)]
val resI14 : (int array array * int * int) list =
  [([|[|1|]|], 1, 1); ([|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]|], 50, 3);
   ([|[|1; 2; 3; 0|]; [|0; 5; -7; 0|]; [|0; 0; 50; 0|]|], 50, 3);
   ([|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]; [|0; 0; 0|]|], 50, 3);
   ([|[|0; 2; 3|]; [|0; 0; -9|]; [|0; 0; 0|]|], 0, 2)]
val iv0 : int Domains_code.container2dfromvector =
  {arr = [|1|]; n = 1; m = 1}
val iv1 : int Domains_code.container2dfromvector =
  {arr = [|1; 2; 3; 4; 13; 5; -1; 3; 0|]; n = 3; m = 3}
val iv2 : int Domains_code.container2dfromvector =
  {arr = [|1; 2; 3; 0; 4; 13; 5; 0; -1; 3; 0; 0|]; n = 3; m = 4}
val iv4 : int Domains_code.container2dfromvector =
  {arr = [|0; 2; 3; 0; 13; 5; 0; 3; 0|]; n = 3; m = 3}
val iv5 : int Domains_code.container2dfromvector list =
  [{arr = [|1|]; n = 1; m = 1};
   {arr = [|1; 2; 3; 4; 13; 5; -1; 3; 0|]; n = 3; m = 3};
   {arr = [|1; 2; 3; 0; 4; 13; 5; 0; -1; 3; 0; 0|]; n = 3; m = 4};
   {arr = [|0; 2; 3; 0; 13; 5; 0; 3; 0|]; n = 3; m = 3}]
val resI21 : int Domains_code.container2dfromvector list =
  [{arr = [|1|]; n = 1; m = 1};
   {arr = [|1; 2; 3; 0; 5; -7; 0; 0; 50|]; n = 3; m = 3};
   {arr = [|1; 2; 3; 0; 0; 5; -7; 0; 0; 0; 50; 0|]; n = 3; m = 4};
   {arr = [|0; 2; 3; 0; 0; -9; 0; 0; 0|]; n = 3; m = 3}]
val resI22 : (int Domains_code.container2dfromvector * int) list =
  [({arr = [|1|]; n = 1; m = 1}, 1);
   ({arr = [|1; 2; 3; 0; 5; -7; 0; 0; 50|]; n = 3; m = 3}, 50);
   ({arr = [|1; 2; 3; 0; 0; 5; -7; 0; 0; 0; 50; 0|]; n = 3; m = 4}, 50);
   ({arr = [|0; 2; 3; 0; 0; -9; 0; 0; 0|]; n = 3; m = 3}, 0)]
val resI23 : (int Domains_code.container2dfromvector * int) list =
  [({arr = [|1|]; n = 1; m = 1}, 1);
   ({arr = [|1; 2; 3; 0; 5; -7; 0; 0; 50|]; n = 3; m = 3}, 3);
   ({arr = [|1; 2; 3; 0; 0; 5; -7; 0; 0; 0; 50; 0|]; n = 3; m = 4}, 3);
   ({arr = [|0; 2; 3; 0; 0; -9; 0; 0; 0|]; n = 3; m = 3}, 2)]
val resI24 : (int Domains_code.container2dfromvector * int * int) list =
  [({arr = [|1|]; n = 1; m = 1}, 1, 1);
   ({arr = [|1; 2; 3; 0; 5; -7; 0; 0; 50|]; n = 3; m = 3}, 50, 3);
   ({arr = [|1; 2; 3; 0; 0; 5; -7; 0; 0; 0; 50; 0|]; n = 3; m = 4}, 50, 3);
   ({arr = [|0; 2; 3; 0; 0; -9; 0; 0; 0|]; n = 3; m = 3}, 0, 2)]
val resI25 : (GVC_I.contr * GVC_I.Dom.v * int) list =
  [({arr = [|1|]; n = 1; m = 1}, 1, 1);
   ({arr = [|1; 3; 2; 0; 3; 5; 0; 0; 50|]; n = 3; m = 3}, 50, 3);
   ({arr = [|1; 3; 2; 0; 0; 3; 5; 0; 0; 0; 50; 0|]; n = 3; m = 4}, 50, 3);
   ({arr = [|2; 3; 0; 0; -9; 0; 0; 0; 0|]; n = 3; m = 3}, 0, 2)]
val resI26 : (GVC_I.contr * GVC_I.Dom.v * int * Code.perm list) list =
  [({arr = [|1|]; n = 1; m = 1}, 1, 1, []);
   ({arr = [|1; 3; 2; 0; 3; 5; 0; 0; 50|]; n = 3; m = 3}, 50, 3,
    [Code.RowSwap (2, 1); Code.ColSwap (2, 1)]);
   ({arr = [|1; 3; 2; 0; 0; 3; 5; 0; 0; 0; 50; 0|]; n = 3; m = 4}, 50, 3,
    [Code.RowSwap (2, 1); Code.ColSwap (2, 1)]);
   ({arr = [|2; 3; 0; 0; -9; 0; 0; 0; 0|]; n = 3; m = 3}, 0, 2,
    [Code.RowSwap (2, 1); Code.ColSwap (2, 1); Code.ColSwap (1, 0)])]
val fa0 : float array array = [|[|1.|]|]
val fa1 : float array array =
  [|[|1.; 2.; 3.|]; [|4.; 13.; 5.|]; [|-1.; 3.; 0.|]|]
val fa2 : float array array =
  [|[|1.; 2.; 3.; 0.|]; [|4.; 13.; 5.; 0.|]; [|-1.; 3.; 0.; 0.|]|]
val fa3 : float array array =
  [|[|1.; 2.; 3.|]; [|4.; 13.; 5.|]; [|-1.; 3.; 0.|]; [|0.; 0.; 0.|]|]
val fa4 : float array array =
  [|[|0.; 2.; 3.|]; [|0.; 10.; 5.|]; [|0.; 3.; 0.|]|]
val fa5 : float array array list =
  [[|[|1.|]|]; [|[|1.; 2.; 3.|]; [|4.; 13.; 5.|]; [|-1.; 3.; 0.|]|];
   [|[|1.; 2.; 3.; 0.|]; [|4.; 13.; 5.; 0.|]; [|-1.; 3.; 0.; 0.|]|];
   [|[|1.; 2.; 3.|]; [|4.; 13.; 5.|]; [|-1.; 3.; 0.|]; [|0.; 0.; 0.|]|];
   [|[|0.; 2.; 3.|]; [|0.; 10.; 5.|]; [|0.; 3.; 0.|]|]]
val fa6 : float array array = [|[|1.; 1.|]|]
val fa7 : float array array =
  [|[|1.; 2.; 3.; 1.; 0.; 0.|]; [|4.; 13.; 5.; 0.; 1.; 0.|];
    [|-1.; 3.; 0.; 0.; 0.; 1.|]|]
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val resFA9 : GAC_F.contr * Code.perm list =
  ([|[|4.; 13.; 5.|]; [|-1.; 6.25; 1.25|]; [|1.; -1.25; 2.|]|],
   [Code.RowSwap (2, 1); Code.RowSwap (1, 0)])
- : unit = ()
- : unit = ()
- : unit = ()
val resF1 : GAC_F.Dom.v array array list =
  [[|[|1.|]|]; [|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]|];
   [|[|4.; 13.; 5.; 0.|]; [|0.; 6.25; 1.25; 0.|]; [|0.; 0.; 2.; 0.|]|];
   [|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|];
   [|[|0.; 10.; 5.|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|]]
- : unit = ()
- : unit = ()
- : unit = ()
val resFA31 : (GAC_F.contr * GAC_F.contr * Code.perm list) list =
  [([|[|1.|]|], [|[|1.|]|], []);
   ([|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]|],
    [|[|1.; 0.; 0.|]; [|0.25; 1.; 0.|]; [|-0.25; -0.2; 1.|]|],
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|4.; 13.; 5.; 0.|]; [|0.; 6.25; 1.25; 0.|]; [|0.; 0.; 2.; 0.|]|],
    [|[|1.; 0.; 0.; 0.|]; [|0.25; 1.; 0.; 0.|]; [|-0.25; -0.2; 1.; 0.|]|],
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|],
    [|[|1.; 0.; 0.|]; [|0.25; 1.; 0.|]; [|-0.25; -0.2; 1.|]; [|0.; 0.; 0.|]|],
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|0.; 10.; 5.|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|],
    [|[|1.; 0.; 0.|]; [|0.; 0.2; 0.|]; [|0.; 0.3; -0.75|]|],
    [Code.RowSwap (1, 0)])]
val resFA32 : (GAC_F.contr * Code.perm list) list =
  [([|[|1.|]|], []);
   ([|[|4.; 13.; 5.|]; [|-1.; 6.25; 1.25|]; [|1.; -1.25; 2.|]|],
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|4.; 13.; 5.; 0.|]; [|-1.; 6.25; 1.25; 0.|]; [|1.; -1.25; 2.; 0.|]|],
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|4.; 13.; 5.|]; [|-1.; 6.25; 1.25|]; [|1.; -1.25; 2.|];
      [|0.; 0.; 0.|]|],
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|0.; 10.; 5.|]; [|0.; 2.; 2.|]; [|0.; 3.; -1.5|]|],
    [Code.RowSwap (1, 0)])]
val a2v : 'a array array -> 'a Domains_code.container2dfromvector = <fun>
val xxx : float Domains_code.container2dfromvector list =
  [{arr = [|1.|]; n = 1; m = 1};
   {arr = [|1.; 2.; 3.; 4.; 13.; 5.; -1.; 3.; 0.|]; n = 3; m = 3};
   {arr = [|1.; 2.; 3.; 0.; 4.; 13.; 5.; 0.; -1.; 3.; 0.; 0.|]; n = 3; m = 4};
   {arr = [|1.; 2.; 3.; 4.; 13.; 5.; -1.; 3.; 0.; 0.; 0.; 0.|]; n = 4; m = 3};
   {arr = [|0.; 2.; 3.; 0.; 10.; 5.; 0.; 3.; 0.|]; n = 3; m = 3}]
- : unit = ()
val resFV5 : (float Domains_code.container2dfromvector * float * int) list =
  [({arr = [|1.|]; n = 1; m = 1}, 1., 1);
   ({arr =
      [|13.; 5.; 4.; 0.; 2.23076923076923084; 0.384615384615384581; 0.; 0.;
        -1.72413793103448287|];
     n = 3; m = 3},
    50., 3);
   ({arr =
      [|13.; 5.; 4.; 0.; 0.; 2.23076923076923084; 0.384615384615384581; 0.;
        0.; 0.; -1.72413793103448287; 0.|];
     n = 3; m = 4},
    50., 3);
   ({arr =
      [|13.; 5.; 4.; 0.; 2.23076923076923084; 0.384615384615384581; 0.; 0.;
        -1.72413793103448287; 0.; 0.; 0.|];
     n = 4; m = 3},
    50., 3);
   ({arr = [|10.; 5.; 0.; 0.; 2.; 0.; 0.; 0.; 0.|]; n = 3; m = 3}, 0., 2)]
val resF11 : GAC_F.Dom.v array array list =
  [[|[|1.|]|];
   [|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
     [|0.; 0.; -1.72413793103448287|]|];
   [|[|13.; 5.; 4.; 0.|];
     [|0.; 2.23076923076923084; 0.384615384615384581; 0.|];
     [|0.; 0.; -1.72413793103448287; 0.|]|];
   [|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
     [|0.; 0.; -1.72413793103448287|]; [|0.; 0.; 0.|]|];
   [|[|10.; 5.; 0.|]; [|0.; 2.; 0.|]; [|0.; 0.; 0.|]|]]
val resF12 : (GAC_F.contr * float) list =
  [([|[|1.|]|], 1.);
   ([|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
      [|0.; 0.; -1.72413793103448287|]|],
    50.);
   ([|[|13.; 5.; 4.; 0.|];
      [|0.; 2.23076923076923084; 0.384615384615384581; 0.|];
      [|0.; 0.; -1.72413793103448287; 0.|]|],
    50.);
   ([|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
      [|0.; 0.; -1.72413793103448287|]; [|0.; 0.; 0.|]|],
    50.);
   ([|[|10.; 5.; 0.|]; [|0.; 2.; 0.|]; [|0.; 0.; 0.|]|], 0.)]
val resF13 : (GAC_F.contr * int) list =
  [([|[|1.|]|], 1);
   ([|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
      [|0.; 0.; -1.72413793103448287|]|],
    3);
   ([|[|13.; 5.; 4.; 0.|];
      [|0.; 2.23076923076923084; 0.384615384615384581; 0.|];
      [|0.; 0.; -1.72413793103448287; 0.|]|],
    3);
   ([|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
      [|0.; 0.; -1.72413793103448287|]; [|0.; 0.; 0.|]|],
    3);
   ([|[|10.; 5.; 0.|]; [|0.; 2.; 0.|]; [|0.; 0.; 0.|]|], 2)]
val resF14 : (GAC_F.contr * GAC_F.Dom.v * int) list =
  [([|[|1.|]|], 1., 1);
   ([|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
      [|0.; 0.; -1.72413793103448287|]|],
    50., 3);
   ([|[|13.; 5.; 4.; 0.|];
      [|0.; 2.23076923076923084; 0.384615384615384581; 0.|];
      [|0.; 0.; -1.72413793103448287; 0.|]|],
    50., 3);
   ([|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
      [|0.; 0.; -1.72413793103448287|]; [|0.; 0.; 0.|]|],
    50., 3);
   ([|[|10.; 5.; 0.|]; [|0.; 2.; 0.|]; [|0.; 0.; 0.|]|], 0., 2)]
val resF24 : (GAC_F.contr * GAC_F.Dom.v * int * Code.perm list) list =
  [([|[|1.|]|], 1., 1, []);
   ([|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]|], 50., 3,
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|4.; 13.; 5.; 0.|]; [|0.; 6.25; 1.25; 0.|]; [|0.; 0.; 2.; 0.|]|], 50.,
    3, [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|],
    50., 3, [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|0.; 10.; 5.|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|], 0., 2,
    [Code.RowSwap (1, 0)])]
val resF25 : (GAC_F.contr * GAC_F.Dom.v * int * int array) list =
  [([|[|1.|]|], 1., 1, [|0|]);
   ([|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]|], 50., 3,
    [|1; 2; 0|]);
   ([|[|4.; 13.; 5.; 0.|]; [|0.; 6.25; 1.25; 0.|]; [|0.; 0.; 2.; 0.|]|], 50.,
    3, [|1; 2; 0|]);
   ([|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|],
    50., 3, [|1; 2; 0; 3|]);
   ([|[|0.; 10.; 5.|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|], 0., 2, [|1; 0; 2|])]
val resF26 : GAC_F.Dom.v array array list =
  [[|[|1.|]|]; [|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]|];
   [|[|4.; 13.; 5.; 0.|]; [|0.; 6.25; 1.25; 0.|]; [|0.; 0.; 2.; 0.|]|];
   [|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|];
   [|[|0.; 10.; 5.|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|]]
val ra0 : Num.num array array = [|[|Num.Int 1|]|]
val ra1 : Num.num array array =
  [|[|Num.Int 1; Num.Int 2; Num.Int 3|];
    [|Num.Int 4; Num.Int 13; Num.Int 5|];
    [|Num.Int (-1); Num.Int 3; Num.Int 0|]|]
val ra2 : Num.num array array =
  [|[|Num.Int 1; Num.Int 2; Num.Int 3; Num.Int 0|];
    [|Num.Int 4; Num.Int 13; Num.Int 5; Num.Int 0|];
    [|Num.Int (-1); Num.Int 3; Num.Int 0; Num.Int 0|]|]
val ra3 : Num.num array array =
  [|[|Num.Int 1; Num.Int 2; Num.Int 3|];
    [|Num.Int 4; Num.Int 13; Num.Int 5|];
    [|Num.Int (-1); Num.Int 3; Num.Int 0|];
    [|Num.Int 0; Num.Int 0; Num.Int 0|]|]
val ra4 : Num.num array array =
  [|[|Num.Int 0; Num.Int 2; Num.Int 3|];
    [|Num.Int 0; Num.Int 13; Num.Int 5|];
    [|Num.Int 0; Num.Int 3; Num.Int 0|]|]
val ra5 : Num.num array array list =
  [[|[|Num.Int 1|]|];
   [|[|Num.Int 1; Num.Int 2; Num.Int 3|];
     [|Num.Int 4; Num.Int 13; Num.Int 5|];
     [|Num.Int (-1); Num.Int 3; Num.Int 0|]|];
   [|[|Num.Int 1; Num.Int 2; Num.Int 3; Num.Int 0|];
     [|Num.Int 4; Num.Int 13; Num.Int 5; Num.Int 0|];
     [|Num.Int (-1); Num.Int 3; Num.Int 0; Num.Int 0|]|];
   [|[|Num.Int 1; Num.Int 2; Num.Int 3|];
     [|Num.Int 4; Num.Int 13; Num.Int 5|];
     [|Num.Int (-1); Num.Int 3; Num.Int 0|];
     [|Num.Int 0; Num.Int 0; Num.Int 0|]|];
   [|[|Num.Int 0; Num.Int 2; Num.Int 3|];
     [|Num.Int 0; Num.Int 13; Num.Int 5|];
     [|Num.Int 0; Num.Int 3; Num.Int 0|]|]]
val resR11 : GAC_R.Dom.v array array list =
  [[|[|Num.Int 1|]|];
   [|[|Num.Int 1; Num.Int 2; Num.Int 3|];
     [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
     [|Num.Int 0; Num.Int 0; Num.Int 10|]|];
   [|[|Num.Int 1; Num.Int 2; Num.Int 3; Num.Int 0|];
     [|Num.Int 0; Num.Int 5; Num.Int (-7); Num.Int 0|];
     [|Num.Int 0; Num.Int 0; Num.Int 10; Num.Int 0|]|];
   [|[|Num.Int 1; Num.Int 2; Num.Int 3|];
     [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
     [|Num.Int 0; Num.Int 0; Num.Int 10|];
     [|Num.Int 0; Num.Int 0; Num.Int 0|]|];
   [|[|Num.Int 0; Num.Int 2; Num.Int 3|];
     [|Num.Int 0; Num.Int 0; Num.Ratio <abstr>|];
     [|Num.Int 0; Num.Int 0; Num.Int 0|]|]]
val resR12 : (GAC_R.contr * GAC_R.Dom.v) list =
  [([|[|Num.Int 1|]|], Num.Int 1);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
      [|Num.Int 0; Num.Int 0; Num.Int 10|]|],
    Num.Int 50);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3; Num.Int 0|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7); Num.Int 0|];
      [|Num.Int 0; Num.Int 0; Num.Int 10; Num.Int 0|]|],
    Num.Int 50);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
      [|Num.Int 0; Num.Int 0; Num.Int 10|];
      [|Num.Int 0; Num.Int 0; Num.Int 0|]|],
    Num.Int 50);
   ([|[|Num.Int 0; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 0; Num.Ratio <abstr>|];
      [|Num.Int 0; Num.Int 0; Num.Int 0|]|],
    Num.Int 0)]
val resR13 : (GAC_R.contr * int) list =
  [([|[|Num.Int 1|]|], 1);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
      [|Num.Int 0; Num.Int 0; Num.Int 10|]|],
    3);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3; Num.Int 0|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7); Num.Int 0|];
      [|Num.Int 0; Num.Int 0; Num.Int 10; Num.Int 0|]|],
    3);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
      [|Num.Int 0; Num.Int 0; Num.Int 10|];
      [|Num.Int 0; Num.Int 0; Num.Int 0|]|],
    3);
   ([|[|Num.Int 0; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 0; Num.Ratio <abstr>|];
      [|Num.Int 0; Num.Int 0; Num.Int 0|]|],
    2)]
val resR14 : (GAC_R.contr * GAC_R.Dom.v * int) list =
  [([|[|Num.Int 1|]|], Num.Int 1, 1);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
      [|Num.Int 0; Num.Int 0; Num.Int 10|]|],
    Num.Int 50, 3);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3; Num.Int 0|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7); Num.Int 0|];
      [|Num.Int 0; Num.Int 0; Num.Int 10; Num.Int 0|]|],
    Num.Int 50, 3);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
      [|Num.Int 0; Num.Int 0; Num.Int 10|];
      [|Num.Int 0; Num.Int 0; Num.Int 0|]|],
    Num.Int 50, 3);
   ([|[|Num.Int 0; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 0; Num.Ratio <abstr>|];
      [|Num.Int 0; Num.Int 0; Num.Int 0|]|],
    Num.Int 0, 2)]
# 
