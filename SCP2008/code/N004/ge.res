Meta Caml toplevel, version N 004
        Objective Caml version 3.11.2

#             module GEF :
  sig
    module D :
      sig
        module type DOMAIN =
          sig
            type v
            val kind : Domains_sig.domain_kind
            val zero : v
            val one : v
            val plus : v -> v -> v
            val times : v -> v -> v
            val minus : v -> v -> v
            val uminus : v -> v
            val div : v -> v -> v
            val better_than : (v -> v -> bool) option
            val normalizer : (v -> v) option
          end
        module type DOMAINL =
          sig
            type v
            val kind : Domains_sig.domain_kind
            val zero : v
            val one : v
            val plus : v -> v -> v
            val times : v -> v -> v
            val minus : v -> v -> v
            val uminus : v -> v
            val div : v -> v -> v
            val better_than : (v -> v -> bool) option
            val normalizer : (v -> v) option
            type 'a vc = ('a, v) Code.abstract
            val zeroL : 'a vc
            val oneL : 'a vc
            val ( +^ ) : 'a vc -> 'a vc -> 'a vc
            val ( *^ ) : 'a vc -> 'a vc -> 'a vc
            val ( -^ ) : 'a vc -> 'a vc -> 'a vc
            val uminusL : 'a vc -> 'a vc
            val divL : 'a vc -> 'a vc -> 'a vc
            val better_thanL :
              ('a vc -> 'a vc -> ('a, bool) Code.abstract) option
            val normalizerL : ('a vc -> 'a vc) option
          end
        module type CONTAINER2D =
          sig
            module Dom : DOMAINL
            type contr
            type 'a vc = ('a, contr) Code.abstract
            type 'a vo = ('a, Dom.v) Code.abstract
            val getL :
              'a vc ->
              ('a, int) Code.abstract -> ('a, int) Code.abstract -> 'a vo
            val dim1 : 'a vc -> ('a, int) Code.abstract
            val dim2 : 'a vc -> ('a, int) Code.abstract
            val mapper : ('a vo -> 'a vo) option -> 'a vc -> 'a vc
            val copy : 'a vc -> 'a vc
            val init :
              ('a, int) Code.abstract -> ('a, int) Code.abstract -> 'a vc
            val augment :
              'a vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a vc -> ('a, int) Code.abstract -> 'a vc
            val identity :
              ('a, int) Code.abstract -> ('a, int) Code.abstract -> 'a vc
            val swap_rows_stmt :
              'a vc ->
              ('a, int) Code.abstract option ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract -> ('a, unit) Code.abstract
            val swap_cols_stmt :
              'a vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract -> ('a, unit) Code.abstract
            val row_head :
              'a vc ->
              ('a, int) Code.abstract -> ('a, int) Code.abstract -> 'a vo
            val col_head_set :
              'a vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract -> 'a vo -> ('a, unit) Code.abstract
          end
      end
    type ('a, 'b, 'c) cmonad_constraint = unit
      constraint 'a = < answer : 'd; classif : 'c; state : 'e; .. >
      constraint 'b = < answer : ('c, 'd) Code.abstract; state : 'e list >
    type ('a, 'b) cmonad =
        (< answer : ('d, 'c) Code.abstract; state : 'e list >,
         ('d, 'b) Code.abstract)
        StateCPSMonad.monad
      constraint 'a = < answer : 'c; classif : 'd; state : 'e; .. >
    type ('a, 'b) omonad =
        (< answer : ('d, 'c) Code.abstract; state : 'e list >,
         ('d, 'b) Code.abstract option)
        StateCPSMonad.monad
      constraint 'a = < answer : 'c; classif : 'd; state : 'e; .. >
    module Iters :
      sig
        val row_iter :
          'a ->
          'b ->
          ('c, int) Code.abstract ->
          ('c, int) Code.abstract ->
          ('a -> ('c, int) Code.abstract -> 'b -> ('c, 'd) Code.abstract) ->
          (('c, int) Code.abstract ->
           ('c, 'd) Code.abstract ->
           (< answer : ('c, 'e) Code.abstract; state : 'f; .. >,
            ('c, 'e) Code.abstract)
           StateCPSMonad.monad) ->
          Prelude.dir -> 'f -> ('f -> ('c, unit) Code.abstract -> 'g) -> 'g
        val col_iter :
          'a ->
          'b ->
          ('c, int) Code.abstract ->
          ('c, int) Code.abstract ->
          ('a -> 'b -> ('c, int) Code.abstract -> 'd) ->
          (('c, int) Code.abstract ->
           'd ->
           (< answer : ('c, 'e) Code.abstract; state : 'f; .. >,
            ('c, 'e) Code.abstract)
           StateCPSMonad.monad) ->
          Prelude.dir -> 'f -> ('f -> ('c, unit) Code.abstract -> 'g) -> 'g
      end
    module TrackRank :
      sig
        type 'a lstate = ('a, int ref) Code.abstract
        type 'a tag_lstate_ = [ `TRan of 'a lstate ]
        type 'a tag_lstate = 'a tag_lstate_
        type ('a, 'b) lm = ('a, 'b) cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> 'd tag_lstate ]; .. >
        val ip :
          ('a -> [> `TRan of 'a ]) * ([> `TRan of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TRan of ('a, int ref) Code.abstract ] list; .. >,
           ('a, int ref) Code.abstract)
          StateCPSMonad.monad
        val succ :
          unit ->
          (< answer : 'a;
             state : [> `TRan of ('b, int ref) Code.abstract ] list; .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        module type RANK =
          sig
            type 'a tag_lstate = 'a tag_lstate_
            val decl :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               int ref)
              lm
            val succ :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               unit)
              lm
            val fin :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               int)
              lm
          end
      end
    module Rank :
      sig
        type 'a lstate = ('a, int ref) Code.abstract
        type 'a tag_lstate_ = [ `TRan of 'a lstate ]
        type 'a tag_lstate = 'a tag_lstate_
        type ('a, 'b) lm = ('a, 'b) cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> 'd tag_lstate ]; .. >
        val ip :
          ('a -> [> `TRan of 'a ]) * ([> `TRan of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TRan of ('a, int ref) Code.abstract ] list; .. >,
           ('a, int ref) Code.abstract)
          StateCPSMonad.monad
        val succ :
          unit ->
          (< answer : 'a;
             state : [> `TRan of ('b, int ref) Code.abstract ] list; .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        module type RANK =
          sig
            type 'a tag_lstate = 'a tag_lstate_
            val decl :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               int ref)
              lm
            val succ :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               unit)
              lm
            val fin :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               int)
              lm
          end
        val fin :
          unit ->
          (< answer : 'a;
             state : [> `TRan of ('b, 'c ref) Code.abstract ] list; .. >,
           ('b, 'c) Code.abstract)
          StateCPSMonad.monad
      end
    module NoRank :
      sig
        type 'a lstate = ('a, int ref) Code.abstract
        type 'a tag_lstate_ = [ `TRan of 'a lstate ]
        type 'a tag_lstate = 'a tag_lstate_
        type ('a, 'b) lm = ('a, 'b) cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> 'd tag_lstate ]; .. >
        val ip :
          ('a -> [> `TRan of 'a ]) * ([> `TRan of 'b ] -> 'b option) * string
        val decl :
          unit ->
          (< answer : ('a, 'b) Code.abstract;
             state : [> `TRan of ('a, int ref) Code.abstract ] list; .. >,
           ('a, int ref) Code.abstract)
          StateCPSMonad.monad
        val succ :
          unit ->
          (< answer : 'a;
             state : [> `TRan of ('b, int ref) Code.abstract ] list; .. >,
           ('b, unit) Code.abstract)
          StateCPSMonad.monad
        module type RANK =
          sig
            type 'a tag_lstate = 'a tag_lstate_
            val decl :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               int ref)
              lm
            val succ :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               unit)
              lm
            val fin :
              unit ->
              (< answer : 'a; classif : 'b; state : [> 'b tag_lstate ]; .. >,
               int)
              lm
          end
        val fin : unit -> 'a
      end
    module type PIVOTKIND =
      sig
        type perm_rep
        type 'a ira = ('a, int) Code.abstract
        type 'a fra
        type 'a pra = ('a, perm_rep) Code.abstract
        val add : 'a fra -> 'a pra -> 'a pra
        val empty : 'a ira -> 'a pra
        val rowrep : 'a ira -> 'a ira -> 'a fra
        val colrep : 'a ira -> 'a ira -> 'a fra
      end
    module PermList :
      sig
        type flip_rep = Code.perm
        type perm_rep = Code.perm list
        type 'a ira = ('a, int) Code.abstract
        type 'a fra = ('a, flip_rep) Code.abstract
        type 'a pra = ('a, perm_rep) Code.abstract
        val add :
          ('a, 'b) Code.abstract ->
          ('a, 'b list) Code.abstract -> ('a, 'b list) Code.abstract
        val empty : 'a -> 'b pra
        val rowrep :
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract -> ('a, Code.perm) Code.abstract
        val colrep :
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract -> ('a, Code.perm) Code.abstract
      end
    module RowVectorPerm :
      sig
        type flip_rep = int * int
        type perm_rep = int array
        type 'a ira = ('a, int) Code.abstract
        type 'a fra = ('a, flip_rep) Code.abstract
        type 'a pra = ('a, perm_rep) Code.abstract
        val add :
          ('a, int * int) Code.abstract ->
          ('a, int array) Code.abstract -> ('a, int array) Code.abstract
        val empty : ('a, int) Code.abstract -> ('a, int array) Code.abstract
        val rowrep :
          ('a, 'b) Code.abstract ->
          ('a, 'c) Code.abstract -> ('a, 'b * 'c) Code.abstract
        val colrep :
          ('a, 'b) Code.abstract ->
          ('a, 'c) Code.abstract -> ('a, 'b * 'c) Code.abstract
      end
    module type TRACKPIVOT =
      sig
        type perm_rep
        type 'a ira = ('a, int) Code.abstract
        type 'a fra
        type 'a pra
        type 'a lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TPivot of 'd lstate ];
              .. >
        type ('a, 'b) nm =
            (< answer : ('b, 'c) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'c; classif : 'b;
              state : [> `TPivot of 'b lstate ] as 'd; .. >
        val rowrep : 'a ira -> 'a ira -> 'a fra
        val colrep : 'a ira -> 'a ira -> 'a fra
        val decl :
          ('a, int) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TPivot of 'a lstate ];
             .. >,
           'a)
          nm
        val add :
          'a fra ->
          (< answer : 'b; classif : 'a; state : [> `TPivot of 'a lstate ];
             .. >,
           unit)
          omonad
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TPivot of 'b lstate ];
             .. >,
           perm_rep)
          lm
      end
    module PivotCommon :
      functor (PK : PIVOTKIND) ->
        sig
          type perm_rep = PK.perm_rep
          type 'a ira = 'a PK.ira
          type 'a fra = 'a PK.fra
          type 'a pra = 'a PK.pra
          type 'a lstate = ('a, PK.perm_rep ref) Code.abstract
          type 'a pc_constraint = unit
            constraint 'a =
              < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
          type ('a, 'b) lm = ('a, 'b) cmonad
            constraint 'a =
              < answer : 'c; classif : 'd; state : [> `TPivot of 'd lstate ];
                .. >
          type ('a, 'b) nm =
              (< answer : ('b, 'c) Code.abstract; state : 'd list >, unit)
              StateCPSMonad.monad
            constraint 'a =
              < answer : 'c; classif : 'b;
                state : [> `TPivot of 'b lstate ] as 'd; .. >
          val rowrep : 'a PK.ira -> 'a PK.ira -> 'a PK.fra
          val colrep : 'a PK.ira -> 'a PK.ira -> 'a PK.fra
          val ip :
            ('a -> [> `TPivot of 'a ]) * ([> `TPivot of 'b ] -> 'b option) *
            string
        end
    module KeepPivot :
      functor (PK : PIVOTKIND) ->
        sig
          type perm_rep = PK.perm_rep
          type 'a ira = 'a PK.ira
          type 'a fra = 'a PK.fra
          type 'a pra = 'a PK.pra
          type 'a lstate = ('a, PK.perm_rep ref) Code.abstract
          type 'a pc_constraint = unit
            constraint 'a =
              < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
          type ('a, 'b) lm = ('a, 'b) cmonad
            constraint 'a =
              < answer : 'c; classif : 'd; state : [> `TPivot of 'd lstate ];
                .. >
          type ('a, 'b) nm =
              (< answer : ('b, 'c) Code.abstract; state : 'd list >, unit)
              StateCPSMonad.monad
            constraint 'a =
              < answer : 'c; classif : 'b;
                state : [> `TPivot of 'b lstate ] as 'd; .. >
          val rowrep : 'a PK.ira -> 'a PK.ira -> 'a PK.fra
          val colrep : 'a PK.ira -> 'a PK.ira -> 'a PK.fra
          val ip :
            ('a -> [> `TPivot of 'a ]) * ([> `TPivot of 'b ] -> 'b option) *
            string
          val decl :
            'a PK.ira ->
            (< answer : ('a, 'b) Code.abstract;
               state : [> `TPivot of ('a, PK.perm_rep ref) Code.abstract ]
                       list;
               .. >,
             unit)
            StateCPSMonad.monad
          val add :
            'a PK.fra ->
            (< answer : 'b;
               state : [> `TPivot of ('a, PK.perm_rep ref) Code.abstract ]
                       list;
               .. >,
             ('a, unit) Code.abstract option)
            StateCPSMonad.monad
          val fin :
            unit ->
            (< answer : 'a;
               state : [> `TPivot of ('b, 'c ref) Code.abstract ] list; .. >,
             ('b, 'c) Code.abstract)
            StateCPSMonad.monad
        end
    module DiscardPivot :
      sig
        type perm_rep = PermList.perm_rep
        type 'a ira = 'a PermList.ira
        type 'a fra = 'a PermList.fra
        type 'a pra = 'a PermList.pra
        type 'a lstate = ('a, PermList.perm_rep ref) Code.abstract
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TPivot of 'd lstate ];
              .. >
        type ('a, 'b) nm =
            (< answer : ('b, 'c) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'c; classif : 'b;
              state : [> `TPivot of 'b lstate ] as 'd; .. >
        val rowrep : 'a PermList.ira -> 'a PermList.ira -> 'a PermList.fra
        val colrep : 'a PermList.ira -> 'a PermList.ira -> 'a PermList.fra
        val ip :
          ('a -> [> `TPivot of 'a ]) * ([> `TPivot of 'b ] -> 'b option) *
          string
        val decl :
          'a -> (< answer : 'b; state : 'c; .. >, unit) StateCPSMonad.monad
        val add :
          'a ->
          (< answer : 'b; state : 'c; .. >, 'd option) StateCPSMonad.monad
        val fin : unit -> 'a
      end
    module GenLA :
      functor (C : D.CONTAINER2D) ->
        sig
          type 'a wmatrix =
            'a Ge.LAMake(Code).GenLA(C).wmatrix = {
            matrix : 'a C.vc;
            numrow : ('a, int) Code.abstract;
            numcol : ('a, int) Code.abstract;
          }
          type 'a curpos =
            'a Ge.LAMake(Code).GenLA(C).curpos = {
            rowpos : ('a, int) Code.abstract;
            colpos : ('a, int) Code.abstract;
          }
          type 'a curposval =
            'a Ge.LAMake(Code).GenLA(C).curposval = {
            p : 'a curpos;
            curval : ('a, C.Dom.v) Code.abstract;
          }
          module type DETERMINANT =
            sig
              type tdet = C.Dom.v ref
              type 'a lstate
              type 'a pc_constraint = unit
                constraint 'a =
                  < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
              type ('a, 'b) lm = ('a, 'b) cmonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TDet of 'd lstate ]; .. >
              type ('a, 'b) om = ('a, 'b) omonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TDet of 'd lstate ]; .. >
              type 'a nm =
                  (< answer : ('c, 'b) Code.abstract; state : 'd list >,
                   unit)
                  StateCPSMonad.monad
                constraint 'a =
                  < answer : 'b; classif : 'c;
                    state : [> `TDet of 'c lstate ] as 'd; .. >
              val decl :
                unit ->
                < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ];
                  .. >
                nm
              val upd_sign :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 unit)
                om
              val zero_sign :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 unit)
                lm
              val acc_magn :
                ('a, C.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a lstate ]; .. >,
                 unit)
                lm
              val get_magn :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 tdet)
                lm
              val set_magn :
                ('a, C.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a lstate ]; .. >,
                 unit)
                lm
              val fin :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 C.Dom.v)
                lm
            end
          module type LOWER =
            sig
              type 'a lstate = ('a, C.contr) Code.abstract
              type ('a, 'b) lm = ('a, 'b) cmonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TLower of 'd lstate ]; .. >
              val decl :
                ('a, C.contr) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TLower of 'a lstate ]; .. >,
                 C.contr)
                lm
              val updt :
                'a C.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'a C.vo ->
                'a C.Dom.vc ->
                (< answer : 'b; classif : 'a;
                   state : [> `TLower of 'a lstate ]; .. >,
                 unit)
                lm option
              val fin :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TLower of 'b lstate ]; .. >,
                 C.contr)
                lm
              val wants_pack : bool
            end
          module type PIVOT =
            functor (D : DETERMINANT) ->
              functor (P : TRACKPIVOT) ->
                functor (L : LOWER) ->
                  sig
                    val findpivot :
                      'a wmatrix ->
                      'a curpos ->
                      (< answer : 'b; classif : 'a;
                         state : [> `TDet of 'a D.lstate
                                  | `TPivot of 'a P.lstate ];
                         .. >,
                       C.Dom.v option)
                      cmonad
                  end
          module NoDet :
            sig
              type tdet = C.Dom.v ref
              type 'a lstate = 'a Ge.LAMake(Code).GenLA(C).NoDet.lstate
              type 'a pc_constraint = unit
                constraint 'a =
                  < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
              type ('a, 'b) lm = ('a, 'b) cmonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TDet of 'd lstate ]; .. >
              type ('a, 'b) om = ('a, 'b) omonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TDet of 'd lstate ]; .. >
              type 'a nm =
                  (< answer : ('c, 'b) Code.abstract; state : 'd list >,
                   unit)
                  StateCPSMonad.monad
                constraint 'a =
                  < answer : 'b; classif : 'c;
                    state : [> `TDet of 'c lstate ] as 'd; .. >
              val decl :
                unit ->
                < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ];
                  .. >
                nm
              val upd_sign :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 unit)
                om
              val zero_sign :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 unit)
                lm
              val acc_magn :
                ('a, C.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a lstate ]; .. >,
                 unit)
                lm
              val get_magn :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 tdet)
                lm
              val set_magn :
                ('a, C.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a lstate ]; .. >,
                 unit)
                lm
              val fin :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 C.Dom.v)
                lm
            end
          module AbstractDet :
            sig
              type tdet = C.Dom.v ref
              type 'a lstate = 'a Ge.LAMake(Code).GenLA(C).AbstractDet.lstate
              type 'a pc_constraint = unit
                constraint 'a =
                  < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
              type ('a, 'b) lm = ('a, 'b) cmonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TDet of 'd lstate ]; .. >
              type ('a, 'b) om = ('a, 'b) omonad
                constraint 'a =
                  < answer : 'c; classif : 'd;
                    state : [> `TDet of 'd lstate ]; .. >
              type 'a nm =
                  (< answer : ('c, 'b) Code.abstract; state : 'd list >,
                   unit)
                  StateCPSMonad.monad
                constraint 'a =
                  < answer : 'b; classif : 'c;
                    state : [> `TDet of 'c lstate ] as 'd; .. >
              val decl :
                unit ->
                < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ];
                  .. >
                nm
              val upd_sign :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 unit)
                om
              val zero_sign :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 unit)
                lm
              val acc_magn :
                ('a, C.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a lstate ]; .. >,
                 unit)
                lm
              val get_magn :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 tdet)
                lm
              val set_magn :
                ('a, C.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a lstate ]; .. >,
                 unit)
                lm
              val fin :
                unit ->
                (< answer : 'a; classif : 'b;
                   state : [> `TDet of 'b lstate ]; .. >,
                 C.Dom.v)
                lm
            end
          module type UPDATE =
            functor (D : DETERMINANT) ->
              sig
                type 'a in_val = 'a C.Dom.vc
                val update :
                  'a in_val ->
                  'a in_val ->
                  'a in_val ->
                  'a in_val ->
                  ('a in_val -> ('a, unit) Code.abstract) ->
                  ('a, C.Dom.v ref) Code.abstract ->
                  (< answer : 'b; classif : 'a; state : 'c; .. >, unit)
                  cmonad
                val update_det :
                  'a in_val ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TDet of 'a D.lstate ]; .. >,
                   unit)
                  D.lm
                val upd_kind : Ge.update_kind
              end
          module GE :
            sig
              module DivisionUpdate :
                functor (Det : DETERMINANT) ->
                  sig
                    type 'a in_val = 'a C.Dom.vc
                    val update :
                      'a C.Dom.vc ->
                      'a C.Dom.vc ->
                      'a C.Dom.vc ->
                      'a C.Dom.vc ->
                      ('a C.Dom.vc -> 'b) ->
                      'c ->
                      (< answer : 'd; state : 'e; .. >, 'b)
                      StateCPSMonad.monad
                    val update_det :
                      ('a, C.Dom.v) Code.abstract ->
                      (< answer : 'b; classif : 'a;
                         state : [> `TDet of 'a Det.lstate ]; .. >,
                       unit)
                      Det.lm
                    val upd_kind : Ge.update_kind
                  end
              module FractionFreeUpdate :
                functor (Det : DETERMINANT) ->
                  sig
                    type 'a in_val = 'a C.Dom.vc
                    val update :
                      'a C.Dom.vc ->
                      'a C.Dom.vc ->
                      'a C.Dom.vc ->
                      'a C.Dom.vc ->
                      ('a C.Dom.vc -> 'b) ->
                      ('a, C.Dom.v ref) Code.abstract ->
                      (< answer : 'c; state : 'd; .. >, 'b)
                      StateCPSMonad.monad
                    val update_det :
                      ('a, C.Dom.v) Code.abstract ->
                      (< answer : 'b; classif : 'a;
                         state : [> `TDet of 'a Det.lstate ]; .. >,
                       unit)
                      Det.lm
                    val upd_kind : Ge.update_kind
                  end
              module TrackLower :
                sig
                  type 'a lstate = ('a, C.contr) Code.abstract
                  type ('a, 'b) lm = ('a, 'b) cmonad
                    constraint 'a =
                      < answer : 'c; classif : 'd;
                        state : [> `TLower of 'd lstate ]; .. >
                  val ip :
                    ('a -> [> `TLower of 'a ]) *
                    ([> `TLower of 'b ] -> 'b option) * string
                end
              module SeparateLower :
                sig
                  type 'a lstate = ('a, C.contr) Code.abstract
                  type ('a, 'b) lm = ('a, 'b) cmonad
                    constraint 'a =
                      < answer : 'c; classif : 'd;
                        state : [> `TLower of 'd lstate ]; .. >
                  val ip :
                    ('a -> [> `TLower of 'a ]) *
                    ([> `TLower of 'b ] -> 'b option) * string
                  val decl :
                    ('a, 'b) Code.abstract ->
                    (< answer : ('a, 'c) Code.abstract;
                       state : [> `TLower of ('a, 'b) Code.abstract ] list;
                       .. >,
                     ('a, 'b) Code.abstract)
                    StateCPSMonad.monad
                  val updt :
                    'a C.vc ->
                    ('a, int) Code.abstract ->
                    ('a, int) Code.abstract ->
                    'a C.vo ->
                    'a C.vo ->
                    (< answer : 'b; state : [> `TLower of 'a C.vc ] list;
                       .. >,
                     ('a, unit) Code.abstract)
                    StateCPSMonad.monad option
                  val fin :
                    unit ->
                    (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                     'b)
                    StateCPSMonad.monad
                  val wants_pack : bool
                end
              module PackedLower :
                sig
                  type 'a lstate = ('a, C.contr) Code.abstract
                  type ('a, 'b) lm = ('a, 'b) cmonad
                    constraint 'a =
                      < answer : 'c; classif : 'd;
                        state : [> `TLower of 'd lstate ]; .. >
                  val ip :
                    ('a -> [> `TLower of 'a ]) *
                    ([> `TLower of 'b ] -> 'b option) * string
                  val decl :
                    'a ->
                    (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                     'a)
                    StateCPSMonad.monad
                  val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                  val fin :
                    unit ->
                    (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                     'b)
                    StateCPSMonad.monad
                  val wants_pack : bool
                end
              module NoLower :
                sig
                  type 'a lstate = ('a, C.contr) Code.abstract
                  type ('a, 'b) lm = ('a, 'b) cmonad
                    constraint 'a =
                      < answer : 'c; classif : 'd;
                        state : [> `TLower of 'd lstate ]; .. >
                  val ip :
                    ('a -> [> `TLower of 'a ]) *
                    ([> `TLower of 'b ] -> 'b option) * string
                  val decl :
                    'a ->
                    (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
                  val updt :
                    'a C.vc ->
                    ('a, int) Code.abstract ->
                    ('a, int) Code.abstract ->
                    'a C.vo ->
                    'b ->
                    (< answer : 'c; state : 'd; .. >,
                     ('a, unit) Code.abstract)
                    StateCPSMonad.monad option
                  val fin : unit -> 'a
                  val wants_pack : bool
                end
              module type INPUT =
                sig
                  type inp
                  val get_input :
                    ('a, inp) Code.abstract ->
                    (< answer : 'b; classif : 'a; state : 'c; .. >,
                     ('a, C.contr) Code.abstract * ('a, int) Code.abstract *
                     bool)
                    StateCPSMonad.monad
                end
              module InpJustMatrix :
                sig
                  type inp = C.contr
                  val get_input :
                    'a C.vc ->
                    (< answer : 'b; state : 'c; .. >,
                     'a C.vc * ('a, int) Code.abstract * bool)
                    StateCPSMonad.monad
                end
              module InpMatrixMargin :
                sig
                  type inp = C.contr * int
                  val get_input :
                    ('a, 'b * 'c) Code.abstract ->
                    (< answer : 'd; state : 'e; .. >,
                     ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
                    StateCPSMonad.monad
                end
              module RowPivot :
                functor (Det : DETERMINANT) ->
                  functor (P : TRACKPIVOT) ->
                    functor (L : LOWER) ->
                      sig
                        val optim : 'a -> 'a option
                        val findpivot :
                          'a wmatrix ->
                          'a curpos ->
                          (< answer : ('a, 'b) Code.abstract;
                             state : [> `TDet of 'a Det.lstate
                                      | `TPivot of 'a P.lstate ]
                                     list;
                             .. >,
                           ('a, C.Dom.v option) Code.abstract)
                          StateCPSMonad.monad
                      end
              module FullPivot :
                functor (Det : DETERMINANT) ->
                  functor (P : TRACKPIVOT) ->
                    functor (L : LOWER) ->
                      sig
                        val optim : 'a -> 'a option
                        val findpivot :
                          'a wmatrix ->
                          'a curpos ->
                          (< answer : ('a, 'b) Code.abstract;
                             state : [> `TDet of 'a Det.lstate
                                      | `TPivot of 'a P.lstate ]
                                     list;
                             .. >,
                           ('a, C.Dom.v option) Code.abstract)
                          StateCPSMonad.monad
                      end
              module NoPivot :
                functor (Det : DETERMINANT) ->
                  functor (P : TRACKPIVOT) ->
                    functor (L : LOWER) ->
                      sig
                        val findpivot :
                          'a wmatrix ->
                          'a curpos ->
                          (< answer : 'b; state : 'c; .. >,
                           ('a, C.Dom.v option) Code.abstract)
                          StateCPSMonad.monad
                      end
              module type OUTPUTDEP =
                sig module PivotRep : PIVOTKIND module Det : DETERMINANT end
              module OutJustMatrix :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin : unit -> 'a
                          end
                        module P :
                          sig
                            type perm_rep = PermList.perm_rep
                            type 'a ira = 'a PermList.ira
                            type 'a fra = 'a PermList.fra
                            type 'a pra = 'a PermList.pra
                            type 'a lstate =
                                ('a, PermList.perm_rep ref) Code.abstract
                            type 'a pc_constraint = unit
                              constraint 'a =
                                < classif : 'b;
                                  state : [> `TPivot of 'b lstate ]; .. >
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            type ('a, 'b) nm =
                                (< answer : ('b, 'c) Code.abstract;
                                   state : 'd list >,
                                 unit)
                                StateCPSMonad.monad
                              constraint 'a =
                                < answer : 'c; classif : 'b;
                                  state : [> `TPivot of 'b lstate ] as 'd;
                                  .. >
                            val rowrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val colrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, unit)
                              StateCPSMonad.monad
                            val add :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'd option)
                              StateCPSMonad.monad
                            val fin : unit -> 'a
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'a)
                              StateCPSMonad.monad
                            val updt :
                              'a C.vc ->
                              ('a, int) Code.abstract ->
                              ('a, int) Code.abstract ->
                              'a C.vo ->
                              'b ->
                              (< answer : 'c; state : 'd; .. >,
                               ('a, unit) Code.abstract)
                              StateCPSMonad.monad option
                            val fin : unit -> 'a
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr
                    val make_result :
                      'a wmatrix ->
                      (< answer : 'b; state : 'c; .. >, 'a C.vc)
                      StateCPSMonad.monad
                  end
              module OutDet :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin : unit -> 'a
                          end
                        module P :
                          sig
                            type perm_rep = PermList.perm_rep
                            type 'a ira = 'a PermList.ira
                            type 'a fra = 'a PermList.fra
                            type 'a pra = 'a PermList.pra
                            type 'a lstate =
                                ('a, PermList.perm_rep ref) Code.abstract
                            type 'a pc_constraint = unit
                              constraint 'a =
                                < classif : 'b;
                                  state : [> `TPivot of 'b lstate ]; .. >
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            type ('a, 'b) nm =
                                (< answer : ('b, 'c) Code.abstract;
                                   state : 'd list >,
                                 unit)
                                StateCPSMonad.monad
                              constraint 'a =
                                < answer : 'c; classif : 'b;
                                  state : [> `TPivot of 'b lstate ] as 'd;
                                  .. >
                            val rowrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val colrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, unit)
                              StateCPSMonad.monad
                            val add :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'd option)
                              StateCPSMonad.monad
                            val fin : unit -> 'a
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'a)
                              StateCPSMonad.monad
                            val updt :
                              'a C.vc ->
                              ('a, int) Code.abstract ->
                              ('a, int) Code.abstract ->
                              'a C.vo ->
                              'b ->
                              (< answer : 'c; state : 'd; .. >,
                               ('a, unit) Code.abstract)
                              StateCPSMonad.monad option
                            val fin : unit -> 'a
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr * C.Dom.v
                    val make_result :
                      'a wmatrix ->
                      (< answer : ('a, 'b) Code.abstract;
                         state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                       ('a, C.contr * C.Dom.v) Code.abstract)
                      StateCPSMonad.monad
                  end
              module OutRank :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, 'c ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, 'c) Code.abstract)
                              StateCPSMonad.monad
                          end
                        module P :
                          sig
                            type perm_rep = PermList.perm_rep
                            type 'a ira = 'a PermList.ira
                            type 'a fra = 'a PermList.fra
                            type 'a pra = 'a PermList.pra
                            type 'a lstate =
                                ('a, PermList.perm_rep ref) Code.abstract
                            type 'a pc_constraint = unit
                              constraint 'a =
                                < classif : 'b;
                                  state : [> `TPivot of 'b lstate ]; .. >
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            type ('a, 'b) nm =
                                (< answer : ('b, 'c) Code.abstract;
                                   state : 'd list >,
                                 unit)
                                StateCPSMonad.monad
                              constraint 'a =
                                < answer : 'c; classif : 'b;
                                  state : [> `TPivot of 'b lstate ] as 'd;
                                  .. >
                            val rowrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val colrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, unit)
                              StateCPSMonad.monad
                            val add :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'd option)
                              StateCPSMonad.monad
                            val fin : unit -> 'a
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'a)
                              StateCPSMonad.monad
                            val updt :
                              'a C.vc ->
                              ('a, int) Code.abstract ->
                              ('a, int) Code.abstract ->
                              'a C.vo ->
                              'b ->
                              (< answer : 'c; state : 'd; .. >,
                               ('a, unit) Code.abstract)
                              StateCPSMonad.monad option
                            val fin : unit -> 'a
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr * int
                    val make_result :
                      'a wmatrix ->
                      (< answer : 'b;
                         state : [> `TRan of ('a, 'c ref) Code.abstract ]
                                 list;
                         .. >,
                       ('a, C.contr * 'c) Code.abstract)
                      StateCPSMonad.monad
                  end
              module OutDetRank :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, 'c ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, 'c) Code.abstract)
                              StateCPSMonad.monad
                          end
                        module P :
                          sig
                            type perm_rep = PermList.perm_rep
                            type 'a ira = 'a PermList.ira
                            type 'a fra = 'a PermList.fra
                            type 'a pra = 'a PermList.pra
                            type 'a lstate =
                                ('a, PermList.perm_rep ref) Code.abstract
                            type 'a pc_constraint = unit
                              constraint 'a =
                                < classif : 'b;
                                  state : [> `TPivot of 'b lstate ]; .. >
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            type ('a, 'b) nm =
                                (< answer : ('b, 'c) Code.abstract;
                                   state : 'd list >,
                                 unit)
                                StateCPSMonad.monad
                              constraint 'a =
                                < answer : 'c; classif : 'b;
                                  state : [> `TPivot of 'b lstate ] as 'd;
                                  .. >
                            val rowrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val colrep :
                              'a PermList.ira ->
                              'a PermList.ira -> 'a PermList.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, unit)
                              StateCPSMonad.monad
                            val add :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'd option)
                              StateCPSMonad.monad
                            val fin : unit -> 'a
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'a)
                              StateCPSMonad.monad
                            val updt :
                              'a C.vc ->
                              ('a, int) Code.abstract ->
                              ('a, int) Code.abstract ->
                              'a C.vo ->
                              'b ->
                              (< answer : 'c; state : 'd; .. >,
                               ('a, unit) Code.abstract)
                              StateCPSMonad.monad option
                            val fin : unit -> 'a
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr * C.Dom.v * int
                    val make_result :
                      'a wmatrix ->
                      (< answer : ('a, 'b) Code.abstract;
                         state : [> `TDet of 'a OD.Det.lstate
                                  | `TRan of ('a, 'c ref) Code.abstract ]
                                 list;
                         .. >,
                       ('a, C.contr * C.Dom.v * 'c) Code.abstract)
                      StateCPSMonad.monad
                  end
              module OutDetRankPivot :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, 'c ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, 'c) Code.abstract)
                              StateCPSMonad.monad
                          end
                        module P :
                          sig
                            type perm_rep = OD.PivotRep.perm_rep
                            type 'a ira = 'a OD.PivotRep.ira
                            type 'a fra = 'a OD.PivotRep.fra
                            type 'a pra = 'a OD.PivotRep.pra
                            type 'a lstate =
                                ('a, OD.PivotRep.perm_rep ref) Code.abstract
                            type 'a pc_constraint = unit
                              constraint 'a =
                                < classif : 'b;
                                  state : [> `TPivot of 'b lstate ]; .. >
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            type ('a, 'b) nm =
                                (< answer : ('b, 'c) Code.abstract;
                                   state : 'd list >,
                                 unit)
                                StateCPSMonad.monad
                              constraint 'a =
                                < answer : 'c; classif : 'b;
                                  state : [> `TPivot of 'b lstate ] as 'd;
                                  .. >
                            val rowrep :
                              'a OD.PivotRep.ira ->
                              'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                            val colrep :
                              'a OD.PivotRep.ira ->
                              'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a OD.PivotRep.ira ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TPivot of
                                              ('a, OD.PivotRep.perm_rep ref)
                                              Code.abstract ]
                                         list;
                                 .. >,
                               unit)
                              StateCPSMonad.monad
                            val add :
                              'a OD.PivotRep.fra ->
                              (< answer : 'b;
                                 state : [> `TPivot of
                                              ('a, OD.PivotRep.perm_rep ref)
                                              Code.abstract ]
                                         list;
                                 .. >,
                               ('a, unit) Code.abstract option)
                              StateCPSMonad.monad
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TPivot of
                                              ('b, 'c ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, 'c) Code.abstract)
                              StateCPSMonad.monad
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b; state : 'c; .. >, 'a)
                              StateCPSMonad.monad
                            val updt :
                              'a C.vc ->
                              ('a, int) Code.abstract ->
                              ('a, int) Code.abstract ->
                              'a C.vo ->
                              'b ->
                              (< answer : 'c; state : 'd; .. >,
                               ('a, unit) Code.abstract)
                              StateCPSMonad.monad option
                            val fin : unit -> 'a
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr * C.Dom.v * int * IF.P.perm_rep
                    val make_result :
                      'a wmatrix ->
                      (< answer : ('a, 'b) Code.abstract;
                         state : [> `TDet of 'a OD.Det.lstate
                                  | `TPivot of ('a, 'c ref) Code.abstract
                                  | `TRan of ('a, 'd ref) Code.abstract ]
                                 list;
                         .. >,
                       ('a, C.contr * C.Dom.v * 'd * 'c) Code.abstract)
                      StateCPSMonad.monad
                  end
              module Out_L_U :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin : unit -> 'a
                          end
                        module P :
                          sig
                            type perm_rep = OD.PivotRep.perm_rep
                            type 'a ira = 'a OD.PivotRep.ira
                            type 'a fra = 'a OD.PivotRep.fra
                            type 'a pra = 'a OD.PivotRep.pra
                            type 'a lstate =
                                ('a, OD.PivotRep.perm_rep ref) Code.abstract
                            type 'a pc_constraint = unit
                              constraint 'a =
                                < classif : 'b;
                                  state : [> `TPivot of 'b lstate ]; .. >
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            type ('a, 'b) nm =
                                (< answer : ('b, 'c) Code.abstract;
                                   state : 'd list >,
                                 unit)
                                StateCPSMonad.monad
                              constraint 'a =
                                < answer : 'c; classif : 'b;
                                  state : [> `TPivot of 'b lstate ] as 'd;
                                  .. >
                            val rowrep :
                              'a OD.PivotRep.ira ->
                              'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                            val colrep :
                              'a OD.PivotRep.ira ->
                              'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a OD.PivotRep.ira ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TPivot of
                                              ('a, OD.PivotRep.perm_rep ref)
                                              Code.abstract ]
                                         list;
                                 .. >,
                               unit)
                              StateCPSMonad.monad
                            val add :
                              'a OD.PivotRep.fra ->
                              (< answer : 'b;
                                 state : [> `TPivot of
                                              ('a, OD.PivotRep.perm_rep ref)
                                              Code.abstract ]
                                         list;
                                 .. >,
                               ('a, unit) Code.abstract option)
                              StateCPSMonad.monad
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TPivot of
                                              ('b, 'c ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, 'c) Code.abstract)
                              StateCPSMonad.monad
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              ('a, 'b) Code.abstract ->
                              (< answer : ('a, 'c) Code.abstract;
                                 state : [> `TLower of ('a, 'b) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, 'b) Code.abstract)
                              StateCPSMonad.monad
                            val updt :
                              'a C.vc ->
                              ('a, int) Code.abstract ->
                              ('a, int) Code.abstract ->
                              'a C.vo ->
                              'a C.vo ->
                              (< answer : 'b;
                                 state : [> `TLower of 'a C.vc ] list; .. >,
                               ('a, unit) Code.abstract)
                              StateCPSMonad.monad option
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TLower of 'b ] list; .. >,
                               'b)
                              StateCPSMonad.monad
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr * C.contr * IF.P.perm_rep
                    val make_result :
                      'a wmatrix ->
                      (< answer : 'b;
                         state : [> `TLower of ('a, 'c) Code.abstract
                                  | `TPivot of ('a, 'd ref) Code.abstract ]
                                 list;
                         .. >,
                       ('a, C.contr * 'c * 'd) Code.abstract)
                      StateCPSMonad.monad
                  end
              module Out_LU_Packed :
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF :
                      sig
                        module R :
                          sig
                            type 'a lstate = ('a, int ref) Code.abstract
                            type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                            type 'a tag_lstate = 'a tag_lstate_
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> 'd tag_lstate ]; .. >
                            val ip :
                              ('a -> [> `TRan of 'a ]) *
                              ([> `TRan of 'b ] -> 'b option) * string
                            val decl :
                              unit ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TRan of
                                              ('a, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('a, int ref) Code.abstract)
                              StateCPSMonad.monad
                            val succ :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TRan of
                                              ('b, int ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, unit) Code.abstract)
                              StateCPSMonad.monad
                            module type RANK =
                              sig
                                type 'a tag_lstate = 'a tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int ref)
                                  lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   unit)
                                  lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b tag_lstate ]; .. >,
                                   int)
                                  lm
                              end
                            val fin : unit -> 'a
                          end
                        module P :
                          sig
                            type perm_rep = OD.PivotRep.perm_rep
                            type 'a ira = 'a OD.PivotRep.ira
                            type 'a fra = 'a OD.PivotRep.fra
                            type 'a pra = 'a OD.PivotRep.pra
                            type 'a lstate =
                                ('a, OD.PivotRep.perm_rep ref) Code.abstract
                            type 'a pc_constraint = unit
                              constraint 'a =
                                < classif : 'b;
                                  state : [> `TPivot of 'b lstate ]; .. >
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TPivot of 'd lstate ]; .. >
                            type ('a, 'b) nm =
                                (< answer : ('b, 'c) Code.abstract;
                                   state : 'd list >,
                                 unit)
                                StateCPSMonad.monad
                              constraint 'a =
                                < answer : 'c; classif : 'b;
                                  state : [> `TPivot of 'b lstate ] as 'd;
                                  .. >
                            val rowrep :
                              'a OD.PivotRep.ira ->
                              'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                            val colrep :
                              'a OD.PivotRep.ira ->
                              'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                            val ip :
                              ('a -> [> `TPivot of 'a ]) *
                              ([> `TPivot of 'b ] -> 'b option) * string
                            val decl :
                              'a OD.PivotRep.ira ->
                              (< answer : ('a, 'b) Code.abstract;
                                 state : [> `TPivot of
                                              ('a, OD.PivotRep.perm_rep ref)
                                              Code.abstract ]
                                         list;
                                 .. >,
                               unit)
                              StateCPSMonad.monad
                            val add :
                              'a OD.PivotRep.fra ->
                              (< answer : 'b;
                                 state : [> `TPivot of
                                              ('a, OD.PivotRep.perm_rep ref)
                                              Code.abstract ]
                                         list;
                                 .. >,
                               ('a, unit) Code.abstract option)
                              StateCPSMonad.monad
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TPivot of
                                              ('b, 'c ref) Code.abstract ]
                                         list;
                                 .. >,
                               ('b, 'c) Code.abstract)
                              StateCPSMonad.monad
                          end
                        module L :
                          sig
                            type 'a lstate = ('a, C.contr) Code.abstract
                            type ('a, 'b) lm = ('a, 'b) cmonad
                              constraint 'a =
                                < answer : 'c; classif : 'd;
                                  state : [> `TLower of 'd lstate ]; .. >
                            val ip :
                              ('a -> [> `TLower of 'a ]) *
                              ([> `TLower of 'b ] -> 'b option) * string
                            val decl :
                              'a ->
                              (< answer : 'b;
                                 state : [> `TLower of 'a ] list; .. >,
                               'a)
                              StateCPSMonad.monad
                            val updt :
                              'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                            val fin :
                              unit ->
                              (< answer : 'a;
                                 state : [> `TLower of 'b ] list; .. >,
                               'b)
                              StateCPSMonad.monad
                            val wants_pack : bool
                          end
                      end
                    type res = C.contr * IF.P.perm_rep
                    val make_result :
                      'a ->
                      (< answer : 'b;
                         state : [> `TLower of ('c, 'd) Code.abstract
                                  | `TPivot of ('c, 'e ref) Code.abstract ]
                                 list;
                         .. >,
                       ('c, 'd * 'e) Code.abstract)
                      StateCPSMonad.monad
                  end
              module type INTERNAL_FEATURES =
                sig
                  module R : TrackRank.RANK
                  module P : TRACKPIVOT
                  module L : LOWER
                end
              module type OUTPUT =
                functor (OD : OUTPUTDEP) ->
                  sig
                    module IF : INTERNAL_FEATURES
                    type res
                    val make_result :
                      'a wmatrix ->
                      (< answer : 'b; classif : 'a;
                         state : [> `TDet of 'a OD.Det.lstate
                                  | `TLower of 'a IF.L.lstate
                                  | `TPivot of 'a IF.P.lstate
                                  | `TRan of 'a TrackRank.lstate ];
                         .. >,
                       res)
                      cmonad
                  end
              module type FEATURES =
                sig
                  module Det : DETERMINANT
                  module PivotF : PIVOT
                  module PivotRep : PIVOTKIND
                  module Update : UPDATE
                  module Input : INPUT
                  module Output : OUTPUT
                end
              module GenGE :
                functor (F : FEATURES) ->
                  sig
                    module O :
                      sig
                        module IF :
                          sig
                            module R :
                              sig
                                type 'a tag_lstate = 'a TrackRank.tag_lstate_
                                val decl :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b TrackRank.tag_lstate ];
                                     .. >,
                                   int ref)
                                  TrackRank.lm
                                val succ :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b TrackRank.tag_lstate ];
                                     .. >,
                                   unit)
                                  TrackRank.lm
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> 'b TrackRank.tag_lstate ];
                                     .. >,
                                   int)
                                  TrackRank.lm
                              end
                            module P :
                              sig
                                type perm_rep = F.Output(F).IF.P.perm_rep
                                type 'a ira = ('a, int) Code.abstract
                                type 'a fra = 'a F.Output(F).IF.P.fra
                                type 'a pra = 'a F.Output(F).IF.P.pra
                                type 'a lstate = 'a F.Output(F).IF.P.lstate
                                type 'a pc_constraint = unit
                                  constraint 'a =
                                    < classif : 'b;
                                      state : [> `TPivot of 'b lstate ]; .. >
                                type ('a, 'b) lm = ('a, 'b) cmonad
                                  constraint 'a =
                                    < answer : 'c; classif : 'd;
                                      state : [> `TPivot of 'd lstate ]; .. >
                                type ('a, 'b) nm =
                                    (< answer : ('b, 'c) Code.abstract;
                                       state : 'd list >,
                                     unit)
                                    StateCPSMonad.monad
                                  constraint 'a =
                                    < answer : 'c; classif : 'b;
                                      state : [> `TPivot of 'b lstate ] as 'd;
                                      .. >
                                val rowrep : 'a ira -> 'a ira -> 'a fra
                                val colrep : 'a ira -> 'a ira -> 'a fra
                                val decl :
                                  ('a, int) Code.abstract ->
                                  (< answer : 'b; classif : 'a;
                                     state : [> `TPivot of 'a lstate ]; .. >,
                                   'a)
                                  nm
                                val add :
                                  'a fra ->
                                  (< answer : 'b; classif : 'a;
                                     state : [> `TPivot of 'a lstate ]; .. >,
                                   unit)
                                  omonad
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> `TPivot of 'b lstate ]; .. >,
                                   perm_rep)
                                  lm
                              end
                            module L :
                              sig
                                type 'a lstate = ('a, C.contr) Code.abstract
                                type ('a, 'b) lm = ('a, 'b) cmonad
                                  constraint 'a =
                                    < answer : 'c; classif : 'd;
                                      state : [> `TLower of 'd lstate ]; .. >
                                val decl :
                                  ('a, C.contr) Code.abstract ->
                                  (< answer : 'b; classif : 'a;
                                     state : [> `TLower of 'a lstate ]; .. >,
                                   C.contr)
                                  lm
                                val updt :
                                  'a C.vc ->
                                  ('a, int) Code.abstract ->
                                  ('a, int) Code.abstract ->
                                  'a C.vo ->
                                  'a C.Dom.vc ->
                                  (< answer : 'b; classif : 'a;
                                     state : [> `TLower of 'a lstate ]; .. >,
                                   unit)
                                  lm option
                                val fin :
                                  unit ->
                                  (< answer : 'a; classif : 'b;
                                     state : [> `TLower of 'b lstate ]; .. >,
                                   C.contr)
                                  lm
                                val wants_pack : bool
                              end
                          end
                        type res = F.Output(F).res
                        val make_result :
                          'a wmatrix ->
                          (< answer : 'b; classif : 'a;
                             state : [> `TDet of 'a F.Det.lstate
                                      | `TLower of 'a IF.L.lstate
                                      | `TPivot of 'a IF.P.lstate
                                      | `TRan of 'a TrackRank.lstate ];
                             .. >,
                           res)
                          cmonad
                      end
                    val wants_pack : bool
                    val can_pack : bool
                    val zerobelow :
                      'a wmatrix ->
                      'a curposval ->
                      ([> `TDet of 'a F.Det.lstate
                        | `TLower of ('a, C.contr) Code.abstract ]
                       as 'b)
                      list ->
                      ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                    val init :
                      ('a, F.Input.inp) Code.abstract ->
                      (< answer : ('a, 'b) Code.abstract;
                         state : [> `TDet of 'a F.Det.lstate
                                  | `TLower of ('a, C.contr) Code.abstract
                                  | `TPivot of 'a F.Output(F).IF.P.lstate
                                  | `TRan of 'a TrackRank.lstate ]
                                 list;
                         .. >,
                       'a wmatrix * ('a, int ref) Code.abstract *
                       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                      StateCPSMonad.monad
                    val forward_elim :
                      'a wmatrix * ('a, int ref) Code.abstract *
                      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                      ([> `TDet of 'a F.Det.lstate
                        | `TLower of ('a, C.contr) Code.abstract
                        | `TPivot of 'a F.Output(F).IF.P.lstate
                        | `TRan of 'a TrackRank.lstate ]
                       as 'b)
                      list ->
                      ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                    val gen :
                      ('a, F.Input.inp) Code.abstract ->
                      (< answer : ('a, 'b) Code.abstract;
                         state : [> `TDet of 'a F.Det.lstate
                                  | `TLower of 'a O.IF.L.lstate
                                  | `TPivot of 'a O.IF.P.lstate
                                  | `TRan of 'a TrackRank.lstate ]
                                 list;
                         .. >,
                       ('a, O.res) Code.abstract)
                      StateCPSMonad.monad
                  end
            end
          module Solve :
            sig
              module type INPUT =
                sig
                  type inp
                  type rhs = C.contr
                  val get_input :
                    ('a, inp) Code.abstract ->
                    (< answer : 'b; classif : 'a; state : 'c; .. >,
                     ('a, C.contr) Code.abstract * ('a, rhs) Code.abstract)
                    StateCPSMonad.monad
                end
              module InpMatrixVector :
                sig
                  type inp = C.contr * C.contr
                  type rhs = C.contr
                  val get_input :
                    ('a, 'b * 'c) Code.abstract ->
                    (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
                     ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
                    StateCPSMonad.monad
                end
              module type OUTPUT =
                sig
                  type res
                  val make_result :
                    ('a, C.contr) Code.abstract ->
                    ('a, C.contr) Code.abstract ->
                    ('a, int) Code.abstract ->
                    ('a, int) Code.abstract ->
                    ('a, int) Code.abstract ->
                    (< answer : 'b; classif : 'a; state : 'c; .. >, res)
                    cmonad
                end
              module OutJustAnswer :
                sig
                  type res = C.contr
                  val make_result :
                    'a C.vc ->
                    'a C.vc ->
                    ('a, int) Code.abstract ->
                    ('a, int) Code.abstract ->
                    ('a, int) Code.abstract ->
                    'b -> ('b -> ('a, C.contr) Code.abstract -> 'c) -> 'c
                end
              module type FEATURES =
                sig
                  module Det : DETERMINANT
                  module PivotF : PIVOT
                  module Input : INPUT
                  module Output : OUTPUT
                end
              module GenSolve :
                functor (F : FEATURES) ->
                  sig
                    module GE' :
                      sig
                        module O :
                          sig
                            module IF :
                              sig
                                module R :
                                  sig
                                    type 'a tag_lstate =
                                        'a TrackRank.tag_lstate_
                                    val decl :
                                      unit ->
                                      (< answer : 'a; classif : 'b;
                                         state : [> 'b TrackRank.tag_lstate ];
                                         .. >,
                                       int ref)
                                      TrackRank.lm
                                    val succ :
                                      unit ->
                                      (< answer : 'a; classif : 'b;
                                         state : [> 'b TrackRank.tag_lstate ];
                                         .. >,
                                       unit)
                                      TrackRank.lm
                                    val fin :
                                      unit ->
                                      (< answer : 'a; classif : 'b;
                                         state : [> 'b TrackRank.tag_lstate ];
                                         .. >,
                                       int)
                                      TrackRank.lm
                                  end
                                module P :
                                  sig
                                    type perm_rep = PermList.perm_rep
                                    type 'a ira = ('a, int) Code.abstract
                                    type 'a fra = 'a PermList.fra
                                    type 'a pra = 'a PermList.pra
                                    type 'a lstate =
                                        ('a, PermList.perm_rep ref)
                                        Code.abstract
                                    type 'a pc_constraint = unit
                                      constraint 'a =
                                        < classif : 'b;
                                          state : [> `TPivot of 'b lstate ];
                                          .. >
                                    type ('a, 'b) lm = ('a, 'b) cmonad
                                      constraint 'a =
                                        < answer : 'c; classif : 'd;
                                          state : [> `TPivot of 'd lstate ];
                                          .. >
                                    type ('a, 'b) nm =
                                        (< answer : ('b, 'c) Code.abstract;
                                           state : 'd list >,
                                         unit)
                                        StateCPSMonad.monad
                                      constraint 'a =
                                        < answer : 'c; classif : 'b;
                                          state : [> `TPivot of 'b lstate ]
                                                  as 'd;
                                          .. >
                                    val rowrep : 'a ira -> 'a ira -> 'a fra
                                    val colrep : 'a ira -> 'a ira -> 'a fra
                                    val decl :
                                      ('a, int) Code.abstract ->
                                      (< answer : 'b; classif : 'a;
                                         state : [> `TPivot of 'a lstate ];
                                         .. >,
                                       'a)
                                      nm
                                    val add :
                                      'a fra ->
                                      (< answer : 'b; classif : 'a;
                                         state : [> `TPivot of 'a lstate ];
                                         .. >,
                                       unit)
                                      omonad
                                    val fin :
                                      unit ->
                                      (< answer : 'a; classif : 'b;
                                         state : [> `TPivot of 'b lstate ];
                                         .. >,
                                       perm_rep)
                                      lm
                                  end
                                module L :
                                  sig
                                    type 'a lstate =
                                        ('a, C.contr) Code.abstract
                                    type ('a, 'b) lm = ('a, 'b) cmonad
                                      constraint 'a =
                                        < answer : 'c; classif : 'd;
                                          state : [> `TLower of 'd lstate ];
                                          .. >
                                    val decl :
                                      ('a, C.contr) Code.abstract ->
                                      (< answer : 'b; classif : 'a;
                                         state : [> `TLower of 'a lstate ];
                                         .. >,
                                       C.contr)
                                      lm
                                    val updt :
                                      'a C.vc ->
                                      ('a, int) Code.abstract ->
                                      ('a, int) Code.abstract ->
                                      'a C.vo ->
                                      'a C.Dom.vc ->
                                      (< answer : 'b; classif : 'a;
                                         state : [> `TLower of 'a lstate ];
                                         .. >,
                                       unit)
                                      lm option
                                    val fin :
                                      unit ->
                                      (< answer : 'a; classif : 'b;
                                         state : [> `TLower of 'b lstate ];
                                         .. >,
                                       C.contr)
                                      lm
                                    val wants_pack : bool
                                  end
                              end
                            type res = C.contr
                            val make_result :
                              'a wmatrix ->
                              (< answer : 'b; classif : 'a;
                                 state : [> `TDet of 'a F.Det.lstate
                                          | `TLower of 'a IF.L.lstate
                                          | `TPivot of 'a IF.P.lstate
                                          | `TRan of 'a TrackRank.lstate ];
                                 .. >,
                               res)
                              cmonad
                          end
                        val wants_pack : bool
                        val can_pack : bool
                        val zerobelow :
                          'a wmatrix ->
                          'a curposval ->
                          ([> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, C.contr) Code.abstract ]
                           as 'b)
                          list ->
                          ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                        val init :
                          ('a, C.contr * int) Code.abstract ->
                          (< answer : ('a, 'b) Code.abstract;
                             state : [> `TDet of 'a F.Det.lstate
                                      | `TLower of
                                          ('a, C.contr) Code.abstract
                                      | `TPivot of
                                          ('a, PermList.perm_rep ref)
                                          Code.abstract
                                      | `TRan of 'a TrackRank.lstate ]
                                     list;
                             .. >,
                           'a wmatrix * ('a, int ref) Code.abstract *
                           ('a, int ref) Code.abstract *
                           ('a, int) Code.abstract)
                          StateCPSMonad.monad
                        val forward_elim :
                          'a wmatrix * ('a, int ref) Code.abstract *
                          ('a, int ref) Code.abstract *
                          ('a, int) Code.abstract ->
                          ([> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, C.contr) Code.abstract
                            | `TPivot of
                                ('a, PermList.perm_rep ref) Code.abstract
                            | `TRan of 'a TrackRank.lstate ]
                           as 'b)
                          list ->
                          ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                        val gen :
                          ('a, C.contr * int) Code.abstract ->
                          (< answer : ('a, 'b) Code.abstract;
                             state : [> `TDet of 'a F.Det.lstate
                                      | `TLower of 'a O.IF.L.lstate
                                      | `TPivot of 'a O.IF.P.lstate
                                      | `TRan of 'a TrackRank.lstate ]
                                     list;
                             .. >,
                           ('a, O.res) Code.abstract)
                          StateCPSMonad.monad
                      end
                    val init :
                      ('a, F.Input.inp) Code.abstract ->
                      (< answer : 'b; state : 'c; .. >,
                       ('a, C.contr) Code.abstract *
                       ('a, F.Input.rhs) Code.abstract)
                      StateCPSMonad.monad
                    val back_elim :
                      'a C.vc ->
                      ('a, int) Code.abstract ->
                      ('a, int) Code.abstract ->
                      'b -> ('b -> ('a, C.contr) Code.abstract -> 'c) -> 'c
                    val gen :
                      ('a, F.Input.inp) Code.abstract ->
                      (< answer : ('a, 'b) Code.abstract;
                         state : [> `TDet of 'a F.Det.lstate
                                  | `TLower of 'a GE'.O.IF.L.lstate
                                  | `TPivot of 'a GE'.O.IF.P.lstate
                                  | `TRan of 'a TrackRank.lstate ]
                                 list;
                         .. >,
                       ('a, F.Output.res) Code.abstract)
                      StateCPSMonad.monad
                  end
            end
        end
  end
type 'a pr = { pf : 'b. ('b, 'a) code; }
#   val instantiate :
  (('a, 'b) code -> 'c list -> ('d -> 'e -> 'e) -> ('a, 'f) code) ->
  ('a, 'b -> 'f) code = <fun>
#   val runit : 'a pr -> 'a = <fun>
#   * * * * * * * * *     module Z3 :
  sig
    type v = int
    val kind : Domains_sig.domain_kind
    val zero : int
    val one : int
    val plus : int -> int -> int
    val times : int -> int -> int
    val minus : int -> int -> int
    val uminus : int -> int
    val extended_gcd : int -> int -> int * int
    val div : int -> int -> int
    val normalizer : 'a option
    val better_than : 'a option
    type 'a vc = ('a, v) code
    val zeroL : ('a, int) code
    val oneL : ('a, int) code
    val ( +^ ) : ('a, int) code -> ('a, int) code -> ('a, int) code
    val ( *^ ) : ('a, int) code -> ('a, int) code -> ('a, int) code
    val ( -^ ) : ('a, int) code -> ('a, int) code -> ('a, int) code
    val uminusL : ('a, int) code -> ('a, int) code
    val divL : ('a, int) code -> ('a, int) code -> ('a, int) code
    val normalizerL : 'a option
    val better_thanL : 'a option
  end
module Z19 :
  sig
    type v = int
    val kind : Domains_sig.domain_kind
    val zero : int
    val one : int
    val plus : int -> int -> int
    val times : int -> int -> int
    val minus : int -> int -> int
    val uminus : int -> int
    val extended_gcd : int -> int -> int * int
    val div : int -> int -> int
    val normalizer : 'a option
    val better_than : 'a option
    type 'a vc = ('a, v) code
    val zeroL : ('a, int) code
    val oneL : ('a, int) code
    val ( +^ ) : ('a, int) code -> ('a, int) code -> ('a, int) code
    val ( *^ ) : ('a, int) code -> ('a, int) code -> ('a, int) code
    val ( -^ ) : ('a, int) code -> ('a, int) code -> ('a, int) code
    val uminusL : ('a, int) code -> ('a, int) code
    val divL : ('a, int) code -> ('a, int) code -> ('a, int) code
    val normalizerL : 'a option
    val better_thanL : 'a option
  end
module GAC_F :
  sig
    module Dom :
      sig
        type v = Domains_code.FloatDomainL.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v array array
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 : ('a, 'b array) code -> ('a, int) code
    val dim1 : ('a, 'b array array) code -> ('a, int) code
    val mapper :
      ('a vo -> 'a vo) option ->
      ('a, Dom.v array array) code -> ('a, Dom.v array array) code
    val copy : ('a, 'b array array) code -> ('a, 'b array array) code
    val init :
      ('a, int) code -> ('a, int) code -> ('a, Dom.v array array) code
    val augment :
      ('a, 'b array array) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, 'b array array) code
    val identity :
      ('a, int) code -> ('a, int) code -> ('a, Dom.v array array) code
    val swap_rows_stmt :
      ('a, 'b array) code ->
      'c -> ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GVC_F :
  sig
    module Dom :
      sig
        type v = Domains_code.FloatDomainL.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v Domains_code.container2dfromvector
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val dim1 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val mapper :
      (('a, 'b) code -> ('a, 'b) code) option ->
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val copy :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val init :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val augment :
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val identity :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val index_default : ('a, int) code option -> ('a, int) code
    val swap_rows_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code option ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GAC_I :
  sig
    module Dom :
      sig
        type v = Domains_code.IntegerDomainL.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v array array
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 : ('a, 'b array) code -> ('a, int) code
    val dim1 : ('a, 'b array array) code -> ('a, int) code
    val mapper :
      ('a vo -> 'a vo) option ->
      ('a, Dom.v array array) code -> ('a, Dom.v array array) code
    val copy : ('a, 'b array array) code -> ('a, 'b array array) code
    val init :
      ('a, int) code -> ('a, int) code -> ('a, Dom.v array array) code
    val augment :
      ('a, 'b array array) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, 'b array array) code
    val identity :
      ('a, int) code -> ('a, int) code -> ('a, Dom.v array array) code
    val swap_rows_stmt :
      ('a, 'b array) code ->
      'c -> ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GVC_I :
  sig
    module Dom :
      sig
        type v = Domains_code.IntegerDomainL.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v Domains_code.container2dfromvector
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val dim1 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val mapper :
      (('a, 'b) code -> ('a, 'b) code) option ->
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val copy :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val init :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val augment :
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val identity :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val index_default : ('a, int) code option -> ('a, int) code
    val swap_rows_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code option ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GAC_R :
  sig
    module Dom :
      sig
        type v = Domains_code.RationalDomainL.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v array array
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 : ('a, 'b array) code -> ('a, int) code
    val dim1 : ('a, 'b array array) code -> ('a, int) code
    val mapper :
      ('a vo -> 'a vo) option ->
      ('a, Dom.v array array) code -> ('a, Dom.v array array) code
    val copy : ('a, 'b array array) code -> ('a, 'b array array) code
    val init :
      ('a, int) code -> ('a, int) code -> ('a, Dom.v array array) code
    val augment :
      ('a, 'b array array) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, 'b array array) code
    val identity :
      ('a, int) code -> ('a, int) code -> ('a, Dom.v array array) code
    val swap_rows_stmt :
      ('a, 'b array) code ->
      'c -> ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b array array) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GVC_Z3 :
  sig
    module Dom :
      sig
        type v = Z3.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v Domains_code.container2dfromvector
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val dim1 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val mapper :
      (('a, 'b) code -> ('a, 'b) code) option ->
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val copy :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val init :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val augment :
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val identity :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val index_default : ('a, int) code option -> ('a, int) code
    val swap_rows_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code option ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GVC_Z19 :
  sig
    module Dom :
      sig
        type v = Z19.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr = Dom.v Domains_code.container2dfromvector
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val dim2 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val dim1 :
      ('a, 'b Domains_code.container2dfromvector) code -> ('a, int) code
    val mapper :
      (('a, 'b) code -> ('a, 'b) code) option ->
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val copy :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, 'b Domains_code.container2dfromvector) code
    val init :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val augment :
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code ->
      ('a, int) code ->
      ('a, Dom.v Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val identity :
      ('a, int) code ->
      ('a, int) code -> ('a, Dom.v Domains_code.container2dfromvector) code
    val index_default : ('a, int) code option -> ('a, int) code
    val swap_rows_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code option ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code
    val col_head_set :
      ('a, 'b Domains_code.container2dfromvector) code ->
      ('a, int) code -> ('a, int) code -> ('a, 'b) code -> ('a, unit) code
  end
module GFC_F :
  sig
    module Dom :
      sig
        type v =
            Domains_code.FortranVectorContainer(Domains_code.FloatDomainL).Dom.v
        val kind : Domains_sig.domain_kind
        val zero : v
        val one : v
        val plus : v -> v -> v
        val times : v -> v -> v
        val minus : v -> v -> v
        val uminus : v -> v
        val div : v -> v -> v
        val better_than : (v -> v -> bool) option
        val normalizer : (v -> v) option
        type 'a vc = ('a, v) code
        val zeroL : 'a vc
        val oneL : 'a vc
        val ( +^ ) : 'a vc -> 'a vc -> 'a vc
        val ( *^ ) : 'a vc -> 'a vc -> 'a vc
        val ( -^ ) : 'a vc -> 'a vc -> 'a vc
        val uminusL : 'a vc -> 'a vc
        val divL : 'a vc -> 'a vc -> 'a vc
        val better_thanL : ('a vc -> 'a vc -> ('a, bool) code) option
        val normalizerL : ('a vc -> 'a vc) option
      end
    type contr =
        Domains_code.FortranVectorContainer(Domains_code.FloatDomainL).contr
    type 'a vc = ('a, contr) code
    type 'a vo = ('a, Dom.v) code
    val getL : 'a vc -> ('a, int) code -> ('a, int) code -> 'a vo
    val dim1 : 'a vc -> ('a, int) code
    val dim2 : 'a vc -> ('a, int) code
    val mapper : ('a vo -> 'a vo) option -> 'a vc -> 'a vc
    val copy : 'a vc -> 'a vc
    val init : ('a, int) code -> ('a, int) code -> 'a vc
    val augment :
      'a vc ->
      ('a, int) code -> ('a, int) code -> 'a vc -> ('a, int) code -> 'a vc
    val identity : ('a, int) code -> ('a, int) code -> 'a vc
    val swap_rows_stmt :
      'a vc ->
      ('a, int) code option ->
      ('a, int) code -> ('a, int) code -> ('a, unit) code
    val swap_cols_stmt :
      'a vc -> ('a, int) code -> ('a, int) code -> ('a, unit) code
    val row_head : 'a vc -> ('a, int) code -> ('a, int) code -> 'a vo
    val col_head_set :
      'a vc -> ('a, int) code -> ('a, int) code -> 'a vo -> ('a, unit) code
  end
module G_GAC_F :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GAC_F).wmatrix = {
      matrix : 'a GAC_F.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GAC_F).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GAC_F).curposval = {
      p : 'a curpos;
      curval : ('a, GAC_F.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GAC_F.Dom.v ref
        type 'a lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GAC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GAC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GAC_F.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GAC_F.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GAC_F.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GAC_F.contr)
          lm
        val updt :
          'a GAC_F.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GAC_F.vo ->
          'a GAC_F.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GAC_F.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GAC_F.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GAC_F.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GAC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GAC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GAC_F.Dom.v)
          lm
      end
    module AbstractDet :
      sig
        type tdet = GAC_F.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GAC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GAC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GAC_F.Dom.v)
          lm
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GAC_F.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GAC_F.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GAC_F.Dom.vc
              val update :
                'a GAC_F.Dom.vc ->
                'a GAC_F.Dom.vc ->
                'a GAC_F.Dom.vc ->
                'a GAC_F.Dom.vc ->
                ('a GAC_F.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GAC_F.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GAC_F.Dom.vc
              val update :
                'a GAC_F.Dom.vc ->
                'a GAC_F.Dom.vc ->
                'a GAC_F.Dom.vc ->
                'a GAC_F.Dom.vc ->
                ('a GAC_F.Dom.vc -> 'b) ->
                ('a, GAC_F.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GAC_F.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GAC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GAC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GAC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GAC_F.vo ->
              'a GAC_F.vo ->
              (< answer : 'b; state : [> `TLower of 'a GAC_F.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GAC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GAC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GAC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GAC_F.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GAC_F.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GAC_F.contr
            val get_input :
              'a GAC_F.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GAC_F.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GAC_F.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GAC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GAC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GAC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GAC_F.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr * GAC_F.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GAC_F.contr * GAC_F.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GAC_F.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr * GAC_F.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_F.contr * GAC_F.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr * GAC_F.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_F.contr * GAC_F.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_F.vo ->
                        'a GAC_F.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GAC_F.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr * GAC_F.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_F.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GAC_F.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type 'a pc_constraint = unit
                            constraint 'a =
                              < classif : 'b;
                                state : [> `TPivot of 'b lstate ]; .. >
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          type ('a, 'b) nm =
                              (< answer : ('b, 'c) Code.abstract;
                                 state : 'd list >,
                               unit)
                              StateCPSMonad.monad
                            constraint 'a =
                              < answer : 'c; classif : 'b;
                                state : [> `TPivot of 'b lstate ] as 'd; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             'a)
                            nm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GAC_F.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GAC_F.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GAC_F.contr)
                            lm
                          val updt :
                            'a GAC_F.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GAC_F.vo ->
                            'a GAC_F.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GAC_F.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GAC_F.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GAC_F.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GAC_F.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GAC_F.contr * GAC_F.contr
            type rhs = GAC_F.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GAC_F.contr) Code.abstract ->
              ('a, GAC_F.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GAC_F.contr
            val make_result :
              'a GAC_F.vc ->
              'a GAC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GAC_F.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type 'a pc_constraint = unit
                                constraint 'a =
                                  < classif : 'b;
                                    state : [> `TPivot of 'b lstate ]; .. >
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              type ('a, 'b) nm =
                                  (< answer : ('b, 'c) Code.abstract;
                                     state : 'd list >,
                                   unit)
                                  StateCPSMonad.monad
                                constraint 'a =
                                  < answer : 'c; classif : 'b;
                                    state : [> `TPivot of 'b lstate ] as 'd;
                                    .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 'a)
                                nm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GAC_F.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GAC_F.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GAC_F.contr)
                                lm
                              val updt :
                                'a GAC_F.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GAC_F.vo ->
                                'a GAC_F.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GAC_F.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GAC_F.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GAC_F.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GAC_F.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GAC_F.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GAC_F.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GAC_F.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GAC_F.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GAC_F.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GAC_F.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GVC_F :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GVC_F).wmatrix = {
      matrix : 'a GVC_F.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GVC_F).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GVC_F).curposval = {
      p : 'a curpos;
      curval : ('a, GVC_F.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GVC_F.Dom.v ref
        type 'a lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_F.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GVC_F.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GVC_F.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GVC_F.contr)
          lm
        val updt :
          'a GVC_F.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GVC_F.vo ->
          'a GVC_F.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GVC_F.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GVC_F.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GVC_F.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_F.Dom.v)
          lm
      end
    module AbstractDet :
      sig
        type tdet = GVC_F.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_F.Dom.v)
          lm
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GVC_F.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GVC_F.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_F.Dom.vc
              val update :
                'a GVC_F.Dom.vc ->
                'a GVC_F.Dom.vc ->
                'a GVC_F.Dom.vc ->
                'a GVC_F.Dom.vc ->
                ('a GVC_F.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_F.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_F.Dom.vc
              val update :
                'a GVC_F.Dom.vc ->
                'a GVC_F.Dom.vc ->
                'a GVC_F.Dom.vc ->
                'a GVC_F.Dom.vc ->
                ('a GVC_F.Dom.vc -> 'b) ->
                ('a, GVC_F.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_F.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GVC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GVC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GVC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_F.vo ->
              'a GVC_F.vo ->
              (< answer : 'b; state : [> `TLower of 'a GVC_F.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GVC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GVC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GVC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_F.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_F.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GVC_F.contr
            val get_input :
              'a GVC_F.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GVC_F.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GVC_F.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GVC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GVC_F.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr * GVC_F.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GVC_F.contr * GVC_F.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GVC_F.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr * GVC_F.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_F.contr * GVC_F.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr * GVC_F.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_F.contr * GVC_F.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_F.vo ->
                        'a GVC_F.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GVC_F.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr * GVC_F.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_F.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_F.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type 'a pc_constraint = unit
                            constraint 'a =
                              < classif : 'b;
                                state : [> `TPivot of 'b lstate ]; .. >
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          type ('a, 'b) nm =
                              (< answer : ('b, 'c) Code.abstract;
                                 state : 'd list >,
                               unit)
                              StateCPSMonad.monad
                            constraint 'a =
                              < answer : 'c; classif : 'b;
                                state : [> `TPivot of 'b lstate ] as 'd; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             'a)
                            nm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GVC_F.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GVC_F.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GVC_F.contr)
                            lm
                          val updt :
                            'a GVC_F.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GVC_F.vo ->
                            'a GVC_F.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GVC_F.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_F.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GVC_F.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GVC_F.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_F.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GVC_F.contr * GVC_F.contr
            type rhs = GVC_F.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GVC_F.contr) Code.abstract ->
              ('a, GVC_F.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GVC_F.contr
            val make_result :
              'a GVC_F.vc ->
              'a GVC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GVC_F.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type 'a pc_constraint = unit
                                constraint 'a =
                                  < classif : 'b;
                                    state : [> `TPivot of 'b lstate ]; .. >
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              type ('a, 'b) nm =
                                  (< answer : ('b, 'c) Code.abstract;
                                     state : 'd list >,
                                   unit)
                                  StateCPSMonad.monad
                                constraint 'a =
                                  < answer : 'c; classif : 'b;
                                    state : [> `TPivot of 'b lstate ] as 'd;
                                    .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 'a)
                                nm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GVC_F.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GVC_F.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GVC_F.contr)
                                lm
                              val updt :
                                'a GVC_F.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GVC_F.vo ->
                                'a GVC_F.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GVC_F.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GVC_F.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_F.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GVC_F.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GVC_F.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_F.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GVC_F.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GVC_F.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GVC_F.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GVC_F.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GAC_I :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GAC_I).wmatrix = {
      matrix : 'a GAC_I.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GAC_I).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GAC_I).curposval = {
      p : 'a curpos;
      curval : ('a, GAC_I.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GAC_I.Dom.v ref
        type 'a lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GAC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GAC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GAC_I.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GAC_I.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GAC_I.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GAC_I.contr)
          lm
        val updt :
          'a GAC_I.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GAC_I.vo ->
          'a GAC_I.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GAC_I.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GAC_I.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GAC_I.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GAC_I).NoDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GAC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GAC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GAC_I.Dom.v)
          lm
      end
    module AbstractDet :
      sig
        type tdet = GAC_I.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GAC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GAC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GAC_I.Dom.v)
          lm
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GAC_I.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GAC_I.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GAC_I.Dom.vc
              val update :
                'a GAC_I.Dom.vc ->
                'a GAC_I.Dom.vc ->
                'a GAC_I.Dom.vc ->
                'a GAC_I.Dom.vc ->
                ('a GAC_I.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GAC_I.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GAC_I.Dom.vc
              val update :
                'a GAC_I.Dom.vc ->
                'a GAC_I.Dom.vc ->
                'a GAC_I.Dom.vc ->
                'a GAC_I.Dom.vc ->
                ('a GAC_I.Dom.vc -> 'b) ->
                ('a, GAC_I.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GAC_I.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GAC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GAC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GAC_I.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GAC_I.vo ->
              'a GAC_I.vo ->
              (< answer : 'b; state : [> `TLower of 'a GAC_I.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GAC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GAC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GAC_I.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GAC_I.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GAC_I.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GAC_I.contr
            val get_input :
              'a GAC_I.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GAC_I.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GAC_I.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GAC_I.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GAC_I.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GAC_I.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GAC_I.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr * GAC_I.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GAC_I.contr * GAC_I.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GAC_I.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr * GAC_I.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_I.contr * GAC_I.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr * GAC_I.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_I.contr * GAC_I.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_I.vo ->
                        'a GAC_I.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GAC_I.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr * GAC_I.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_I.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GAC_I.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type 'a pc_constraint = unit
                            constraint 'a =
                              < classif : 'b;
                                state : [> `TPivot of 'b lstate ]; .. >
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          type ('a, 'b) nm =
                              (< answer : ('b, 'c) Code.abstract;
                                 state : 'd list >,
                               unit)
                              StateCPSMonad.monad
                            constraint 'a =
                              < answer : 'c; classif : 'b;
                                state : [> `TPivot of 'b lstate ] as 'd; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             'a)
                            nm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GAC_I.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GAC_I.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GAC_I.contr)
                            lm
                          val updt :
                            'a GAC_I.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GAC_I.vo ->
                            'a GAC_I.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GAC_I.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GAC_I.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GAC_I.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GAC_I.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GAC_I.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GAC_I.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GAC_I.contr * GAC_I.contr
            type rhs = GAC_I.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GAC_I.contr) Code.abstract ->
              ('a, GAC_I.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GAC_I.contr
            val make_result :
              'a GAC_I.vc ->
              'a GAC_I.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GAC_I.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type 'a pc_constraint = unit
                                constraint 'a =
                                  < classif : 'b;
                                    state : [> `TPivot of 'b lstate ]; .. >
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              type ('a, 'b) nm =
                                  (< answer : ('b, 'c) Code.abstract;
                                     state : 'd list >,
                                   unit)
                                  StateCPSMonad.monad
                                constraint 'a =
                                  < answer : 'c; classif : 'b;
                                    state : [> `TPivot of 'b lstate ] as 'd;
                                    .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 'a)
                                nm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GAC_I.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GAC_I.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GAC_I.contr)
                                lm
                              val updt :
                                'a GAC_I.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GAC_I.vo ->
                                'a GAC_I.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GAC_I.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GAC_I.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GAC_I.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GAC_I.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GAC_I.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GAC_I.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GAC_I.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GAC_I.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GAC_I.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GAC_I.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GVC_I :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GVC_I).wmatrix = {
      matrix : 'a GVC_I.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GVC_I).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GVC_I).curposval = {
      p : 'a curpos;
      curval : ('a, GVC_I.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GVC_I.Dom.v ref
        type 'a lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_I.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GVC_I.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GVC_I.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GVC_I.contr)
          lm
        val updt :
          'a GVC_I.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GVC_I.vo ->
          'a GVC_I.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GVC_I.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GVC_I.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GVC_I.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GVC_I).NoDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_I.Dom.v)
          lm
      end
    module AbstractDet :
      sig
        type tdet = GVC_I.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_I.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_I.Dom.v)
          lm
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GVC_I.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GVC_I.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_I.Dom.vc
              val update :
                'a GVC_I.Dom.vc ->
                'a GVC_I.Dom.vc ->
                'a GVC_I.Dom.vc ->
                'a GVC_I.Dom.vc ->
                ('a GVC_I.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_I.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_I.Dom.vc
              val update :
                'a GVC_I.Dom.vc ->
                'a GVC_I.Dom.vc ->
                'a GVC_I.Dom.vc ->
                'a GVC_I.Dom.vc ->
                ('a GVC_I.Dom.vc -> 'b) ->
                ('a, GVC_I.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_I.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GVC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GVC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GVC_I.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_I.vo ->
              'a GVC_I.vo ->
              (< answer : 'b; state : [> `TLower of 'a GVC_I.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GVC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GVC_I.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GVC_I.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_I.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_I.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GVC_I.contr
            val get_input :
              'a GVC_I.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GVC_I.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GVC_I.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_I.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_I.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GVC_I.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GVC_I.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr * GVC_I.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GVC_I.contr * GVC_I.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GVC_I.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr * GVC_I.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_I.contr * GVC_I.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_I.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr * GVC_I.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_I.contr * GVC_I.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_I.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_I.vo ->
                        'a GVC_I.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GVC_I.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr * GVC_I.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_I.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_I.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_I.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type 'a pc_constraint = unit
                            constraint 'a =
                              < classif : 'b;
                                state : [> `TPivot of 'b lstate ]; .. >
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          type ('a, 'b) nm =
                              (< answer : ('b, 'c) Code.abstract;
                                 state : 'd list >,
                               unit)
                              StateCPSMonad.monad
                            constraint 'a =
                              < answer : 'c; classif : 'b;
                                state : [> `TPivot of 'b lstate ] as 'd; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             'a)
                            nm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GVC_I.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GVC_I.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GVC_I.contr)
                            lm
                          val updt :
                            'a GVC_I.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GVC_I.vo ->
                            'a GVC_I.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GVC_I.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_I.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GVC_I.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GVC_I.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_I.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GVC_I.contr * GVC_I.contr
            type rhs = GVC_I.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GVC_I.contr) Code.abstract ->
              ('a, GVC_I.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GVC_I.contr
            val make_result :
              'a GVC_I.vc ->
              'a GVC_I.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GVC_I.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type 'a pc_constraint = unit
                                constraint 'a =
                                  < classif : 'b;
                                    state : [> `TPivot of 'b lstate ]; .. >
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              type ('a, 'b) nm =
                                  (< answer : ('b, 'c) Code.abstract;
                                     state : 'd list >,
                                   unit)
                                  StateCPSMonad.monad
                                constraint 'a =
                                  < answer : 'c; classif : 'b;
                                    state : [> `TPivot of 'b lstate ] as 'd;
                                    .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 'a)
                                nm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GVC_I.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GVC_I.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GVC_I.contr)
                                lm
                              val updt :
                                'a GVC_I.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GVC_I.vo ->
                                'a GVC_I.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GVC_I.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GVC_I.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_I.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GVC_I.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GVC_I.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_I.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GVC_I.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GVC_I.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GVC_I.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GVC_I.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GAC_R :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GAC_R).wmatrix = {
      matrix : 'a GAC_R.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GAC_R).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GAC_R).curposval = {
      p : 'a curpos;
      curval : ('a, GAC_R.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GAC_R.Dom.v ref
        type 'a lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GAC_R.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GAC_R.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GAC_R.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GAC_R.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GAC_R.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GAC_R.contr)
          lm
        val updt :
          'a GAC_R.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GAC_R.vo ->
          'a GAC_R.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GAC_R.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GAC_R.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GAC_R.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GAC_R).NoDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GAC_R.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GAC_R.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GAC_R.Dom.v)
          lm
      end
    module AbstractDet :
      sig
        type tdet = GAC_R.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GAC_R).AbstractDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GAC_R.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GAC_R.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GAC_R.Dom.v)
          lm
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GAC_R.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GAC_R.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GAC_R.Dom.vc
              val update :
                'a GAC_R.Dom.vc ->
                'a GAC_R.Dom.vc ->
                'a GAC_R.Dom.vc ->
                'a GAC_R.Dom.vc ->
                ('a GAC_R.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GAC_R.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GAC_R.Dom.vc
              val update :
                'a GAC_R.Dom.vc ->
                'a GAC_R.Dom.vc ->
                'a GAC_R.Dom.vc ->
                'a GAC_R.Dom.vc ->
                ('a GAC_R.Dom.vc -> 'b) ->
                ('a, GAC_R.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GAC_R.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GAC_R.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GAC_R.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GAC_R.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GAC_R.vo ->
              'a GAC_R.vo ->
              (< answer : 'b; state : [> `TLower of 'a GAC_R.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GAC_R.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GAC_R.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GAC_R.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GAC_R.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GAC_R.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GAC_R.contr
            val get_input :
              'a GAC_R.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GAC_R.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GAC_R.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GAC_R.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GAC_R.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GAC_R.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_R.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_R.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GAC_R.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_R.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_R.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr * GAC_R.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GAC_R.contr * GAC_R.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_R.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_R.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GAC_R.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_R.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_R.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr * GAC_R.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_R.contr * GAC_R.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_R.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_R.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr * GAC_R.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_R.contr * GAC_R.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GAC_R.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GAC_R.vo ->
                        'a GAC_R.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GAC_R.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr * GAC_R.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GAC_R.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GAC_R.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GAC_R.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type 'a pc_constraint = unit
                            constraint 'a =
                              < classif : 'b;
                                state : [> `TPivot of 'b lstate ]; .. >
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          type ('a, 'b) nm =
                              (< answer : ('b, 'c) Code.abstract;
                                 state : 'd list >,
                               unit)
                              StateCPSMonad.monad
                            constraint 'a =
                              < answer : 'c; classif : 'b;
                                state : [> `TPivot of 'b lstate ] as 'd; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             'a)
                            nm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GAC_R.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GAC_R.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GAC_R.contr)
                            lm
                          val updt :
                            'a GAC_R.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GAC_R.vo ->
                            'a GAC_R.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GAC_R.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GAC_R.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GAC_R.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GAC_R.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GAC_R.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GAC_R.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GAC_R.contr * GAC_R.contr
            type rhs = GAC_R.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GAC_R.contr) Code.abstract ->
              ('a, GAC_R.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GAC_R.contr
            val make_result :
              'a GAC_R.vc ->
              'a GAC_R.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GAC_R.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type 'a pc_constraint = unit
                                constraint 'a =
                                  < classif : 'b;
                                    state : [> `TPivot of 'b lstate ]; .. >
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              type ('a, 'b) nm =
                                  (< answer : ('b, 'c) Code.abstract;
                                     state : 'd list >,
                                   unit)
                                  StateCPSMonad.monad
                                constraint 'a =
                                  < answer : 'c; classif : 'b;
                                    state : [> `TPivot of 'b lstate ] as 'd;
                                    .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 'a)
                                nm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GAC_R.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GAC_R.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GAC_R.contr)
                                lm
                              val updt :
                                'a GAC_R.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GAC_R.vo ->
                                'a GAC_R.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GAC_R.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GAC_R.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GAC_R.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GAC_R.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GAC_R.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GAC_R.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GAC_R.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GAC_R.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GAC_R.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GAC_R.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GVC_Z3 :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GVC_Z3).wmatrix = {
      matrix : 'a GVC_Z3.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GVC_Z3).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GVC_Z3).curposval = {
      p : 'a curpos;
      curval : ('a, GVC_Z3.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GVC_Z3.Dom.v ref
        type 'a lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_Z3.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_Z3.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_Z3.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GVC_Z3.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GVC_Z3.contr)
          lm
        val updt :
          'a GVC_Z3.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GVC_Z3.vo ->
          'a GVC_Z3.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GVC_Z3.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GVC_Z3.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GVC_Z3.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GVC_Z3).NoDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_Z3.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_Z3.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_Z3.Dom.v)
          lm
      end
    module AbstractDet :
      sig
        type tdet = GVC_Z3.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GVC_Z3).AbstractDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_Z3.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_Z3.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_Z3.Dom.v)
          lm
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GVC_Z3.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GVC_Z3.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_Z3.Dom.vc
              val update :
                'a GVC_Z3.Dom.vc ->
                'a GVC_Z3.Dom.vc ->
                'a GVC_Z3.Dom.vc ->
                'a GVC_Z3.Dom.vc ->
                ('a GVC_Z3.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_Z3.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_Z3.Dom.vc
              val update :
                'a GVC_Z3.Dom.vc ->
                'a GVC_Z3.Dom.vc ->
                'a GVC_Z3.Dom.vc ->
                'a GVC_Z3.Dom.vc ->
                ('a GVC_Z3.Dom.vc -> 'b) ->
                ('a, GVC_Z3.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_Z3.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GVC_Z3.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_Z3.vo ->
              'a GVC_Z3.vo ->
              (< answer : 'b; state : [> `TLower of 'a GVC_Z3.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GVC_Z3.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_Z3.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_Z3.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GVC_Z3.contr
            val get_input :
              'a GVC_Z3.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GVC_Z3.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GVC_Z3.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_Z3.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_Z3.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GVC_Z3.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z3.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z3.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GVC_Z3.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z3.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z3.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr * GVC_Z3.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GVC_Z3.contr * GVC_Z3.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z3.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z3.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GVC_Z3.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z3.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z3.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr * GVC_Z3.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_Z3.contr * GVC_Z3.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z3.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z3.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr * GVC_Z3.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_Z3.contr * GVC_Z3.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z3.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z3.vo ->
                        'a GVC_Z3.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GVC_Z3.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr * GVC_Z3.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_Z3.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z3.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type 'a pc_constraint = unit
                            constraint 'a =
                              < classif : 'b;
                                state : [> `TPivot of 'b lstate ]; .. >
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          type ('a, 'b) nm =
                              (< answer : ('b, 'c) Code.abstract;
                                 state : 'd list >,
                               unit)
                              StateCPSMonad.monad
                            constraint 'a =
                              < answer : 'c; classif : 'b;
                                state : [> `TPivot of 'b lstate ] as 'd; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             'a)
                            nm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GVC_Z3.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GVC_Z3.contr)
                            lm
                          val updt :
                            'a GVC_Z3.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GVC_Z3.vo ->
                            'a GVC_Z3.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GVC_Z3.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_Z3.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GVC_Z3.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_Z3.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GVC_Z3.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_Z3.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GVC_Z3.contr * GVC_Z3.contr
            type rhs = GVC_Z3.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GVC_Z3.contr) Code.abstract ->
              ('a, GVC_Z3.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GVC_Z3.contr
            val make_result :
              'a GVC_Z3.vc ->
              'a GVC_Z3.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GVC_Z3.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type 'a pc_constraint = unit
                                constraint 'a =
                                  < classif : 'b;
                                    state : [> `TPivot of 'b lstate ]; .. >
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              type ('a, 'b) nm =
                                  (< answer : ('b, 'c) Code.abstract;
                                     state : 'd list >,
                                   unit)
                                  StateCPSMonad.monad
                                constraint 'a =
                                  < answer : 'c; classif : 'b;
                                    state : [> `TPivot of 'b lstate ] as 'd;
                                    .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 'a)
                                nm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GVC_Z3.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GVC_Z3.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GVC_Z3.contr)
                                lm
                              val updt :
                                'a GVC_Z3.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GVC_Z3.vo ->
                                'a GVC_Z3.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GVC_Z3.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GVC_Z3.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_Z3.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GVC_Z3.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GVC_Z3.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_Z3.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GVC_Z3.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GVC_Z3.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GVC_Z3.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GVC_Z3.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GVC_Z19 :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GVC_Z19).wmatrix = {
      matrix : 'a GVC_Z19.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GVC_Z19).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GVC_Z19).curposval = {
      p : 'a curpos;
      curval : ('a, GVC_Z19.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GVC_Z19.Dom.v ref
        type 'a lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_Z19.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_Z19.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_Z19.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GVC_Z19.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GVC_Z19.contr)
          lm
        val updt :
          'a GVC_Z19.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GVC_Z19.vo ->
          'a GVC_Z19.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GVC_Z19.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GVC_Z19.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GVC_Z19.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GVC_Z19).NoDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_Z19.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_Z19.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_Z19.Dom.v)
          lm
      end
    module AbstractDet :
      sig
        type tdet = GVC_Z19.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GVC_Z19).AbstractDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GVC_Z19.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GVC_Z19.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GVC_Z19.Dom.v)
          lm
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GVC_Z19.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GVC_Z19.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_Z19.Dom.vc
              val update :
                'a GVC_Z19.Dom.vc ->
                'a GVC_Z19.Dom.vc ->
                'a GVC_Z19.Dom.vc ->
                'a GVC_Z19.Dom.vc ->
                ('a GVC_Z19.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_Z19.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GVC_Z19.Dom.vc
              val update :
                'a GVC_Z19.Dom.vc ->
                'a GVC_Z19.Dom.vc ->
                'a GVC_Z19.Dom.vc ->
                'a GVC_Z19.Dom.vc ->
                ('a GVC_Z19.Dom.vc -> 'b) ->
                ('a, GVC_Z19.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GVC_Z19.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GVC_Z19.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_Z19.vo ->
              'a GVC_Z19.vo ->
              (< answer : 'b; state : [> `TLower of 'a GVC_Z19.vc ] list;
                 .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GVC_Z19.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GVC_Z19.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_Z19.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GVC_Z19.contr
            val get_input :
              'a GVC_Z19.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GVC_Z19.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GVC_Z19.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_Z19.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GVC_Z19.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GVC_Z19.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z19.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z19.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GVC_Z19.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z19.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z19.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr * GVC_Z19.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GVC_Z19.contr * GVC_Z19.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z19.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z19.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GVC_Z19.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z19.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z19.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr * GVC_Z19.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_Z19.contr * GVC_Z19.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z19.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z19.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr * GVC_Z19.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_Z19.contr * GVC_Z19.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GVC_Z19.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GVC_Z19.vo ->
                        'a GVC_Z19.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GVC_Z19.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr * GVC_Z19.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GVC_Z19.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GVC_Z19.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type 'a pc_constraint = unit
                            constraint 'a =
                              < classif : 'b;
                                state : [> `TPivot of 'b lstate ]; .. >
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          type ('a, 'b) nm =
                              (< answer : ('b, 'c) Code.abstract;
                                 state : 'd list >,
                               unit)
                              StateCPSMonad.monad
                            constraint 'a =
                              < answer : 'c; classif : 'b;
                                state : [> `TPivot of 'b lstate ] as 'd; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             'a)
                            nm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GVC_Z19.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GVC_Z19.contr)
                            lm
                          val updt :
                            'a GVC_Z19.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GVC_Z19.vo ->
                            'a GVC_Z19.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GVC_Z19.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_Z19.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GVC_Z19.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GVC_Z19.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GVC_Z19.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GVC_Z19.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GVC_Z19.contr * GVC_Z19.contr
            type rhs = GVC_Z19.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GVC_Z19.contr) Code.abstract ->
              ('a, GVC_Z19.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GVC_Z19.contr
            val make_result :
              'a GVC_Z19.vc ->
              'a GVC_Z19.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GVC_Z19.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type 'a pc_constraint = unit
                                constraint 'a =
                                  < classif : 'b;
                                    state : [> `TPivot of 'b lstate ]; .. >
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              type ('a, 'b) nm =
                                  (< answer : ('b, 'c) Code.abstract;
                                     state : 'd list >,
                                   unit)
                                  StateCPSMonad.monad
                                constraint 'a =
                                  < answer : 'c; classif : 'b;
                                    state : [> `TPivot of 'b lstate ] as 'd;
                                    .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 'a)
                                nm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GVC_Z19.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GVC_Z19.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GVC_Z19.contr)
                                lm
                              val updt :
                                'a GVC_Z19.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GVC_Z19.vo ->
                                'a GVC_Z19.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GVC_Z19.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GVC_Z19.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_Z19.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GVC_Z19.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of
                                    ('a, GVC_Z19.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GVC_Z19.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GVC_Z19.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GVC_Z19.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GVC_Z19.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GVC_Z19.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module G_GFC_F :
  sig
    type 'a wmatrix =
      'a Ge.LAMake(Code).GenLA(GFC_F).wmatrix = {
      matrix : 'a GFC_F.vc;
      numrow : ('a, int) Code.abstract;
      numcol : ('a, int) Code.abstract;
    }
    type 'a curpos =
      'a Ge.LAMake(Code).GenLA(GFC_F).curpos = {
      rowpos : ('a, int) Code.abstract;
      colpos : ('a, int) Code.abstract;
    }
    type 'a curposval =
      'a Ge.LAMake(Code).GenLA(GFC_F).curposval = {
      p : 'a curpos;
      curval : ('a, GFC_F.Dom.v) Code.abstract;
    }
    module type DETERMINANT =
      sig
        type tdet = GFC_F.Dom.v ref
        type 'a lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GFC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GFC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GFC_F.Dom.v)
          lm
      end
    module type LOWER =
      sig
        type 'a lstate = ('a, GFC_F.contr) Code.abstract
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TLower of 'd lstate ];
              .. >
        val decl :
          ('a, GFC_F.contr) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           GFC_F.contr)
          lm
        val updt :
          'a GFC_F.vc ->
          ('a, int) Code.abstract ->
          ('a, int) Code.abstract ->
          'a GFC_F.vo ->
          'a GFC_F.Dom.vc ->
          (< answer : 'b; classif : 'a; state : [> `TLower of 'a lstate ];
             .. >,
           unit)
          lm option
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TLower of 'b lstate ];
             .. >,
           GFC_F.contr)
          lm
        val wants_pack : bool
      end
    module type PIVOT =
      functor (D : DETERMINANT) ->
        functor (P : GEF.TRACKPIVOT) ->
          functor (L : LOWER) ->
            sig
              val findpivot :
                'a wmatrix ->
                'a curpos ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a D.lstate | `TPivot of 'a P.lstate ];
                   .. >,
                 GFC_F.Dom.v option)
                GEF.cmonad
            end
    module NoDet :
      sig
        type tdet = GFC_F.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GFC_F).NoDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GFC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GFC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GFC_F.Dom.v)
          lm
      end
    module AbstractDet :
      sig
        type tdet = GFC_F.Dom.v ref
        type 'a lstate = 'a Ge.LAMake(Code).GenLA(GFC_F).AbstractDet.lstate
        type 'a pc_constraint = unit
          constraint 'a =
            < classif : 'b; state : [> `TDet of 'b lstate ]; .. >
        type ('a, 'b) lm = ('a, 'b) GEF.cmonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type ('a, 'b) om = ('a, 'b) GEF.omonad
          constraint 'a =
            < answer : 'c; classif : 'd; state : [> `TDet of 'd lstate ];
              .. >
        type 'a nm =
            (< answer : ('c, 'b) Code.abstract; state : 'd list >, unit)
            StateCPSMonad.monad
          constraint 'a =
            < answer : 'b; classif : 'c;
              state : [> `TDet of 'c lstate ] as 'd; .. >
        val decl :
          unit ->
          < answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >
          nm
        val upd_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          om
        val zero_sign :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           unit)
          lm
        val acc_magn :
          ('a, GFC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val get_magn :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           tdet)
          lm
        val set_magn :
          ('a, GFC_F.Dom.v) Code.abstract ->
          (< answer : 'b; classif : 'a; state : [> `TDet of 'a lstate ]; .. >,
           unit)
          lm
        val fin :
          unit ->
          (< answer : 'a; classif : 'b; state : [> `TDet of 'b lstate ]; .. >,
           GFC_F.Dom.v)
          lm
      end
    module type UPDATE =
      functor (D : DETERMINANT) ->
        sig
          type 'a in_val = 'a GFC_F.Dom.vc
          val update :
            'a in_val ->
            'a in_val ->
            'a in_val ->
            'a in_val ->
            ('a in_val -> ('a, unit) Code.abstract) ->
            ('a, GFC_F.Dom.v ref) Code.abstract ->
            (< answer : 'b; classif : 'a; state : 'c; .. >, unit) GEF.cmonad
          val update_det :
            'a in_val ->
            (< answer : 'b; classif : 'a; state : [> `TDet of 'a D.lstate ];
               .. >,
             unit)
            D.lm
          val upd_kind : Ge.update_kind
        end
    module GE :
      sig
        module DivisionUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GFC_F.Dom.vc
              val update :
                'a GFC_F.Dom.vc ->
                'a GFC_F.Dom.vc ->
                'a GFC_F.Dom.vc ->
                'a GFC_F.Dom.vc ->
                ('a GFC_F.Dom.vc -> 'b) ->
                'c ->
                (< answer : 'd; state : 'e; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GFC_F.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module FractionFreeUpdate :
          functor (Det : DETERMINANT) ->
            sig
              type 'a in_val = 'a GFC_F.Dom.vc
              val update :
                'a GFC_F.Dom.vc ->
                'a GFC_F.Dom.vc ->
                'a GFC_F.Dom.vc ->
                'a GFC_F.Dom.vc ->
                ('a GFC_F.Dom.vc -> 'b) ->
                ('a, GFC_F.Dom.v ref) Code.abstract ->
                (< answer : 'c; state : 'd; .. >, 'b) StateCPSMonad.monad
              val update_det :
                ('a, GFC_F.Dom.v) Code.abstract ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a Det.lstate ]; .. >,
                 unit)
                Det.lm
              val upd_kind : Ge.update_kind
            end
        module TrackLower :
          sig
            type 'a lstate = ('a, GFC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
          end
        module SeparateLower :
          sig
            type 'a lstate = ('a, GFC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              ('a, 'b) Code.abstract ->
              (< answer : ('a, 'c) Code.abstract;
                 state : [> `TLower of ('a, 'b) Code.abstract ] list; .. >,
               ('a, 'b) Code.abstract)
              StateCPSMonad.monad
            val updt :
              'a GFC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GFC_F.vo ->
              'a GFC_F.vo ->
              (< answer : 'b; state : [> `TLower of 'a GFC_F.vc ] list; .. >,
               ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module PackedLower :
          sig
            type 'a lstate = ('a, GFC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a ->
              (< answer : 'b; state : [> `TLower of 'a ] list; .. >, 'a)
              StateCPSMonad.monad
            val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
            val fin :
              unit ->
              (< answer : 'a; state : [> `TLower of 'b ] list; .. >, 'b)
              StateCPSMonad.monad
            val wants_pack : bool
          end
        module NoLower :
          sig
            type 'a lstate = ('a, GFC_F.contr) Code.abstract
            type ('a, 'b) lm = ('a, 'b) GEF.cmonad
              constraint 'a =
                < answer : 'c; classif : 'd;
                  state : [> `TLower of 'd lstate ]; .. >
            val ip :
              ('a -> [> `TLower of 'a ]) *
              ([> `TLower of 'b ] -> 'b option) * string
            val decl :
              'a -> (< answer : 'b; state : 'c; .. >, 'a) StateCPSMonad.monad
            val updt :
              'a GFC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'a GFC_F.vo ->
              'b ->
              (< answer : 'c; state : 'd; .. >, ('a, unit) Code.abstract)
              StateCPSMonad.monad option
            val fin : unit -> 'a
            val wants_pack : bool
          end
        module type INPUT =
          sig
            type inp
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GFC_F.contr) Code.abstract * ('a, int) Code.abstract *
               bool)
              StateCPSMonad.monad
          end
        module InpJustMatrix :
          sig
            type inp = GFC_F.contr
            val get_input :
              'a GFC_F.vc ->
              (< answer : 'b; state : 'c; .. >,
               'a GFC_F.vc * ('a, int) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module InpMatrixMargin :
          sig
            type inp = GFC_F.contr * int
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : 'd; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract * bool)
              StateCPSMonad.monad
          end
        module RowPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GFC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module FullPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val optim : 'a -> 'a option
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a Det.lstate
                                | `TPivot of 'a P.lstate ]
                               list;
                       .. >,
                     ('a, GFC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module NoPivot :
          functor (Det : DETERMINANT) ->
            functor (P : GEF.TRACKPIVOT) ->
              functor (L : LOWER) ->
                sig
                  val findpivot :
                    'a wmatrix ->
                    'a curpos ->
                    (< answer : 'b; state : 'c; .. >,
                     ('a, GFC_F.Dom.v option) Code.abstract)
                    StateCPSMonad.monad
                end
        module type OUTPUTDEP =
          sig module PivotRep : GEF.PIVOTKIND module Det : DETERMINANT end
        module OutJustMatrix :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GFC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GFC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr
              val make_result :
                'a wmatrix ->
                (< answer : 'b; state : 'c; .. >, 'a GFC_F.vc)
                StateCPSMonad.monad
            end
        module OutDet :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GFC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GFC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr * GFC_F.Dom.v
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate ] list; .. >,
                 ('a, GFC_F.contr * GFC_F.Dom.v) Code.abstract)
                StateCPSMonad.monad
            end
        module OutRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GFC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GFC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr * int
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TRan of ('a, 'c ref) Code.abstract ] list;
                   .. >,
                 ('a, GFC_F.contr * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRank :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = GEF.PermList.perm_rep
                      type 'a ira = 'a GEF.PermList.ira
                      type 'a fra = 'a GEF.PermList.fra
                      type 'a pra = 'a GEF.PermList.pra
                      type 'a lstate =
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val colrep :
                        'a GEF.PermList.ira ->
                        'a GEF.PermList.ira -> 'a GEF.PermList.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, unit)
                        StateCPSMonad.monad
                      val add :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'd option)
                        StateCPSMonad.monad
                      val fin : unit -> 'a
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GFC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GFC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr * GFC_F.Dom.v * int
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TRan of ('a, 'c ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GFC_F.contr * GFC_F.Dom.v * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module OutDetRankPivot :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : 'c; .. >, 'a)
                        StateCPSMonad.monad
                      val updt :
                        'a GFC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GFC_F.vo ->
                        'b ->
                        (< answer : 'c; state : 'd; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin : unit -> 'a
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr * GFC_F.Dom.v * int * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TPivot of ('a, 'c ref) Code.abstract
                            | `TRan of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GFC_F.contr * GFC_F.Dom.v * 'd * 'c) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_L_U :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        ('a, 'b) Code.abstract ->
                        (< answer : ('a, 'c) Code.abstract;
                           state : [> `TLower of ('a, 'b) Code.abstract ]
                                   list;
                           .. >,
                         ('a, 'b) Code.abstract)
                        StateCPSMonad.monad
                      val updt :
                        'a GFC_F.vc ->
                        ('a, int) Code.abstract ->
                        ('a, int) Code.abstract ->
                        'a GFC_F.vo ->
                        'a GFC_F.vo ->
                        (< answer : 'b;
                           state : [> `TLower of 'a GFC_F.vc ] list; .. >,
                         ('a, unit) Code.abstract)
                        StateCPSMonad.monad option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr * GFC_F.contr * IF.P.perm_rep
              val make_result :
                'a wmatrix ->
                (< answer : 'b;
                   state : [> `TLower of ('a, 'c) Code.abstract
                            | `TPivot of ('a, 'd ref) Code.abstract ]
                           list;
                   .. >,
                 ('a, GFC_F.contr * 'c * 'd) Code.abstract)
                StateCPSMonad.monad
            end
        module Out_LU_Packed :
          functor (OD : OUTPUTDEP) ->
            sig
              module IF :
                sig
                  module R :
                    sig
                      type 'a lstate = ('a, int ref) Code.abstract
                      type 'a tag_lstate_ = [ `TRan of 'a lstate ]
                      type 'a tag_lstate = 'a tag_lstate_
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> 'd tag_lstate ]; .. >
                      val ip :
                        ('a -> [> `TRan of 'a ]) *
                        ([> `TRan of 'b ] -> 'b option) * string
                      val decl :
                        unit ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TRan of ('a, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('a, int ref) Code.abstract)
                        StateCPSMonad.monad
                      val succ :
                        unit ->
                        (< answer : 'a;
                           state : [> `TRan of ('b, int ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, unit) Code.abstract)
                        StateCPSMonad.monad
                      module type RANK =
                        sig
                          type 'a tag_lstate = 'a tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int ref)
                            lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             unit)
                            lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b tag_lstate ]; .. >,
                             int)
                            lm
                        end
                      val fin : unit -> 'a
                    end
                  module P :
                    sig
                      type perm_rep = OD.PivotRep.perm_rep
                      type 'a ira = 'a OD.PivotRep.ira
                      type 'a fra = 'a OD.PivotRep.fra
                      type 'a pra = 'a OD.PivotRep.pra
                      type 'a lstate =
                          ('a, OD.PivotRep.perm_rep ref) Code.abstract
                      type 'a pc_constraint = unit
                        constraint 'a =
                          < classif : 'b; state : [> `TPivot of 'b lstate ];
                            .. >
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TPivot of 'd lstate ]; .. >
                      type ('a, 'b) nm =
                          (< answer : ('b, 'c) Code.abstract;
                             state : 'd list >,
                           unit)
                          StateCPSMonad.monad
                        constraint 'a =
                          < answer : 'c; classif : 'b;
                            state : [> `TPivot of 'b lstate ] as 'd; .. >
                      val rowrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val colrep :
                        'a OD.PivotRep.ira ->
                        'a OD.PivotRep.ira -> 'a OD.PivotRep.fra
                      val ip :
                        ('a -> [> `TPivot of 'a ]) *
                        ([> `TPivot of 'b ] -> 'b option) * string
                      val decl :
                        'a OD.PivotRep.ira ->
                        (< answer : ('a, 'b) Code.abstract;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         unit)
                        StateCPSMonad.monad
                      val add :
                        'a OD.PivotRep.fra ->
                        (< answer : 'b;
                           state : [> `TPivot of
                                        ('a, OD.PivotRep.perm_rep ref)
                                        Code.abstract ]
                                   list;
                           .. >,
                         ('a, unit) Code.abstract option)
                        StateCPSMonad.monad
                      val fin :
                        unit ->
                        (< answer : 'a;
                           state : [> `TPivot of ('b, 'c ref) Code.abstract ]
                                   list;
                           .. >,
                         ('b, 'c) Code.abstract)
                        StateCPSMonad.monad
                    end
                  module L :
                    sig
                      type 'a lstate = ('a, GFC_F.contr) Code.abstract
                      type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                        constraint 'a =
                          < answer : 'c; classif : 'd;
                            state : [> `TLower of 'd lstate ]; .. >
                      val ip :
                        ('a -> [> `TLower of 'a ]) *
                        ([> `TLower of 'b ] -> 'b option) * string
                      val decl :
                        'a ->
                        (< answer : 'b; state : [> `TLower of 'a ] list; .. >,
                         'a)
                        StateCPSMonad.monad
                      val updt : 'a -> 'b -> 'c -> 'd -> 'e -> 'f option
                      val fin :
                        unit ->
                        (< answer : 'a; state : [> `TLower of 'b ] list; .. >,
                         'b)
                        StateCPSMonad.monad
                      val wants_pack : bool
                    end
                end
              type res = GFC_F.contr * IF.P.perm_rep
              val make_result :
                'a ->
                (< answer : 'b;
                   state : [> `TLower of ('c, 'd) Code.abstract
                            | `TPivot of ('c, 'e ref) Code.abstract ]
                           list;
                   .. >,
                 ('c, 'd * 'e) Code.abstract)
                StateCPSMonad.monad
            end
        module type INTERNAL_FEATURES =
          sig
            module R : GEF.TrackRank.RANK
            module P : GEF.TRACKPIVOT
            module L : LOWER
          end
        module type OUTPUT =
          functor (OD : OUTPUTDEP) ->
            sig
              module IF : INTERNAL_FEATURES
              type res
              val make_result :
                'a wmatrix ->
                (< answer : 'b; classif : 'a;
                   state : [> `TDet of 'a OD.Det.lstate
                            | `TLower of 'a IF.L.lstate
                            | `TPivot of 'a IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ];
                   .. >,
                 res)
                GEF.cmonad
            end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module PivotRep : GEF.PIVOTKIND
            module Update : UPDATE
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenGE :
          functor (F : FEATURES) ->
            sig
              module O :
                sig
                  module IF :
                    sig
                      module R :
                        sig
                          type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                          val decl :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int ref)
                            GEF.TrackRank.lm
                          val succ :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             unit)
                            GEF.TrackRank.lm
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                             int)
                            GEF.TrackRank.lm
                        end
                      module P :
                        sig
                          type perm_rep = F.Output(F).IF.P.perm_rep
                          type 'a ira = ('a, int) Code.abstract
                          type 'a fra = 'a F.Output(F).IF.P.fra
                          type 'a pra = 'a F.Output(F).IF.P.pra
                          type 'a lstate = 'a F.Output(F).IF.P.lstate
                          type 'a pc_constraint = unit
                            constraint 'a =
                              < classif : 'b;
                                state : [> `TPivot of 'b lstate ]; .. >
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TPivot of 'd lstate ]; .. >
                          type ('a, 'b) nm =
                              (< answer : ('b, 'c) Code.abstract;
                                 state : 'd list >,
                               unit)
                              StateCPSMonad.monad
                            constraint 'a =
                              < answer : 'c; classif : 'b;
                                state : [> `TPivot of 'b lstate ] as 'd; .. >
                          val rowrep : 'a ira -> 'a ira -> 'a fra
                          val colrep : 'a ira -> 'a ira -> 'a fra
                          val decl :
                            ('a, int) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             'a)
                            nm
                          val add :
                            'a fra ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TPivot of 'a lstate ]; .. >,
                             unit)
                            GEF.omonad
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TPivot of 'b lstate ]; .. >,
                             perm_rep)
                            lm
                        end
                      module L :
                        sig
                          type 'a lstate = ('a, GFC_F.contr) Code.abstract
                          type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                            constraint 'a =
                              < answer : 'c; classif : 'd;
                                state : [> `TLower of 'd lstate ]; .. >
                          val decl :
                            ('a, GFC_F.contr) Code.abstract ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             GFC_F.contr)
                            lm
                          val updt :
                            'a GFC_F.vc ->
                            ('a, int) Code.abstract ->
                            ('a, int) Code.abstract ->
                            'a GFC_F.vo ->
                            'a GFC_F.Dom.vc ->
                            (< answer : 'b; classif : 'a;
                               state : [> `TLower of 'a lstate ]; .. >,
                             unit)
                            lm option
                          val fin :
                            unit ->
                            (< answer : 'a; classif : 'b;
                               state : [> `TLower of 'b lstate ]; .. >,
                             GFC_F.contr)
                            lm
                          val wants_pack : bool
                        end
                    end
                  type res = F.Output(F).res
                  val make_result :
                    'a wmatrix ->
                    (< answer : 'b; classif : 'a;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a IF.L.lstate
                                | `TPivot of 'a IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ];
                       .. >,
                     res)
                    GEF.cmonad
                end
              val wants_pack : bool
              val can_pack : bool
              val zerobelow :
                'a wmatrix ->
                'a curposval ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GFC_F.contr) Code.abstract ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of ('a, GFC_F.contr) Code.abstract
                            | `TPivot of 'a F.Output(F).IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 'a wmatrix * ('a, int ref) Code.abstract *
                 ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                StateCPSMonad.monad
              val forward_elim :
                'a wmatrix * ('a, int ref) Code.abstract *
                ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                ([> `TDet of 'a F.Det.lstate
                  | `TLower of ('a, GFC_F.contr) Code.abstract
                  | `TPivot of 'a F.Output(F).IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 as 'b)
                list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a O.IF.L.lstate
                            | `TPivot of 'a O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, O.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
    module Solve :
      sig
        module type INPUT =
          sig
            type inp
            type rhs = GFC_F.contr
            val get_input :
              ('a, inp) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >,
               ('a, GFC_F.contr) Code.abstract * ('a, rhs) Code.abstract)
              StateCPSMonad.monad
          end
        module InpMatrixVector :
          sig
            type inp = GFC_F.contr * GFC_F.contr
            type rhs = GFC_F.contr
            val get_input :
              ('a, 'b * 'c) Code.abstract ->
              (< answer : ('a, 'd) Code.abstract; state : 'e; .. >,
               ('a, 'b) Code.abstract * ('a, 'c) Code.abstract)
              StateCPSMonad.monad
          end
        module type OUTPUT =
          sig
            type res
            val make_result :
              ('a, GFC_F.contr) Code.abstract ->
              ('a, GFC_F.contr) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              (< answer : 'b; classif : 'a; state : 'c; .. >, res) GEF.cmonad
          end
        module OutJustAnswer :
          sig
            type res = GFC_F.contr
            val make_result :
              'a GFC_F.vc ->
              'a GFC_F.vc ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              ('a, int) Code.abstract ->
              'b -> ('b -> ('a, GFC_F.contr) Code.abstract -> 'c) -> 'c
          end
        module type FEATURES =
          sig
            module Det : DETERMINANT
            module PivotF : PIVOT
            module Input : INPUT
            module Output : OUTPUT
          end
        module GenSolve :
          functor (F : FEATURES) ->
            sig
              module GE' :
                sig
                  module O :
                    sig
                      module IF :
                        sig
                          module R :
                            sig
                              type 'a tag_lstate =
                                  'a GEF.TrackRank.tag_lstate_
                              val decl :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int ref)
                                GEF.TrackRank.lm
                              val succ :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 unit)
                                GEF.TrackRank.lm
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> 'b GEF.TrackRank.tag_lstate ];
                                   .. >,
                                 int)
                                GEF.TrackRank.lm
                            end
                          module P :
                            sig
                              type perm_rep = GEF.PermList.perm_rep
                              type 'a ira = ('a, int) Code.abstract
                              type 'a fra = 'a GEF.PermList.fra
                              type 'a pra = 'a GEF.PermList.pra
                              type 'a lstate =
                                  ('a, GEF.PermList.perm_rep ref)
                                  Code.abstract
                              type 'a pc_constraint = unit
                                constraint 'a =
                                  < classif : 'b;
                                    state : [> `TPivot of 'b lstate ]; .. >
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TPivot of 'd lstate ]; .. >
                              type ('a, 'b) nm =
                                  (< answer : ('b, 'c) Code.abstract;
                                     state : 'd list >,
                                   unit)
                                  StateCPSMonad.monad
                                constraint 'a =
                                  < answer : 'c; classif : 'b;
                                    state : [> `TPivot of 'b lstate ] as 'd;
                                    .. >
                              val rowrep : 'a ira -> 'a ira -> 'a fra
                              val colrep : 'a ira -> 'a ira -> 'a fra
                              val decl :
                                ('a, int) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 'a)
                                nm
                              val add :
                                'a fra ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TPivot of 'a lstate ]; .. >,
                                 unit)
                                GEF.omonad
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TPivot of 'b lstate ]; .. >,
                                 perm_rep)
                                lm
                            end
                          module L :
                            sig
                              type 'a lstate =
                                  ('a, GFC_F.contr) Code.abstract
                              type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                                constraint 'a =
                                  < answer : 'c; classif : 'd;
                                    state : [> `TLower of 'd lstate ]; .. >
                              val decl :
                                ('a, GFC_F.contr) Code.abstract ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 GFC_F.contr)
                                lm
                              val updt :
                                'a GFC_F.vc ->
                                ('a, int) Code.abstract ->
                                ('a, int) Code.abstract ->
                                'a GFC_F.vo ->
                                'a GFC_F.Dom.vc ->
                                (< answer : 'b; classif : 'a;
                                   state : [> `TLower of 'a lstate ]; .. >,
                                 unit)
                                lm option
                              val fin :
                                unit ->
                                (< answer : 'a; classif : 'b;
                                   state : [> `TLower of 'b lstate ]; .. >,
                                 GFC_F.contr)
                                lm
                              val wants_pack : bool
                            end
                        end
                      type res = GFC_F.contr
                      val make_result :
                        'a wmatrix ->
                        (< answer : 'b; classif : 'a;
                           state : [> `TDet of 'a F.Det.lstate
                                    | `TLower of 'a IF.L.lstate
                                    | `TPivot of 'a IF.P.lstate
                                    | `TRan of 'a GEF.TrackRank.lstate ];
                           .. >,
                         res)
                        GEF.cmonad
                    end
                  val wants_pack : bool
                  val can_pack : bool
                  val zerobelow :
                    'a wmatrix ->
                    'a curposval ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GFC_F.contr) Code.abstract ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val init :
                    ('a, GFC_F.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of ('a, GFC_F.contr) Code.abstract
                                | `TPivot of
                                    ('a, GEF.PermList.perm_rep ref)
                                    Code.abstract
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     'a wmatrix * ('a, int ref) Code.abstract *
                     ('a, int ref) Code.abstract * ('a, int) Code.abstract)
                    StateCPSMonad.monad
                  val forward_elim :
                    'a wmatrix * ('a, int ref) Code.abstract *
                    ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
                    ([> `TDet of 'a F.Det.lstate
                      | `TLower of ('a, GFC_F.contr) Code.abstract
                      | `TPivot of
                          ('a, GEF.PermList.perm_rep ref) Code.abstract
                      | `TRan of 'a GEF.TrackRank.lstate ]
                     as 'b)
                    list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
                  val gen :
                    ('a, GFC_F.contr * int) Code.abstract ->
                    (< answer : ('a, 'b) Code.abstract;
                       state : [> `TDet of 'a F.Det.lstate
                                | `TLower of 'a O.IF.L.lstate
                                | `TPivot of 'a O.IF.P.lstate
                                | `TRan of 'a GEF.TrackRank.lstate ]
                               list;
                       .. >,
                     ('a, O.res) Code.abstract)
                    StateCPSMonad.monad
                end
              val init :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : 'b; state : 'c; .. >,
                 ('a, GFC_F.contr) Code.abstract *
                 ('a, F.Input.rhs) Code.abstract)
                StateCPSMonad.monad
              val back_elim :
                'a GFC_F.vc ->
                ('a, int) Code.abstract ->
                ('a, int) Code.abstract ->
                'b -> ('b -> ('a, GFC_F.contr) Code.abstract -> 'c) -> 'c
              val gen :
                ('a, F.Input.inp) Code.abstract ->
                (< answer : ('a, 'b) Code.abstract;
                   state : [> `TDet of 'a F.Det.lstate
                            | `TLower of 'a GE'.O.IF.L.lstate
                            | `TPivot of 'a GE'.O.IF.P.lstate
                            | `TRan of 'a GEF.TrackRank.lstate ]
                           list;
                   .. >,
                 ('a, F.Output.res) Code.abstract)
                StateCPSMonad.monad
            end
      end
  end
module GenFA1 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA2 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA3 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * int
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA4 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v * int
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA11 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA12 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA13 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * int
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA14 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v * int
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA24 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v * int * Code.perm list
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA25 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = int array
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, int * int) Code.abstract
                type 'a pra = ('a, int array) Code.abstract
                type 'a lstate = ('a, int array ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v * int * int array
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, int array ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, int array ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA26 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA5 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA6 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA7 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * int
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA8 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.Dom.v * int
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr * int) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_F).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA9 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * Code.perm list
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA31 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * GAC_F.contr * Code.perm list
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFA32 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val updt :
                  'a GAC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_F.vo ->
                  'a GAC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_F.contr * Code.perm list
        val make_result :
          'a G_GAC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_F.wmatrix ->
      'a G_GAC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of ('a, GAC_F.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
        | `TLower of ('a, GAC_F.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV1 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV2 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr * GVC_F.Dom.v
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV3 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr * int
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV4 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr * GVC_F.Dom.v * int
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV5 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr * GVC_F.Dom.v * int
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_F).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV6 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr * GVC_F.contr * Code.perm list
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenFV7 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_F.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_F.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val updt :
                  'a GVC_F.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_F.vo ->
                  'a GVC_F.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_F.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_F.contr * Code.perm list
        val make_result :
          'a G_GVC_F.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_F.wmatrix ->
      'a G_GVC_F.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
                  | `TLower of ('a, GVC_F.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_F.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
        | `TLower of ('a, GVC_F.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_F.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_F).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIA1 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val updt :
                  'a GAC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_I.vo ->
                  'a GAC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_I.contr
        val make_result :
          'a G_GAC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_I.wmatrix ->
      'a G_GAC_I.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
        | `TLower of ('a, GAC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
                  | `TLower of ('a, GAC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
        | `TLower of ('a, GAC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
- : unit = ()
module GenIA2 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val updt :
                  'a GAC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_I.vo ->
                  'a GAC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_I.contr * GAC_I.Dom.v
        val make_result :
          'a G_GAC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_I.wmatrix ->
      'a G_GAC_I.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
        | `TLower of ('a, GAC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
                  | `TLower of ('a, GAC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
        | `TLower of ('a, GAC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIA3 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val updt :
                  'a GAC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_I.vo ->
                  'a GAC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_I.contr * int
        val make_result :
          'a G_GAC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_I.wmatrix ->
      'a G_GAC_I.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
        | `TLower of ('a, GAC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
                  | `TLower of ('a, GAC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
        | `TLower of ('a, GAC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIA4 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val updt :
                  'a GAC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_I.vo ->
                  'a GAC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_I.contr * GAC_I.Dom.v * int
        val make_result :
          'a G_GAC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_I.wmatrix ->
      'a G_GAC_I.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
        | `TLower of ('a, GAC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
                  | `TLower of ('a, GAC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
        | `TLower of ('a, GAC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_I).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
- : unit = ()
- : unit = ()
module GenIV1 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val updt :
                  'a GVC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_I.vo ->
                  'a GVC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_I.contr
        val make_result :
          'a G_GVC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_I.wmatrix ->
      'a G_GVC_I.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
        | `TLower of ('a, GVC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
        | `TLower of ('a, GVC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIV2 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val updt :
                  'a GVC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_I.vo ->
                  'a GVC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_I.contr * GVC_I.Dom.v
        val make_result :
          'a G_GVC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_I.wmatrix ->
      'a G_GVC_I.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
        | `TLower of ('a, GVC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
        | `TLower of ('a, GVC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIV3 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val updt :
                  'a GVC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_I.vo ->
                  'a GVC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_I.contr * int
        val make_result :
          'a G_GVC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_I.wmatrix ->
      'a G_GVC_I.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
        | `TLower of ('a, GVC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
        | `TLower of ('a, GVC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIV4 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val updt :
                  'a GVC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_I.vo ->
                  'a GVC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_I.contr * GVC_I.Dom.v * int
        val make_result :
          'a G_GVC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_I.wmatrix ->
      'a G_GVC_I.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
        | `TLower of ('a, GVC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
        | `TLower of ('a, GVC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIV5 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val updt :
                  'a GVC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_I.vo ->
                  'a GVC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_I.contr * GVC_I.Dom.v * int
        val make_result :
          'a G_GVC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_I.wmatrix ->
      'a G_GVC_I.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
        | `TLower of ('a, GVC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
        | `TLower of ('a, GVC_I.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenIV6 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_I.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_I.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val updt :
                  'a GVC_I.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_I.vo ->
                  'a GVC_I.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_I.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_I.contr * GVC_I.Dom.v * int * Code.perm list
        val make_result :
          'a G_GVC_I.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_I.wmatrix ->
      'a G_GVC_I.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
        | `TLower of ('a, GVC_I.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                  | `TLower of ('a, GVC_I.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_I.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
        | `TLower of ('a, GVC_I.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_I.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_I).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenRA1 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_R.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_R.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val updt :
                  'a GAC_R.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_R.vo ->
                  'a GAC_R.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_R.contr
        val make_result :
          'a G_GAC_R.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_R.wmatrix ->
      'a G_GAC_R.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).NoDet.lstate
        | `TLower of ('a, GAC_R.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).NoDet.lstate
                  | `TLower of ('a, GAC_R.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).NoDet.lstate
        | `TLower of ('a, GAC_R.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenRA2 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_R.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_R.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val updt :
                  'a GAC_R.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_R.vo ->
                  'a GAC_R.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_R.contr * GAC_R.Dom.v
        val make_result :
          'a G_GAC_R.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_R).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_R.wmatrix ->
      'a G_GAC_R.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).AbstractDet.lstate
        | `TLower of ('a, GAC_R.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_R).AbstractDet.lstate
                  | `TLower of ('a, GAC_R.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).AbstractDet.lstate
        | `TLower of ('a, GAC_R.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_R).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenRA3 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_R.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_R.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val updt :
                  'a GAC_R.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_R.vo ->
                  'a GAC_R.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_R.contr * int
        val make_result :
          'a G_GAC_R.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).NoDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_R.wmatrix ->
      'a G_GAC_R.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).NoDet.lstate
        | `TLower of ('a, GAC_R.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).NoDet.lstate
                  | `TLower of ('a, GAC_R.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).NoDet.lstate
        | `TLower of ('a, GAC_R.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).NoDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenRA4 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = GEF.PermList.perm_rep
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = 'a GEF.PermList.fra
                type 'a pra = 'a GEF.PermList.pra
                type 'a lstate =
                    ('a, GEF.PermList.perm_rep ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GAC_R.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GAC_R.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val updt :
                  'a GAC_R.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GAC_R.vo ->
                  'a GAC_R.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GAC_R.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GAC_R.contr * GAC_R.Dom.v * int
        val make_result :
          'a G_GAC_R.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GAC_R).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GAC_R.wmatrix ->
      'a G_GAC_R.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).AbstractDet.lstate
        | `TLower of ('a, GAC_R.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_R).AbstractDet.lstate
                  | `TLower of ('a, GAC_R.contr) Code.abstract
                  | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GAC_R.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GAC_R).AbstractDet.lstate
        | `TLower of ('a, GAC_R.contr) Code.abstract
        | `TPivot of ('a, GEF.PermList.perm_rep ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GAC_R.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GAC_R).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenZp3 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_Z3.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_Z3.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_Z3.contr)
                  lm
                val updt :
                  'a GVC_Z3.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_Z3.vo ->
                  'a GVC_Z3.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_Z3.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_Z3.contr * GVC_Z3.Dom.v * int * Code.perm list
        val make_result :
          'a G_GVC_Z3.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a Ge.LAMake(Code).GenLA(GVC_Z3).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_Z3.wmatrix ->
      'a G_GVC_Z3.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_Z3).AbstractDet.lstate
        | `TLower of ('a, GVC_Z3.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_Z3.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_Z3).AbstractDet.lstate
                  | `TLower of ('a, GVC_Z3.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_Z3.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_Z3.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_Z3).AbstractDet.lstate
        | `TLower of ('a, GVC_Z3.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_Z3.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_Z3).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
module GenZp19 :
  sig
    module O :
      sig
        module IF :
          sig
            module R :
              sig
                type 'a tag_lstate = 'a GEF.TrackRank.tag_lstate_
                val decl :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int ref)
                  GEF.TrackRank.lm
                val succ :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   unit)
                  GEF.TrackRank.lm
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> 'b GEF.TrackRank.tag_lstate ]; .. >,
                   int)
                  GEF.TrackRank.lm
              end
            module P :
              sig
                type perm_rep = Code.perm list
                type 'a ira = ('a, int) Code.abstract
                type 'a fra = ('a, Code.perm) Code.abstract
                type 'a pra = ('a, Code.perm list) Code.abstract
                type 'a lstate = ('a, Code.perm list ref) Code.abstract
                type 'a pc_constraint = unit
                  constraint 'a =
                    < classif : 'b; state : [> `TPivot of 'b lstate ]; .. >
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TPivot of 'd lstate ]; .. >
                type ('a, 'b) nm =
                    (< answer : ('b, 'c) Code.abstract; state : 'd list >,
                     unit)
                    StateCPSMonad.monad
                  constraint 'a =
                    < answer : 'c; classif : 'b;
                      state : [> `TPivot of 'b lstate ] as 'd; .. >
                val rowrep : 'a ira -> 'a ira -> 'a fra
                val colrep : 'a ira -> 'a ira -> 'a fra
                val decl :
                  ('a, int) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   'a)
                  nm
                val add :
                  'a fra ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TPivot of 'a lstate ]; .. >,
                   unit)
                  GEF.omonad
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TPivot of 'b lstate ]; .. >,
                   perm_rep)
                  lm
              end
            module L :
              sig
                type 'a lstate = ('a, GVC_Z19.contr) Code.abstract
                type ('a, 'b) lm = ('a, 'b) GEF.cmonad
                  constraint 'a =
                    < answer : 'c; classif : 'd;
                      state : [> `TLower of 'd lstate ]; .. >
                val decl :
                  ('a, GVC_Z19.contr) Code.abstract ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   GVC_Z19.contr)
                  lm
                val updt :
                  'a GVC_Z19.vc ->
                  ('a, int) Code.abstract ->
                  ('a, int) Code.abstract ->
                  'a GVC_Z19.vo ->
                  'a GVC_Z19.Dom.vc ->
                  (< answer : 'b; classif : 'a;
                     state : [> `TLower of 'a lstate ]; .. >,
                   unit)
                  lm option
                val fin :
                  unit ->
                  (< answer : 'a; classif : 'b;
                     state : [> `TLower of 'b lstate ]; .. >,
                   GVC_Z19.contr)
                  lm
                val wants_pack : bool
              end
          end
        type res = GVC_Z19.contr * GVC_Z19.Dom.v * int * Code.perm list
        val make_result :
          'a G_GVC_Z19.wmatrix ->
          (< answer : 'b; classif : 'a;
             state : [> `TDet of
                          'a
                          Ge.LAMake(Code).GenLA(GVC_Z19).AbstractDet.lstate
                      | `TLower of 'a IF.L.lstate
                      | `TPivot of 'a IF.P.lstate
                      | `TRan of 'a GEF.TrackRank.lstate ];
             .. >,
           res)
          GEF.cmonad
      end
    val wants_pack : bool
    val can_pack : bool
    val zerobelow :
      'a G_GVC_Z19.wmatrix ->
      'a G_GVC_Z19.curposval ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_Z19).AbstractDet.lstate
        | `TLower of ('a, GVC_Z19.contr) Code.abstract ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val init :
      ('a, GVC_Z19.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_Z19).AbstractDet.lstate
                  | `TLower of ('a, GVC_Z19.contr) Code.abstract
                  | `TPivot of ('a, Code.perm list ref) Code.abstract
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       'a G_GVC_Z19.wmatrix * ('a, int ref) Code.abstract *
       ('a, int ref) Code.abstract * ('a, int) Code.abstract)
      StateCPSMonad.monad
    val forward_elim :
      'a G_GVC_Z19.wmatrix * ('a, int ref) Code.abstract *
      ('a, int ref) Code.abstract * ('a, int) Code.abstract ->
      ([> `TDet of 'a Ge.LAMake(Code).GenLA(GVC_Z19).AbstractDet.lstate
        | `TLower of ('a, GVC_Z19.contr) Code.abstract
        | `TPivot of ('a, Code.perm list ref) Code.abstract
        | `TRan of 'a GEF.TrackRank.lstate ]
       as 'b)
      list -> ('b list -> ('a, unit) Code.abstract -> 'c) -> 'c
    val gen :
      ('a, GVC_Z19.contr) Code.abstract ->
      (< answer : ('a, 'b) Code.abstract;
         state : [> `TDet of
                      'a Ge.LAMake(Code).GenLA(GVC_Z19).AbstractDet.lstate
                  | `TLower of 'a O.IF.L.lstate
                  | `TPivot of 'a O.IF.P.lstate
                  | `TRan of 'a GEF.TrackRank.lstate ]
                 list;
         .. >,
       ('a, O.res) Code.abstract)
      StateCPSMonad.monad
  end
val resFA1 : ('a, GAC_F.contr -> GenFA1.O.res) code =
  .<fun a_1 ->
     let t_2 = (ref 0) in
     let t_3 = (ref 0) in
     let t_5 = (Array.map (fun x_4 -> (Array.copy x_4)) (Array.copy a_1)) in
     let t_6 = (Array.length a_1.(0)) in
     let t_7 = (Array.length a_1) in
     while (((! t_3) < t_6) && ((! t_2) < t_7)) do
      let t_10 = (! t_2) in
      let t_11 = (! t_3) in
      let t_12 = (ref (None)) in
      let t_18 =
       begin
        for j_15 = t_10 to (t_7 - 1) do
         let t_16 = (t_5.(j_15)).(t_11) in
         if (t_16 <> 0.) then
          (match (! t_12) with
           | Some (i_17) ->
              if ((abs_float (snd i_17)) < (abs_float t_16)) then
               (t_12 := (Some (j_15, t_16)))
           | None -> (t_12 := (Some (j_15, t_16))))
        done;
        (match (! t_12) with
         | Some (i_13) ->
            if ((fst i_13) <> t_10) then
             let t_14 = t_5.(t_10) in
             t_5.(t_10) <- t_5.(fst i_13);
             t_5.(fst i_13) <- t_14;
            (Some (snd i_13))
         | None -> (None))
       end in
      (match t_18 with
       | Some (i_19) ->
          begin
           for j_20 = (t_10 + 1) to (t_7 - 1) do
            let t_21 = (t_5.(j_20)).(t_11) in
            if (t_21 <> 0.) then begin
             for j_22 = (t_11 + 1) to (t_6 - 1) do
              (t_5.(j_20)).(j_22) <-
               ((t_5.(j_20)).(j_22) -.
                 ((t_21 /. i_19) *. (t_5.(t_10)).(j_22)))
             done;
             (t_5.(j_20)).(t_11) <- 0.
            end
           done;
           ()
          end;
          (t_2 := ((! t_2) + 1))
       | None -> ());
      (t_3 := ((! t_3) + 1))
     done;
     t_5>.
val resFA2 : ('a, GAC_F.contr -> GenFA2.O.res) code =
  .<fun a_23 ->
     let t_24 = (ref 0) in
     let t_25 = (ref 0) in
     let t_27 = (Array.map (fun x_26 -> (Array.copy x_26)) (Array.copy a_23)) in
     let t_28 = (Array.length a_23.(0)) in
     let t_29 = (Array.length a_23) in
     let t_30 = (ref 1.) in
     let t_31 = (ref 1) in
     while (((! t_25) < t_28) && ((! t_24) < t_29)) do
      let t_34 = (! t_24) in
      let t_35 = (! t_25) in
      let t_36 = (ref (None)) in
      let t_42 =
       begin
        for j_39 = t_34 to (t_29 - 1) do
         let t_40 = (t_27.(j_39)).(t_35) in
         if (t_40 <> 0.) then
          (match (! t_36) with
           | Some (i_41) ->
              if ((abs_float (snd i_41)) < (abs_float t_40)) then
               (t_36 := (Some (j_39, t_40)))
           | None -> (t_36 := (Some (j_39, t_40))))
        done;
        (match (! t_36) with
         | Some (i_37) ->
            if ((fst i_37) <> t_34) then begin
             let t_38 = t_27.(t_34) in
             t_27.(t_34) <- t_27.(fst i_37);
             t_27.(fst i_37) <- t_38;
             (t_31 := (~- (! t_31)))
            end;
            (Some (snd i_37))
         | None -> (None))
       end in
      (match t_42 with
       | Some (i_43) ->
          begin
           for j_44 = (t_34 + 1) to (t_29 - 1) do
            let t_45 = (t_27.(j_44)).(t_35) in
            if (t_45 <> 0.) then begin
             for j_46 = (t_35 + 1) to (t_28 - 1) do
              (t_27.(j_44)).(j_46) <-
               ((t_27.(j_44)).(j_46) -.
                 ((t_45 /. i_43) *. (t_27.(t_34)).(j_46)))
             done;
             (t_27.(j_44)).(t_35) <- 0.
            end
           done;
           (t_30 := ((! t_30) *. i_43))
          end;
          (t_24 := ((! t_24) + 1))
       | None -> (t_31 := 0));
      (t_25 := ((! t_25) + 1))
     done;
     (t_27,
      if ((! t_31) = 0) then 0.
      else if ((! t_31) = 1) then (! t_30)
      else (~-. (! t_30)))>.
val resFA3 : ('a, GAC_F.contr -> GenFA3.O.res) code =
  .<fun a_47 ->
     let t_48 = (ref 0) in
     let t_49 = (ref 0) in
     let t_51 = (Array.map (fun x_50 -> (Array.copy x_50)) (Array.copy a_47)) in
     let t_52 = (Array.length a_47.(0)) in
     let t_53 = (Array.length a_47) in
     while (((! t_49) < t_52) && ((! t_48) < t_53)) do
      let t_56 = (! t_48) in
      let t_57 = (! t_49) in
      let t_58 = (ref (None)) in
      let t_64 =
       begin
        for j_61 = t_56 to (t_53 - 1) do
         let t_62 = (t_51.(j_61)).(t_57) in
         if (t_62 <> 0.) then
          (match (! t_58) with
           | Some (i_63) ->
              if ((abs_float (snd i_63)) < (abs_float t_62)) then
               (t_58 := (Some (j_61, t_62)))
           | None -> (t_58 := (Some (j_61, t_62))))
        done;
        (match (! t_58) with
         | Some (i_59) ->
            if ((fst i_59) <> t_56) then
             let t_60 = t_51.(t_56) in
             t_51.(t_56) <- t_51.(fst i_59);
             t_51.(fst i_59) <- t_60;
            (Some (snd i_59))
         | None -> (None))
       end in
      (match t_64 with
       | Some (i_65) ->
          begin
           for j_66 = (t_56 + 1) to (t_53 - 1) do
            let t_67 = (t_51.(j_66)).(t_57) in
            if (t_67 <> 0.) then begin
             for j_68 = (t_57 + 1) to (t_52 - 1) do
              (t_51.(j_66)).(j_68) <-
               ((t_51.(j_66)).(j_68) -.
                 ((t_67 /. i_65) *. (t_51.(t_56)).(j_68)))
             done;
             (t_51.(j_66)).(t_57) <- 0.
            end
           done;
           ()
          end;
          (t_48 := ((! t_48) + 1))
       | None -> ());
      (t_49 := ((! t_49) + 1))
     done;
     (t_51, (! t_48))>.
val resFA4 : ('a, GAC_F.contr -> GenFA4.O.res) code =
  .<fun a_69 ->
     let t_70 = (ref 0) in
     let t_71 = (ref 0) in
     let t_73 = (Array.map (fun x_72 -> (Array.copy x_72)) (Array.copy a_69)) in
     let t_74 = (Array.length a_69.(0)) in
     let t_75 = (Array.length a_69) in
     let t_76 = (ref 1.) in
     let t_77 = (ref 1) in
     while (((! t_71) < t_74) && ((! t_70) < t_75)) do
      let t_80 = (! t_70) in
      let t_81 = (! t_71) in
      let t_82 = (ref (None)) in
      let t_88 =
       begin
        for j_85 = t_80 to (t_75 - 1) do
         let t_86 = (t_73.(j_85)).(t_81) in
         if (t_86 <> 0.) then
          (match (! t_82) with
           | Some (i_87) ->
              if ((abs_float (snd i_87)) < (abs_float t_86)) then
               (t_82 := (Some (j_85, t_86)))
           | None -> (t_82 := (Some (j_85, t_86))))
        done;
        (match (! t_82) with
         | Some (i_83) ->
            if ((fst i_83) <> t_80) then begin
             let t_84 = t_73.(t_80) in
             t_73.(t_80) <- t_73.(fst i_83);
             t_73.(fst i_83) <- t_84;
             (t_77 := (~- (! t_77)))
            end;
            (Some (snd i_83))
         | None -> (None))
       end in
      (match t_88 with
       | Some (i_89) ->
          begin
           for j_90 = (t_80 + 1) to (t_75 - 1) do
            let t_91 = (t_73.(j_90)).(t_81) in
            if (t_91 <> 0.) then begin
             for j_92 = (t_81 + 1) to (t_74 - 1) do
              (t_73.(j_90)).(j_92) <-
               ((t_73.(j_90)).(j_92) -.
                 ((t_91 /. i_89) *. (t_73.(t_80)).(j_92)))
             done;
             (t_73.(j_90)).(t_81) <- 0.
            end
           done;
           (t_76 := ((! t_76) *. i_89))
          end;
          (t_70 := ((! t_70) + 1))
       | None -> (t_77 := 0));
      (t_71 := ((! t_71) + 1))
     done;
     (t_73,
      if ((! t_77) = 0) then 0.
      else if ((! t_77) = 1) then (! t_76)
      else (~-. (! t_76)), (! t_70))>.
val resFV1 : ('a, GVC_F.contr -> GenFV1.O.res) code =
  .<fun a_93 ->
     let t_94 = (ref 0) in
     let t_95 = (ref 0) in
     let t_96 = {arr = (Array.copy a_93.arr)} (a_93) in
     let t_97 = a_93.m in
     let t_98 = a_93.n in
     while (((! t_95) < t_97) && ((! t_94) < t_98)) do
      let t_103 = (! t_94) in
      let t_104 = (! t_95) in
      let t_105 = (ref (None)) in
      let t_116 =
       begin
        for j_113 = t_103 to (t_98 - 1) do
         let t_114 = (t_96.arr).((j_113 * t_96.m) + t_104) in
         if (t_114 <> 0.) then
          (match (! t_105) with
           | Some (i_115) ->
              if ((abs_float (snd i_115)) < (abs_float t_114)) then
               (t_105 := (Some (j_113, t_114)))
           | None -> (t_105 := (Some (j_113, t_114))))
        done;
        (match (! t_105) with
         | Some (i_106) ->
            if ((fst i_106) <> t_103) then
             let a_107 = t_96.arr
             and m_108 = t_96.m in
             let i1_109 = (t_103 * m_108)
             and i2_110 = ((fst i_106) * m_108) in
             for i_111 = t_104 to (m_108 - 1) do
              let t_112 = a_107.(i1_109 + i_111) in
              a_107.(i1_109 + i_111) <- a_107.(i2_110 + i_111);
              a_107.(i2_110 + i_111) <- t_112
             done;
            (Some (snd i_106))
         | None -> (None))
       end in
      (match t_116 with
       | Some (i_117) ->
          begin
           for j_118 = (t_103 + 1) to (t_98 - 1) do
            let t_119 = (t_96.arr).((j_118 * t_96.m) + t_104) in
            if (t_119 <> 0.) then begin
             for j_120 = (t_104 + 1) to (t_97 - 1) do
              (t_96.arr).((j_118 * t_96.m) + j_120) <-
               ((t_96.arr).((j_118 * t_96.m) + j_120) -.
                 ((t_119 /. i_117) *. (t_96.arr).((t_103 * t_96.m) + j_120)))
             done;
             (t_96.arr).((j_118 * t_96.m) + t_104) <- 0.
            end
           done;
           ()
          end;
          (t_94 := ((! t_94) + 1))
       | None -> ());
      (t_95 := ((! t_95) + 1))
     done;
     t_96>.
val resFV2 : ('a, GVC_F.contr -> GenFV2.O.res) code =
  .<fun a_121 ->
     let t_122 = (ref 0) in
     let t_123 = (ref 0) in
     let t_124 = {arr = (Array.copy a_121.arr)} (a_121) in
     let t_125 = a_121.m in
     let t_126 = a_121.n in
     let t_127 = (ref 1.) in
     let t_128 = (ref 1) in
     while (((! t_123) < t_125) && ((! t_122) < t_126)) do
      let t_133 = (! t_122) in
      let t_134 = (! t_123) in
      let t_135 = (ref (None)) in
      let t_146 =
       begin
        for j_143 = t_133 to (t_126 - 1) do
         let t_144 = (t_124.arr).((j_143 * t_124.m) + t_134) in
         if (t_144 <> 0.) then
          (match (! t_135) with
           | Some (i_145) ->
              if ((abs_float (snd i_145)) < (abs_float t_144)) then
               (t_135 := (Some (j_143, t_144)))
           | None -> (t_135 := (Some (j_143, t_144))))
        done;
        (match (! t_135) with
         | Some (i_136) ->
            if ((fst i_136) <> t_133) then begin
             let a_137 = t_124.arr
             and m_138 = t_124.m in
             let i1_139 = (t_133 * m_138)
             and i2_140 = ((fst i_136) * m_138) in
             for i_141 = t_134 to (m_138 - 1) do
              let t_142 = a_137.(i1_139 + i_141) in
              a_137.(i1_139 + i_141) <- a_137.(i2_140 + i_141);
              a_137.(i2_140 + i_141) <- t_142
             done;
             (t_128 := (~- (! t_128)))
            end;
            (Some (snd i_136))
         | None -> (None))
       end in
      (match t_146 with
       | Some (i_147) ->
          begin
           for j_148 = (t_133 + 1) to (t_126 - 1) do
            let t_149 = (t_124.arr).((j_148 * t_124.m) + t_134) in
            if (t_149 <> 0.) then begin
             for j_150 = (t_134 + 1) to (t_125 - 1) do
              (t_124.arr).((j_148 * t_124.m) + j_150) <-
               ((t_124.arr).((j_148 * t_124.m) + j_150) -.
                 ((t_149 /. i_147) *.
                   (t_124.arr).((t_133 * t_124.m) + j_150)))
             done;
             (t_124.arr).((j_148 * t_124.m) + t_134) <- 0.
            end
           done;
           (t_127 := ((! t_127) *. i_147))
          end;
          (t_122 := ((! t_122) + 1))
       | None -> (t_128 := 0));
      (t_123 := ((! t_123) + 1))
     done;
     (t_124,
      if ((! t_128) = 0) then 0.
      else if ((! t_128) = 1) then (! t_127)
      else (~-. (! t_127)))>.
val resFV3 : ('a, GVC_F.contr -> GenFV3.O.res) code =
  .<fun a_151 ->
     let t_152 = (ref 0) in
     let t_153 = (ref 0) in
     let t_154 = {arr = (Array.copy a_151.arr)} (a_151) in
     let t_155 = a_151.m in
     let t_156 = a_151.n in
     while (((! t_153) < t_155) && ((! t_152) < t_156)) do
      let t_161 = (! t_152) in
      let t_162 = (! t_153) in
      let t_163 = (ref (None)) in
      let t_174 =
       begin
        for j_171 = t_161 to (t_156 - 1) do
         let t_172 = (t_154.arr).((j_171 * t_154.m) + t_162) in
         if (t_172 <> 0.) then
          (match (! t_163) with
           | Some (i_173) ->
              if ((abs_float (snd i_173)) < (abs_float t_172)) then
               (t_163 := (Some (j_171, t_172)))
           | None -> (t_163 := (Some (j_171, t_172))))
        done;
        (match (! t_163) with
         | Some (i_164) ->
            if ((fst i_164) <> t_161) then
             let a_165 = t_154.arr
             and m_166 = t_154.m in
             let i1_167 = (t_161 * m_166)
             and i2_168 = ((fst i_164) * m_166) in
             for i_169 = t_162 to (m_166 - 1) do
              let t_170 = a_165.(i1_167 + i_169) in
              a_165.(i1_167 + i_169) <- a_165.(i2_168 + i_169);
              a_165.(i2_168 + i_169) <- t_170
             done;
            (Some (snd i_164))
         | None -> (None))
       end in
      (match t_174 with
       | Some (i_175) ->
          begin
           for j_176 = (t_161 + 1) to (t_156 - 1) do
            let t_177 = (t_154.arr).((j_176 * t_154.m) + t_162) in
            if (t_177 <> 0.) then begin
             for j_178 = (t_162 + 1) to (t_155 - 1) do
              (t_154.arr).((j_176 * t_154.m) + j_178) <-
               ((t_154.arr).((j_176 * t_154.m) + j_178) -.
                 ((t_177 /. i_175) *.
                   (t_154.arr).((t_161 * t_154.m) + j_178)))
             done;
             (t_154.arr).((j_176 * t_154.m) + t_162) <- 0.
            end
           done;
           ()
          end;
          (t_152 := ((! t_152) + 1))
       | None -> ());
      (t_153 := ((! t_153) + 1))
     done;
     (t_154, (! t_152))>.
val resFV4 : ('a, GVC_F.contr -> GenFV4.O.res) code =
  .<fun a_179 ->
     let t_180 = (ref 0) in
     let t_181 = (ref 0) in
     let t_182 = {arr = (Array.copy a_179.arr)} (a_179) in
     let t_183 = a_179.m in
     let t_184 = a_179.n in
     let t_185 = (ref 1.) in
     let t_186 = (ref 1) in
     while (((! t_181) < t_183) && ((! t_180) < t_184)) do
      let t_191 = (! t_180) in
      let t_192 = (! t_181) in
      let t_193 = (ref (None)) in
      let t_204 =
       begin
        for j_201 = t_191 to (t_184 - 1) do
         let t_202 = (t_182.arr).((j_201 * t_182.m) + t_192) in
         if (t_202 <> 0.) then
          (match (! t_193) with
           | Some (i_203) ->
              if ((abs_float (snd i_203)) < (abs_float t_202)) then
               (t_193 := (Some (j_201, t_202)))
           | None -> (t_193 := (Some (j_201, t_202))))
        done;
        (match (! t_193) with
         | Some (i_194) ->
            if ((fst i_194) <> t_191) then begin
             let a_195 = t_182.arr
             and m_196 = t_182.m in
             let i1_197 = (t_191 * m_196)
             and i2_198 = ((fst i_194) * m_196) in
             for i_199 = t_192 to (m_196 - 1) do
              let t_200 = a_195.(i1_197 + i_199) in
              a_195.(i1_197 + i_199) <- a_195.(i2_198 + i_199);
              a_195.(i2_198 + i_199) <- t_200
             done;
             (t_186 := (~- (! t_186)))
            end;
            (Some (snd i_194))
         | None -> (None))
       end in
      (match t_204 with
       | Some (i_205) ->
          begin
           for j_206 = (t_191 + 1) to (t_184 - 1) do
            let t_207 = (t_182.arr).((j_206 * t_182.m) + t_192) in
            if (t_207 <> 0.) then begin
             for j_208 = (t_192 + 1) to (t_183 - 1) do
              (t_182.arr).((j_206 * t_182.m) + j_208) <-
               ((t_182.arr).((j_206 * t_182.m) + j_208) -.
                 ((t_207 /. i_205) *.
                   (t_182.arr).((t_191 * t_182.m) + j_208)))
             done;
             (t_182.arr).((j_206 * t_182.m) + t_192) <- 0.
            end
           done;
           (t_185 := ((! t_185) *. i_205))
          end;
          (t_180 := ((! t_180) + 1))
       | None -> (t_186 := 0));
      (t_181 := ((! t_181) + 1))
     done;
     (t_182,
      if ((! t_186) = 0) then 0.
      else if ((! t_186) = 1) then (! t_185)
      else (~-. (! t_185)), (! t_180))>.
val resFV5 : ('a, GVC_F.contr -> GenFV5.O.res) code =
  .<fun a_209 ->
     let t_210 = (ref 0) in
     let t_211 = (ref 0) in
     let t_212 = {arr = (Array.copy a_209.arr)} (a_209) in
     let t_213 = a_209.m in
     let t_214 = a_209.n in
     let t_215 = (ref 1.) in
     let t_216 = (ref 1) in
     while (((! t_211) < t_213) && ((! t_210) < t_214)) do
      let t_221 = (! t_210) in
      let t_222 = (! t_211) in
      let t_223 = (ref (None)) in
      let t_242 =
       begin
        for j_238 = t_221 to (t_214 - 1) do
         for j_239 = t_222 to (t_213 - 1) do
          let t_240 = (t_212.arr).((j_238 * t_212.m) + j_239) in
          if (t_240 <> 0.) then
           (match (! t_223) with
            | Some (i_241) ->
               if ((abs_float (snd i_241)) < (abs_float t_240)) then
                (t_223 := (Some ((j_238, j_239), t_240)))
            | None -> (t_223 := (Some ((j_238, j_239), t_240))))
         done
        done;
        (match (! t_223) with
         | Some (i_224) ->
            if ((snd (fst i_224)) <> t_222) then begin
             let a_231 = t_212.arr
             and nm_232 = (t_212.n * t_212.m)
             and m_233 = t_212.m in
             let rec loop_234 =
              fun i1_235 ->
               fun i2_236 ->
                if (i2_236 < nm_232) then
                 let t_237 = a_231.(i1_235) in
                 a_231.(i1_235) <- a_231.(i2_236);
                 a_231.(i2_236) <- t_237;
                 (loop_234 (i1_235 + m_233) (i2_236 + m_233)) in
             (loop_234 t_222 (snd (fst i_224)));
             (t_216 := (~- (! t_216)))
            end;
            if ((fst (fst i_224)) <> t_221) then begin
             let a_225 = t_212.arr
             and m_226 = t_212.m in
             let i1_227 = (t_221 * m_226)
             and i2_228 = ((snd (fst i_224)) * m_226) in
             for i_229 = t_222 to (m_226 - 1) do
              let t_230 = a_225.(i1_227 + i_229) in
              a_225.(i1_227 + i_229) <- a_225.(i2_228 + i_229);
              a_225.(i2_228 + i_229) <- t_230
             done;
             (t_216 := (~- (! t_216)))
            end;
            (Some (snd i_224))
         | None -> (None))
       end in
      (match t_242 with
       | Some (i_243) ->
          begin
           for j_244 = (t_221 + 1) to (t_214 - 1) do
            let t_245 = (t_212.arr).((j_244 * t_212.m) + t_222) in
            if (t_245 <> 0.) then begin
             for j_246 = (t_222 + 1) to (t_213 - 1) do
              (t_212.arr).((j_244 * t_212.m) + j_246) <-
               ((t_212.arr).((j_244 * t_212.m) + j_246) -.
                 ((t_245 /. i_243) *.
                   (t_212.arr).((t_221 * t_212.m) + j_246)))
             done;
             (t_212.arr).((j_244 * t_212.m) + t_222) <- 0.
            end
           done;
           (t_215 := ((! t_215) *. i_243))
          end;
          (t_210 := ((! t_210) + 1))
       | None -> (t_216 := 0));
      (t_211 := ((! t_211) + 1))
     done;
     (t_212,
      if ((! t_216) = 0) then 0.
      else if ((! t_216) = 1) then (! t_215)
      else (~-. (! t_215)), (! t_210))>.
val resIA1 : ('a, GAC_I.contr -> GenIA1.O.res) code =
  .<fun a_247 ->
     let t_248 = (ref 0) in
     let t_249 = (ref 0) in
     let t_251 =
      (Array.map (fun x_250 -> (Array.copy x_250)) (Array.copy a_247)) in
     let t_252 = (Array.length a_247.(0)) in
     let t_253 = (Array.length a_247) in
     let t_254 = (ref 1) in
     let t_255 = (ref 1) in
     while (((! t_249) < t_252) && ((! t_248) < t_253)) do
      let t_258 = (! t_248) in
      let t_259 = (! t_249) in
      let t_260 = (ref (None)) in
      let t_266 =
       begin
        for j_263 = t_258 to (t_253 - 1) do
         let t_264 = (t_251.(j_263)).(t_259) in
         if (t_264 <> 0) then
          (match (! t_260) with
           | Some (i_265) ->
              if ((abs (snd i_265)) > (abs t_264)) then
               (t_260 := (Some (j_263, t_264)))
           | None -> (t_260 := (Some (j_263, t_264))))
        done;
        (match (! t_260) with
         | Some (i_261) ->
            if ((fst i_261) <> t_258) then begin
             let t_262 = t_251.(t_258) in
             t_251.(t_258) <- t_251.(fst i_261);
             t_251.(fst i_261) <- t_262;
             (t_255 := (~- (! t_255)))
            end;
            (Some (snd i_261))
         | None -> (None))
       end in
      (match t_266 with
       | Some (i_267) ->
          begin
           for j_268 = (t_258 + 1) to (t_253 - 1) do
            let t_269 = (t_251.(j_268)).(t_259) in
            if (t_269 <> 0) then begin
             for j_270 = (t_259 + 1) to (t_252 - 1) do
              (t_251.(j_268)).(j_270) <-
               ((((t_251.(j_268)).(j_270) * i_267) -
                  ((t_251.(t_258)).(j_270) * t_269)) / (! t_254))
             done;
             (t_251.(j_268)).(t_259) <- 0
            end
           done;
           (t_254 := i_267)
          end;
          (t_248 := ((! t_248) + 1))
       | None -> (t_255 := 0));
      (t_249 := ((! t_249) + 1))
     done;
     t_251>.
val resIA2 : ('a, GAC_I.contr -> GenIA2.O.res) code =
  .<fun a_271 ->
     let t_272 = (ref 0) in
     let t_273 = (ref 0) in
     let t_275 =
      (Array.map (fun x_274 -> (Array.copy x_274)) (Array.copy a_271)) in
     let t_276 = (Array.length a_271.(0)) in
     let t_277 = (Array.length a_271) in
     let t_278 = (ref 1) in
     let t_279 = (ref 1) in
     while (((! t_273) < t_276) && ((! t_272) < t_277)) do
      let t_282 = (! t_272) in
      let t_283 = (! t_273) in
      let t_284 = (ref (None)) in
      let t_290 =
       begin
        for j_287 = t_282 to (t_277 - 1) do
         let t_288 = (t_275.(j_287)).(t_283) in
         if (t_288 <> 0) then
          (match (! t_284) with
           | Some (i_289) ->
              if ((abs (snd i_289)) > (abs t_288)) then
               (t_284 := (Some (j_287, t_288)))
           | None -> (t_284 := (Some (j_287, t_288))))
        done;
        (match (! t_284) with
         | Some (i_285) ->
            if ((fst i_285) <> t_282) then begin
             let t_286 = t_275.(t_282) in
             t_275.(t_282) <- t_275.(fst i_285);
             t_275.(fst i_285) <- t_286;
             (t_279 := (~- (! t_279)))
            end;
            (Some (snd i_285))
         | None -> (None))
       end in
      (match t_290 with
       | Some (i_291) ->
          begin
           for j_292 = (t_282 + 1) to (t_277 - 1) do
            let t_293 = (t_275.(j_292)).(t_283) in
            if (t_293 <> 0) then begin
             for j_294 = (t_283 + 1) to (t_276 - 1) do
              (t_275.(j_292)).(j_294) <-
               ((((t_275.(j_292)).(j_294) * i_291) -
                  ((t_275.(t_282)).(j_294) * t_293)) / (! t_278))
             done;
             (t_275.(j_292)).(t_283) <- 0
            end
           done;
           (t_278 := i_291)
          end;
          (t_272 := ((! t_272) + 1))
       | None -> (t_279 := 0));
      (t_273 := ((! t_273) + 1))
     done;
     (t_275,
      if ((! t_279) = 0) then 0
      else if ((! t_279) = 1) then (! t_278)
      else (~- (! t_278)))>.
val resIA3 : ('a, GAC_I.contr -> GenIA3.O.res) code =
  .<fun a_295 ->
     let t_296 = (ref 0) in
     let t_297 = (ref 0) in
     let t_299 =
      (Array.map (fun x_298 -> (Array.copy x_298)) (Array.copy a_295)) in
     let t_300 = (Array.length a_295.(0)) in
     let t_301 = (Array.length a_295) in
     let t_302 = (ref 1) in
     let t_303 = (ref 1) in
     while (((! t_297) < t_300) && ((! t_296) < t_301)) do
      let t_306 = (! t_296) in
      let t_307 = (! t_297) in
      let t_308 = (ref (None)) in
      let t_314 =
       begin
        for j_311 = t_306 to (t_301 - 1) do
         let t_312 = (t_299.(j_311)).(t_307) in
         if (t_312 <> 0) then
          (match (! t_308) with
           | Some (i_313) ->
              if ((abs (snd i_313)) > (abs t_312)) then
               (t_308 := (Some (j_311, t_312)))
           | None -> (t_308 := (Some (j_311, t_312))))
        done;
        (match (! t_308) with
         | Some (i_309) ->
            if ((fst i_309) <> t_306) then begin
             let t_310 = t_299.(t_306) in
             t_299.(t_306) <- t_299.(fst i_309);
             t_299.(fst i_309) <- t_310;
             (t_303 := (~- (! t_303)))
            end;
            (Some (snd i_309))
         | None -> (None))
       end in
      (match t_314 with
       | Some (i_315) ->
          begin
           for j_316 = (t_306 + 1) to (t_301 - 1) do
            let t_317 = (t_299.(j_316)).(t_307) in
            if (t_317 <> 0) then begin
             for j_318 = (t_307 + 1) to (t_300 - 1) do
              (t_299.(j_316)).(j_318) <-
               ((((t_299.(j_316)).(j_318) * i_315) -
                  ((t_299.(t_306)).(j_318) * t_317)) / (! t_302))
             done;
             (t_299.(j_316)).(t_307) <- 0
            end
           done;
           (t_302 := i_315)
          end;
          (t_296 := ((! t_296) + 1))
       | None -> (t_303 := 0));
      (t_297 := ((! t_297) + 1))
     done;
     (t_299, (! t_296))>.
val resIA4 : ('a, GAC_I.contr -> GenIA4.O.res) code =
  .<fun a_319 ->
     let t_320 = (ref 0) in
     let t_321 = (ref 0) in
     let t_323 =
      (Array.map (fun x_322 -> (Array.copy x_322)) (Array.copy a_319)) in
     let t_324 = (Array.length a_319.(0)) in
     let t_325 = (Array.length a_319) in
     let t_326 = (ref 1) in
     let t_327 = (ref 1) in
     while (((! t_321) < t_324) && ((! t_320) < t_325)) do
      let t_330 = (! t_320) in
      let t_331 = (! t_321) in
      let t_332 = (ref (None)) in
      let t_338 =
       begin
        for j_335 = t_330 to (t_325 - 1) do
         let t_336 = (t_323.(j_335)).(t_331) in
         if (t_336 <> 0) then
          (match (! t_332) with
           | Some (i_337) ->
              if ((abs (snd i_337)) > (abs t_336)) then
               (t_332 := (Some (j_335, t_336)))
           | None -> (t_332 := (Some (j_335, t_336))))
        done;
        (match (! t_332) with
         | Some (i_333) ->
            if ((fst i_333) <> t_330) then begin
             let t_334 = t_323.(t_330) in
             t_323.(t_330) <- t_323.(fst i_333);
             t_323.(fst i_333) <- t_334;
             (t_327 := (~- (! t_327)))
            end;
            (Some (snd i_333))
         | None -> (None))
       end in
      (match t_338 with
       | Some (i_339) ->
          begin
           for j_340 = (t_330 + 1) to (t_325 - 1) do
            let t_341 = (t_323.(j_340)).(t_331) in
            if (t_341 <> 0) then begin
             for j_342 = (t_331 + 1) to (t_324 - 1) do
              (t_323.(j_340)).(j_342) <-
               ((((t_323.(j_340)).(j_342) * i_339) -
                  ((t_323.(t_330)).(j_342) * t_341)) / (! t_326))
             done;
             (t_323.(j_340)).(t_331) <- 0
            end
           done;
           (t_326 := i_339)
          end;
          (t_320 := ((! t_320) + 1))
       | None -> (t_327 := 0));
      (t_321 := ((! t_321) + 1))
     done;
     (t_323,
      if ((! t_327) = 0) then 0
      else if ((! t_327) = 1) then (! t_326)
      else (~- (! t_326)), (! t_320))>.
val resIV1 : ('a, GVC_I.contr -> GenIV1.O.res) code =
  .<fun a_343 ->
     let t_344 = (ref 0) in
     let t_345 = (ref 0) in
     let t_346 = {arr = (Array.copy a_343.arr)} (a_343) in
     let t_347 = a_343.m in
     let t_348 = a_343.n in
     let t_349 = (ref 1) in
     let t_350 = (ref 1) in
     while (((! t_345) < t_347) && ((! t_344) < t_348)) do
      let t_355 = (! t_344) in
      let t_356 = (! t_345) in
      let t_357 = (ref (None)) in
      let t_368 =
       begin
        for j_365 = t_355 to (t_348 - 1) do
         let t_366 = (t_346.arr).((j_365 * t_346.m) + t_356) in
         if (t_366 <> 0) then
          (match (! t_357) with
           | Some (i_367) ->
              if ((abs (snd i_367)) > (abs t_366)) then
               (t_357 := (Some (j_365, t_366)))
           | None -> (t_357 := (Some (j_365, t_366))))
        done;
        (match (! t_357) with
         | Some (i_358) ->
            if ((fst i_358) <> t_355) then begin
             let a_359 = t_346.arr
             and m_360 = t_346.m in
             let i1_361 = (t_355 * m_360)
             and i2_362 = ((fst i_358) * m_360) in
             for i_363 = t_356 to (m_360 - 1) do
              let t_364 = a_359.(i1_361 + i_363) in
              a_359.(i1_361 + i_363) <- a_359.(i2_362 + i_363);
              a_359.(i2_362 + i_363) <- t_364
             done;
             (t_350 := (~- (! t_350)))
            end;
            (Some (snd i_358))
         | None -> (None))
       end in
      (match t_368 with
       | Some (i_369) ->
          begin
           for j_370 = (t_355 + 1) to (t_348 - 1) do
            let t_371 = (t_346.arr).((j_370 * t_346.m) + t_356) in
            if (t_371 <> 0) then begin
             for j_372 = (t_356 + 1) to (t_347 - 1) do
              (t_346.arr).((j_370 * t_346.m) + j_372) <-
               ((((t_346.arr).((j_370 * t_346.m) + j_372) * i_369) -
                  ((t_346.arr).((t_355 * t_346.m) + j_372) * t_371)) /
                 (! t_349))
             done;
             (t_346.arr).((j_370 * t_346.m) + t_356) <- 0
            end
           done;
           (t_349 := i_369)
          end;
          (t_344 := ((! t_344) + 1))
       | None -> (t_350 := 0));
      (t_345 := ((! t_345) + 1))
     done;
     t_346>.
val resIV2 : ('a, GVC_I.contr -> GenIV2.O.res) code =
  .<fun a_373 ->
     let t_374 = (ref 0) in
     let t_375 = (ref 0) in
     let t_376 = {arr = (Array.copy a_373.arr)} (a_373) in
     let t_377 = a_373.m in
     let t_378 = a_373.n in
     let t_379 = (ref 1) in
     let t_380 = (ref 1) in
     while (((! t_375) < t_377) && ((! t_374) < t_378)) do
      let t_385 = (! t_374) in
      let t_386 = (! t_375) in
      let t_387 = (ref (None)) in
      let t_398 =
       begin
        for j_395 = t_385 to (t_378 - 1) do
         let t_396 = (t_376.arr).((j_395 * t_376.m) + t_386) in
         if (t_396 <> 0) then
          (match (! t_387) with
           | Some (i_397) ->
              if ((abs (snd i_397)) > (abs t_396)) then
               (t_387 := (Some (j_395, t_396)))
           | None -> (t_387 := (Some (j_395, t_396))))
        done;
        (match (! t_387) with
         | Some (i_388) ->
            if ((fst i_388) <> t_385) then begin
             let a_389 = t_376.arr
             and m_390 = t_376.m in
             let i1_391 = (t_385 * m_390)
             and i2_392 = ((fst i_388) * m_390) in
             for i_393 = t_386 to (m_390 - 1) do
              let t_394 = a_389.(i1_391 + i_393) in
              a_389.(i1_391 + i_393) <- a_389.(i2_392 + i_393);
              a_389.(i2_392 + i_393) <- t_394
             done;
             (t_380 := (~- (! t_380)))
            end;
            (Some (snd i_388))
         | None -> (None))
       end in
      (match t_398 with
       | Some (i_399) ->
          begin
           for j_400 = (t_385 + 1) to (t_378 - 1) do
            let t_401 = (t_376.arr).((j_400 * t_376.m) + t_386) in
            if (t_401 <> 0) then begin
             for j_402 = (t_386 + 1) to (t_377 - 1) do
              (t_376.arr).((j_400 * t_376.m) + j_402) <-
               ((((t_376.arr).((j_400 * t_376.m) + j_402) * i_399) -
                  ((t_376.arr).((t_385 * t_376.m) + j_402) * t_401)) /
                 (! t_379))
             done;
             (t_376.arr).((j_400 * t_376.m) + t_386) <- 0
            end
           done;
           (t_379 := i_399)
          end;
          (t_374 := ((! t_374) + 1))
       | None -> (t_380 := 0));
      (t_375 := ((! t_375) + 1))
     done;
     (t_376,
      if ((! t_380) = 0) then 0
      else if ((! t_380) = 1) then (! t_379)
      else (~- (! t_379)))>.
val resIV3 : ('a, GVC_I.contr -> GenIV3.O.res) code =
  .<fun a_403 ->
     let t_404 = (ref 0) in
     let t_405 = (ref 0) in
     let t_406 = {arr = (Array.copy a_403.arr)} (a_403) in
     let t_407 = a_403.m in
     let t_408 = a_403.n in
     let t_409 = (ref 1) in
     let t_410 = (ref 1) in
     while (((! t_405) < t_407) && ((! t_404) < t_408)) do
      let t_415 = (! t_404) in
      let t_416 = (! t_405) in
      let t_417 = (ref (None)) in
      let t_428 =
       begin
        for j_425 = t_415 to (t_408 - 1) do
         let t_426 = (t_406.arr).((j_425 * t_406.m) + t_416) in
         if (t_426 <> 0) then
          (match (! t_417) with
           | Some (i_427) ->
              if ((abs (snd i_427)) > (abs t_426)) then
               (t_417 := (Some (j_425, t_426)))
           | None -> (t_417 := (Some (j_425, t_426))))
        done;
        (match (! t_417) with
         | Some (i_418) ->
            if ((fst i_418) <> t_415) then begin
             let a_419 = t_406.arr
             and m_420 = t_406.m in
             let i1_421 = (t_415 * m_420)
             and i2_422 = ((fst i_418) * m_420) in
             for i_423 = t_416 to (m_420 - 1) do
              let t_424 = a_419.(i1_421 + i_423) in
              a_419.(i1_421 + i_423) <- a_419.(i2_422 + i_423);
              a_419.(i2_422 + i_423) <- t_424
             done;
             (t_410 := (~- (! t_410)))
            end;
            (Some (snd i_418))
         | None -> (None))
       end in
      (match t_428 with
       | Some (i_429) ->
          begin
           for j_430 = (t_415 + 1) to (t_408 - 1) do
            let t_431 = (t_406.arr).((j_430 * t_406.m) + t_416) in
            if (t_431 <> 0) then begin
             for j_432 = (t_416 + 1) to (t_407 - 1) do
              (t_406.arr).((j_430 * t_406.m) + j_432) <-
               ((((t_406.arr).((j_430 * t_406.m) + j_432) * i_429) -
                  ((t_406.arr).((t_415 * t_406.m) + j_432) * t_431)) /
                 (! t_409))
             done;
             (t_406.arr).((j_430 * t_406.m) + t_416) <- 0
            end
           done;
           (t_409 := i_429)
          end;
          (t_404 := ((! t_404) + 1))
       | None -> (t_410 := 0));
      (t_405 := ((! t_405) + 1))
     done;
     (t_406, (! t_404))>.
val resIV4 : ('a, GVC_I.contr -> GenIV4.O.res) code =
  .<fun a_433 ->
     let t_434 = (ref 0) in
     let t_435 = (ref 0) in
     let t_436 = {arr = (Array.copy a_433.arr)} (a_433) in
     let t_437 = a_433.m in
     let t_438 = a_433.n in
     let t_439 = (ref 1) in
     let t_440 = (ref 1) in
     while (((! t_435) < t_437) && ((! t_434) < t_438)) do
      let t_445 = (! t_434) in
      let t_446 = (! t_435) in
      let t_447 = (ref (None)) in
      let t_458 =
       begin
        for j_455 = t_445 to (t_438 - 1) do
         let t_456 = (t_436.arr).((j_455 * t_436.m) + t_446) in
         if (t_456 <> 0) then
          (match (! t_447) with
           | Some (i_457) ->
              if ((abs (snd i_457)) > (abs t_456)) then
               (t_447 := (Some (j_455, t_456)))
           | None -> (t_447 := (Some (j_455, t_456))))
        done;
        (match (! t_447) with
         | Some (i_448) ->
            if ((fst i_448) <> t_445) then begin
             let a_449 = t_436.arr
             and m_450 = t_436.m in
             let i1_451 = (t_445 * m_450)
             and i2_452 = ((fst i_448) * m_450) in
             for i_453 = t_446 to (m_450 - 1) do
              let t_454 = a_449.(i1_451 + i_453) in
              a_449.(i1_451 + i_453) <- a_449.(i2_452 + i_453);
              a_449.(i2_452 + i_453) <- t_454
             done;
             (t_440 := (~- (! t_440)))
            end;
            (Some (snd i_448))
         | None -> (None))
       end in
      (match t_458 with
       | Some (i_459) ->
          begin
           for j_460 = (t_445 + 1) to (t_438 - 1) do
            let t_461 = (t_436.arr).((j_460 * t_436.m) + t_446) in
            if (t_461 <> 0) then begin
             for j_462 = (t_446 + 1) to (t_437 - 1) do
              (t_436.arr).((j_460 * t_436.m) + j_462) <-
               ((((t_436.arr).((j_460 * t_436.m) + j_462) * i_459) -
                  ((t_436.arr).((t_445 * t_436.m) + j_462) * t_461)) /
                 (! t_439))
             done;
             (t_436.arr).((j_460 * t_436.m) + t_446) <- 0
            end
           done;
           (t_439 := i_459)
          end;
          (t_434 := ((! t_434) + 1))
       | None -> (t_440 := 0));
      (t_435 := ((! t_435) + 1))
     done;
     (t_436,
      if ((! t_440) = 0) then 0
      else if ((! t_440) = 1) then (! t_439)
      else (~- (! t_439)), (! t_434))>.
val resIV5 : ('a, GVC_I.contr -> GenIV5.O.res) code =
  .<fun a_463 ->
     let t_464 = (ref 0) in
     let t_465 = (ref 0) in
     let t_466 = {arr = (Array.copy a_463.arr)} (a_463) in
     let t_467 = a_463.m in
     let t_468 = a_463.n in
     let t_469 = (ref 1) in
     let t_470 = (ref 1) in
     while (((! t_465) < t_467) && ((! t_464) < t_468)) do
      let t_475 = (! t_464) in
      let t_476 = (! t_465) in
      let t_477 = (ref (None)) in
      let t_496 =
       begin
        for j_492 = t_475 to (t_468 - 1) do
         for j_493 = t_476 to (t_467 - 1) do
          let t_494 = (t_466.arr).((j_492 * t_466.m) + j_493) in
          if (t_494 <> 0) then
           (match (! t_477) with
            | Some (i_495) ->
               if ((abs (snd i_495)) > (abs t_494)) then
                (t_477 := (Some ((j_492, j_493), t_494)))
            | None -> (t_477 := (Some ((j_492, j_493), t_494))))
         done
        done;
        (match (! t_477) with
         | Some (i_478) ->
            if ((snd (fst i_478)) <> t_476) then begin
             let a_485 = t_466.arr
             and nm_486 = (t_466.n * t_466.m)
             and m_487 = t_466.m in
             let rec loop_488 =
              fun i1_489 ->
               fun i2_490 ->
                if (i2_490 < nm_486) then
                 let t_491 = a_485.(i1_489) in
                 a_485.(i1_489) <- a_485.(i2_490);
                 a_485.(i2_490) <- t_491;
                 (loop_488 (i1_489 + m_487) (i2_490 + m_487)) in
             (loop_488 t_476 (snd (fst i_478)));
             (t_470 := (~- (! t_470)))
            end;
            if ((fst (fst i_478)) <> t_475) then begin
             let a_479 = t_466.arr
             and m_480 = t_466.m in
             let i1_481 = (t_475 * m_480)
             and i2_482 = ((snd (fst i_478)) * m_480) in
             for i_483 = t_476 to (m_480 - 1) do
              let t_484 = a_479.(i1_481 + i_483) in
              a_479.(i1_481 + i_483) <- a_479.(i2_482 + i_483);
              a_479.(i2_482 + i_483) <- t_484
             done;
             (t_470 := (~- (! t_470)))
            end;
            (Some (snd i_478))
         | None -> (None))
       end in
      (match t_496 with
       | Some (i_497) ->
          begin
           for j_498 = (t_475 + 1) to (t_468 - 1) do
            let t_499 = (t_466.arr).((j_498 * t_466.m) + t_476) in
            if (t_499 <> 0) then begin
             for j_500 = (t_476 + 1) to (t_467 - 1) do
              (t_466.arr).((j_498 * t_466.m) + j_500) <-
               ((((t_466.arr).((j_498 * t_466.m) + j_500) * i_497) -
                  ((t_466.arr).((t_475 * t_466.m) + j_500) * t_499)) /
                 (! t_469))
             done;
             (t_466.arr).((j_498 * t_466.m) + t_476) <- 0
            end
           done;
           (t_469 := i_497)
          end;
          (t_464 := ((! t_464) + 1))
       | None -> (t_470 := 0));
      (t_465 := ((! t_465) + 1))
     done;
     (t_466,
      if ((! t_470) = 0) then 0
      else if ((! t_470) = 1) then (! t_469)
      else (~- (! t_469)), (! t_464))>.
val resIV6 : ('a, GVC_I.contr -> GenIV6.O.res) code =
  .<fun a_501 ->
     let t_502 = (ref 0) in
     let t_503 = (ref 0) in
     let t_504 = {arr = (Array.copy a_501.arr)} (a_501) in
     let t_505 = a_501.m in
     let t_506 = a_501.n in
     let t_507 = (ref 1) in
     let t_508 = (ref 1) in
     let t_509 = (ref ([])) in
     while (((! t_503) < t_505) && ((! t_502) < t_506)) do
      let t_514 = (! t_502) in
      let t_515 = (! t_503) in
      let t_516 = (ref (None)) in
      let t_535 =
       begin
        for j_531 = t_514 to (t_506 - 1) do
         for j_532 = t_515 to (t_505 - 1) do
          let t_533 = (t_504.arr).((j_531 * t_504.m) + j_532) in
          if (t_533 <> 0) then
           (match (! t_516) with
            | Some (i_534) ->
               if ((abs (snd i_534)) > (abs t_533)) then
                (t_516 := (Some ((j_531, j_532), t_533)))
            | None -> (t_516 := (Some ((j_531, j_532), t_533))))
         done
        done;
        (match (! t_516) with
         | Some (i_517) ->
            if ((snd (fst i_517)) <> t_515) then begin
             begin
              let a_524 = t_504.arr
              and nm_525 = (t_504.n * t_504.m)
              and m_526 = t_504.m in
              let rec loop_527 =
               fun i1_528 ->
                fun i2_529 ->
                 if (i2_529 < nm_525) then
                  let t_530 = a_524.(i1_528) in
                  a_524.(i1_528) <- a_524.(i2_529);
                  a_524.(i2_529) <- t_530;
                  (loop_527 (i1_528 + m_526) (i2_529 + m_526)) in
              (loop_527 t_515 (snd (fst i_517)));
              (t_508 := (~- (! t_508)))
             end;
             (t_509 := ((ColSwap ((snd (fst i_517)), t_514)) :: (! t_509)))
            end;
            if ((fst (fst i_517)) <> t_514) then begin
             begin
              let a_518 = t_504.arr
              and m_519 = t_504.m in
              let i1_520 = (t_514 * m_519)
              and i2_521 = ((snd (fst i_517)) * m_519) in
              for i_522 = t_515 to (m_519 - 1) do
               let t_523 = a_518.(i1_520 + i_522) in
               a_518.(i1_520 + i_522) <- a_518.(i2_521 + i_522);
               a_518.(i2_521 + i_522) <- t_523
              done;
              (t_508 := (~- (! t_508)))
             end;
             (t_509 := ((RowSwap ((fst (fst i_517)), t_514)) :: (! t_509)))
            end;
            (Some (snd i_517))
         | None -> (None))
       end in
      (match t_535 with
       | Some (i_536) ->
          begin
           for j_537 = (t_514 + 1) to (t_506 - 1) do
            let t_538 = (t_504.arr).((j_537 * t_504.m) + t_515) in
            if (t_538 <> 0) then begin
             for j_539 = (t_515 + 1) to (t_505 - 1) do
              (t_504.arr).((j_537 * t_504.m) + j_539) <-
               ((((t_504.arr).((j_537 * t_504.m) + j_539) * i_536) -
                  ((t_504.arr).((t_514 * t_504.m) + j_539) * t_538)) /
                 (! t_507))
             done;
             (t_504.arr).((j_537 * t_504.m) + t_515) <- 0
            end
           done;
           (t_507 := i_536)
          end;
          (t_502 := ((! t_502) + 1))
       | None -> (t_508 := 0));
      (t_503 := ((! t_503) + 1))
     done;
     (t_504,
      if ((! t_508) = 0) then 0
      else if ((! t_508) = 1) then (! t_507)
      else (~- (! t_507)), (! t_502), (! t_509))>.
val resFA11 : ('a, GAC_F.contr -> GenFA11.O.res) code =
  .<fun a_540 ->
     let t_541 = (ref 0) in
     let t_542 = (ref 0) in
     let t_544 =
      (Array.map (fun x_543 -> (Array.copy x_543)) (Array.copy a_540)) in
     let t_545 = (Array.length a_540.(0)) in
     let t_546 = (Array.length a_540) in
     while (((! t_542) < t_545) && ((! t_541) < t_546)) do
      let t_549 = (! t_541) in
      let t_550 = (! t_542) in
      let t_551 = (ref (None)) in
      let t_560 =
       begin
        for j_556 = t_549 to (t_546 - 1) do
         for j_557 = t_550 to (t_545 - 1) do
          let t_558 = (t_544.(j_556)).(j_557) in
          if (t_558 <> 0.) then
           (match (! t_551) with
            | Some (i_559) ->
               if ((abs_float (snd i_559)) < (abs_float t_558)) then
                (t_551 := (Some ((j_556, j_557), t_558)))
            | None -> (t_551 := (Some ((j_556, j_557), t_558))))
         done
        done;
        (match (! t_551) with
         | Some (i_552) ->
            if ((snd (fst i_552)) <> t_550) then
             for r_554 = 0 to ((Array.length t_544) - 1) do
              let t_555 = (t_544.(r_554)).(t_550) in
              (t_544.(r_554)).(t_550) <- (t_544.(r_554)).(snd (fst i_552));
              (t_544.(r_554)).(snd (fst i_552)) <- t_555
             done;
            if ((fst (fst i_552)) <> t_549) then
             let t_553 = t_544.(t_549) in
             t_544.(t_549) <- t_544.(snd (fst i_552));
             t_544.(snd (fst i_552)) <- t_553;
            (Some (snd i_552))
         | None -> (None))
       end in
      (match t_560 with
       | Some (i_561) ->
          begin
           for j_562 = (t_549 + 1) to (t_546 - 1) do
            let t_563 = (t_544.(j_562)).(t_550) in
            if (t_563 <> 0.) then begin
             for j_564 = (t_550 + 1) to (t_545 - 1) do
              (t_544.(j_562)).(j_564) <-
               ((t_544.(j_562)).(j_564) -.
                 ((t_563 /. i_561) *. (t_544.(t_549)).(j_564)))
             done;
             (t_544.(j_562)).(t_550) <- 0.
            end
           done;
           ()
          end;
          (t_541 := ((! t_541) + 1))
       | None -> ());
      (t_542 := ((! t_542) + 1))
     done;
     t_544>.
val resFA12 : ('a, GAC_F.contr -> GenFA12.O.res) code =
  .<fun a_565 ->
     let t_566 = (ref 0) in
     let t_567 = (ref 0) in
     let t_569 =
      (Array.map (fun x_568 -> (Array.copy x_568)) (Array.copy a_565)) in
     let t_570 = (Array.length a_565.(0)) in
     let t_571 = (Array.length a_565) in
     let t_572 = (ref 1.) in
     let t_573 = (ref 1) in
     while (((! t_567) < t_570) && ((! t_566) < t_571)) do
      let t_576 = (! t_566) in
      let t_577 = (! t_567) in
      let t_578 = (ref (None)) in
      let t_587 =
       begin
        for j_583 = t_576 to (t_571 - 1) do
         for j_584 = t_577 to (t_570 - 1) do
          let t_585 = (t_569.(j_583)).(j_584) in
          if (t_585 <> 0.) then
           (match (! t_578) with
            | Some (i_586) ->
               if ((abs_float (snd i_586)) < (abs_float t_585)) then
                (t_578 := (Some ((j_583, j_584), t_585)))
            | None -> (t_578 := (Some ((j_583, j_584), t_585))))
         done
        done;
        (match (! t_578) with
         | Some (i_579) ->
            if ((snd (fst i_579)) <> t_577) then begin
             for r_581 = 0 to ((Array.length t_569) - 1) do
              let t_582 = (t_569.(r_581)).(t_577) in
              (t_569.(r_581)).(t_577) <- (t_569.(r_581)).(snd (fst i_579));
              (t_569.(r_581)).(snd (fst i_579)) <- t_582
             done;
             (t_573 := (~- (! t_573)))
            end;
            if ((fst (fst i_579)) <> t_576) then begin
             let t_580 = t_569.(t_576) in
             t_569.(t_576) <- t_569.(snd (fst i_579));
             t_569.(snd (fst i_579)) <- t_580;
             (t_573 := (~- (! t_573)))
            end;
            (Some (snd i_579))
         | None -> (None))
       end in
      (match t_587 with
       | Some (i_588) ->
          begin
           for j_589 = (t_576 + 1) to (t_571 - 1) do
            let t_590 = (t_569.(j_589)).(t_577) in
            if (t_590 <> 0.) then begin
             for j_591 = (t_577 + 1) to (t_570 - 1) do
              (t_569.(j_589)).(j_591) <-
               ((t_569.(j_589)).(j_591) -.
                 ((t_590 /. i_588) *. (t_569.(t_576)).(j_591)))
             done;
             (t_569.(j_589)).(t_577) <- 0.
            end
           done;
           (t_572 := ((! t_572) *. i_588))
          end;
          (t_566 := ((! t_566) + 1))
       | None -> (t_573 := 0));
      (t_567 := ((! t_567) + 1))
     done;
     (t_569,
      if ((! t_573) = 0) then 0.
      else if ((! t_573) = 1) then (! t_572)
      else (~-. (! t_572)))>.
val resFA13 : ('a, GAC_F.contr -> GenFA13.O.res) code =
  .<fun a_592 ->
     let t_593 = (ref 0) in
     let t_594 = (ref 0) in
     let t_596 =
      (Array.map (fun x_595 -> (Array.copy x_595)) (Array.copy a_592)) in
     let t_597 = (Array.length a_592.(0)) in
     let t_598 = (Array.length a_592) in
     while (((! t_594) < t_597) && ((! t_593) < t_598)) do
      let t_601 = (! t_593) in
      let t_602 = (! t_594) in
      let t_603 = (ref (None)) in
      let t_612 =
       begin
        for j_608 = t_601 to (t_598 - 1) do
         for j_609 = t_602 to (t_597 - 1) do
          let t_610 = (t_596.(j_608)).(j_609) in
          if (t_610 <> 0.) then
           (match (! t_603) with
            | Some (i_611) ->
               if ((abs_float (snd i_611)) < (abs_float t_610)) then
                (t_603 := (Some ((j_608, j_609), t_610)))
            | None -> (t_603 := (Some ((j_608, j_609), t_610))))
         done
        done;
        (match (! t_603) with
         | Some (i_604) ->
            if ((snd (fst i_604)) <> t_602) then
             for r_606 = 0 to ((Array.length t_596) - 1) do
              let t_607 = (t_596.(r_606)).(t_602) in
              (t_596.(r_606)).(t_602) <- (t_596.(r_606)).(snd (fst i_604));
              (t_596.(r_606)).(snd (fst i_604)) <- t_607
             done;
            if ((fst (fst i_604)) <> t_601) then
             let t_605 = t_596.(t_601) in
             t_596.(t_601) <- t_596.(snd (fst i_604));
             t_596.(snd (fst i_604)) <- t_605;
            (Some (snd i_604))
         | None -> (None))
       end in
      (match t_612 with
       | Some (i_613) ->
          begin
           for j_614 = (t_601 + 1) to (t_598 - 1) do
            let t_615 = (t_596.(j_614)).(t_602) in
            if (t_615 <> 0.) then begin
             for j_616 = (t_602 + 1) to (t_597 - 1) do
              (t_596.(j_614)).(j_616) <-
               ((t_596.(j_614)).(j_616) -.
                 ((t_615 /. i_613) *. (t_596.(t_601)).(j_616)))
             done;
             (t_596.(j_614)).(t_602) <- 0.
            end
           done;
           ()
          end;
          (t_593 := ((! t_593) + 1))
       | None -> ());
      (t_594 := ((! t_594) + 1))
     done;
     (t_596, (! t_593))>.
val resFA14 : ('a, GAC_F.contr -> GenFA14.O.res) code =
  .<fun a_617 ->
     let t_618 = (ref 0) in
     let t_619 = (ref 0) in
     let t_621 =
      (Array.map (fun x_620 -> (Array.copy x_620)) (Array.copy a_617)) in
     let t_622 = (Array.length a_617.(0)) in
     let t_623 = (Array.length a_617) in
     let t_624 = (ref 1.) in
     let t_625 = (ref 1) in
     while (((! t_619) < t_622) && ((! t_618) < t_623)) do
      let t_628 = (! t_618) in
      let t_629 = (! t_619) in
      let t_630 = (ref (None)) in
      let t_639 =
       begin
        for j_635 = t_628 to (t_623 - 1) do
         for j_636 = t_629 to (t_622 - 1) do
          let t_637 = (t_621.(j_635)).(j_636) in
          if (t_637 <> 0.) then
           (match (! t_630) with
            | Some (i_638) ->
               if ((abs_float (snd i_638)) < (abs_float t_637)) then
                (t_630 := (Some ((j_635, j_636), t_637)))
            | None -> (t_630 := (Some ((j_635, j_636), t_637))))
         done
        done;
        (match (! t_630) with
         | Some (i_631) ->
            if ((snd (fst i_631)) <> t_629) then begin
             for r_633 = 0 to ((Array.length t_621) - 1) do
              let t_634 = (t_621.(r_633)).(t_629) in
              (t_621.(r_633)).(t_629) <- (t_621.(r_633)).(snd (fst i_631));
              (t_621.(r_633)).(snd (fst i_631)) <- t_634
             done;
             (t_625 := (~- (! t_625)))
            end;
            if ((fst (fst i_631)) <> t_628) then begin
             let t_632 = t_621.(t_628) in
             t_621.(t_628) <- t_621.(snd (fst i_631));
             t_621.(snd (fst i_631)) <- t_632;
             (t_625 := (~- (! t_625)))
            end;
            (Some (snd i_631))
         | None -> (None))
       end in
      (match t_639 with
       | Some (i_640) ->
          begin
           for j_641 = (t_628 + 1) to (t_623 - 1) do
            let t_642 = (t_621.(j_641)).(t_629) in
            if (t_642 <> 0.) then begin
             for j_643 = (t_629 + 1) to (t_622 - 1) do
              (t_621.(j_641)).(j_643) <-
               ((t_621.(j_641)).(j_643) -.
                 ((t_642 /. i_640) *. (t_621.(t_628)).(j_643)))
             done;
             (t_621.(j_641)).(t_629) <- 0.
            end
           done;
           (t_624 := ((! t_624) *. i_640))
          end;
          (t_618 := ((! t_618) + 1))
       | None -> (t_625 := 0));
      (t_619 := ((! t_619) + 1))
     done;
     (t_621,
      if ((! t_625) = 0) then 0.
      else if ((! t_625) = 1) then (! t_624)
      else (~-. (! t_624)), (! t_618))>.
val resFA24 : ('a, GAC_F.contr -> GenFA24.O.res) code =
  .<fun a_644 ->
     let t_645 = (ref 0) in
     let t_646 = (ref 0) in
     let t_648 =
      (Array.map (fun x_647 -> (Array.copy x_647)) (Array.copy a_644)) in
     let t_649 = (Array.length a_644.(0)) in
     let t_650 = (Array.length a_644) in
     let t_651 = (ref 1.) in
     let t_652 = (ref 1) in
     let t_653 = (ref ([])) in
     while (((! t_646) < t_649) && ((! t_645) < t_650)) do
      let t_656 = (! t_645) in
      let t_657 = (! t_646) in
      let t_658 = (ref (None)) in
      let t_664 =
       begin
        for j_661 = t_656 to (t_650 - 1) do
         let t_662 = (t_648.(j_661)).(t_657) in
         if (t_662 <> 0.) then
          (match (! t_658) with
           | Some (i_663) ->
              if ((abs_float (snd i_663)) < (abs_float t_662)) then
               (t_658 := (Some (j_661, t_662)))
           | None -> (t_658 := (Some (j_661, t_662))))
        done;
        (match (! t_658) with
         | Some (i_659) ->
            if ((fst i_659) <> t_656) then begin
             begin
              let t_660 = t_648.(t_656) in
              t_648.(t_656) <- t_648.(fst i_659);
              t_648.(fst i_659) <- t_660;
              (t_652 := (~- (! t_652)))
             end;
             (t_653 := ((RowSwap ((fst i_659), t_656)) :: (! t_653)))
            end;
            (Some (snd i_659))
         | None -> (None))
       end in
      (match t_664 with
       | Some (i_665) ->
          begin
           for j_666 = (t_656 + 1) to (t_650 - 1) do
            let t_667 = (t_648.(j_666)).(t_657) in
            if (t_667 <> 0.) then begin
             for j_668 = (t_657 + 1) to (t_649 - 1) do
              (t_648.(j_666)).(j_668) <-
               ((t_648.(j_666)).(j_668) -.
                 ((t_667 /. i_665) *. (t_648.(t_656)).(j_668)))
             done;
             (t_648.(j_666)).(t_657) <- 0.
            end
           done;
           (t_651 := ((! t_651) *. i_665))
          end;
          (t_645 := ((! t_645) + 1))
       | None -> (t_652 := 0));
      (t_646 := ((! t_646) + 1))
     done;
     (t_648,
      if ((! t_652) = 0) then 0.
      else if ((! t_652) = 1) then (! t_651)
      else (~-. (! t_651)), (! t_645), (! t_653))>.
val resFA25 : ('a, GAC_F.contr -> GenFA25.O.res) code =
  .<fun a_669 ->
     let t_670 = (ref 0) in
     let t_671 = (ref 0) in
     let t_673 =
      (Array.map (fun x_672 -> (Array.copy x_672)) (Array.copy a_669)) in
     let t_674 = (Array.length a_669.(0)) in
     let t_675 = (Array.length a_669) in
     let t_676 = (ref 1.) in
     let t_677 = (ref 1) in
     let t_679 = (ref (Array.init t_675 (fun i_678 -> i_678))) in
     while (((! t_671) < t_674) && ((! t_670) < t_675)) do
      let t_682 = (! t_670) in
      let t_683 = (! t_671) in
      let t_684 = (ref (None)) in
      let t_694 =
       begin
        for j_691 = t_682 to (t_675 - 1) do
         let t_692 = (t_673.(j_691)).(t_683) in
         if (t_692 <> 0.) then
          (match (! t_684) with
           | Some (i_693) ->
              if ((abs_float (snd i_693)) < (abs_float t_692)) then
               (t_684 := (Some (j_691, t_692)))
           | None -> (t_684 := (Some (j_691, t_692))))
        done;
        (match (! t_684) with
         | Some (i_685) ->
            if ((fst i_685) <> t_682) then begin
             begin
              let t_686 = t_673.(t_682) in
              t_673.(t_682) <- t_673.(fst i_685);
              t_673.(fst i_685) <- t_686;
              (t_677 := (~- (! t_677)))
             end;
             (t_679 :=
               let (x_687, y_688) = ((fst i_685), t_682) in
               let b_689 = (! t_679)
               and t_690 = (! t_679).(x_687) in
               b_689.(x_687) <- b_689.(y_688);
               b_689.(y_688) <- t_690;
               b_689)
            end;
            (Some (snd i_685))
         | None -> (None))
       end in
      (match t_694 with
       | Some (i_695) ->
          begin
           for j_696 = (t_682 + 1) to (t_675 - 1) do
            let t_697 = (t_673.(j_696)).(t_683) in
            if (t_697 <> 0.) then begin
             for j_698 = (t_683 + 1) to (t_674 - 1) do
              (t_673.(j_696)).(j_698) <-
               ((t_673.(j_696)).(j_698) -.
                 ((t_697 /. i_695) *. (t_673.(t_682)).(j_698)))
             done;
             (t_673.(j_696)).(t_683) <- 0.
            end
           done;
           (t_676 := ((! t_676) *. i_695))
          end;
          (t_670 := ((! t_670) + 1))
       | None -> (t_677 := 0));
      (t_671 := ((! t_671) + 1))
     done;
     (t_673,
      if ((! t_677) = 0) then 0.
      else if ((! t_677) = 1) then (! t_676)
      else (~-. (! t_676)), (! t_670), (! t_679))>.
val resFA26 : ('a, GAC_F.contr -> GenFA26.O.res) code =
  .<fun a_699 ->
     let t_700 = (ref 0) in
     let t_701 = (ref 0) in
     let t_703 =
      (Array.map (fun x_702 -> (Array.copy x_702)) (Array.copy a_699)) in
     let t_704 = (Array.length a_699.(0)) in
     let t_705 = (Array.length a_699) in
     while (((! t_701) < t_704) && ((! t_700) < t_705)) do
      let t_708 = (! t_700) in
      let t_709 = (! t_701) in
      let t_710 = (ref (None)) in
      let t_716 =
       begin
        for j_713 = t_708 to (t_705 - 1) do
         let t_714 = (t_703.(j_713)).(t_709) in
         if (t_714 <> 0.) then
          (match (! t_710) with
           | Some (i_715) ->
              if ((abs_float (snd i_715)) < (abs_float t_714)) then
               (t_710 := (Some (j_713, t_714)))
           | None -> (t_710 := (Some (j_713, t_714))))
        done;
        (match (! t_710) with
         | Some (i_711) ->
            if ((fst i_711) <> t_708) then
             let t_712 = t_703.(t_708) in
             t_703.(t_708) <- t_703.(fst i_711);
             t_703.(fst i_711) <- t_712;
            (Some (snd i_711))
         | None -> (None))
       end in
      (match t_716 with
       | Some (i_717) ->
          begin
           for j_718 = (t_708 + 1) to (t_705 - 1) do
            let t_719 = (t_703.(j_718)).(t_709) in
            if (t_719 <> 0.) then begin
             for j_720 = (t_709 + 1) to (t_704 - 1) do
              (t_703.(j_718)).(j_720) <-
               ((t_703.(j_718)).(j_720) -.
                 ((t_719 /. i_717) *. (t_703.(t_708)).(j_720)))
             done;
             (t_703.(j_718)).(t_709) <- 0.
            end
           done;
           ()
          end;
          (t_700 := ((! t_700) + 1))
       | None -> ());
      (t_701 := ((! t_701) + 1))
     done;
     t_703>.
val resRA1 : ('a, GAC_R.contr -> GenRA1.O.res) code =
  .<fun a_721 ->
     let t_722 = (ref 0) in
     let t_723 = (ref 0) in
     let t_725 =
      (Array.map (fun x_724 -> (Array.copy x_724)) (Array.copy a_721)) in
     let t_726 = (Array.length a_721.(0)) in
     let t_727 = (Array.length a_721) in
     while (((! t_723) < t_726) && ((! t_722) < t_727)) do
      let t_730 = (! t_722) in
      let t_731 = (! t_723) in
      let t_732 = (ref (None)) in
      let t_739 =
       begin
        let t_735 = (t_725.(t_730)).(t_731) in
        if (t_735 <> (* cross-stage persistent value (as id: zero) *)) then
         (t_732 := (Some (t_730, t_735)))
        else
         let rec loop_736 =
          fun j_737 ->
           if (j_737 < t_727) then
            let t_738 = (t_725.(j_737)).(t_731) in
            if (t_738 = (* cross-stage persistent value (as id: zero) *)) then
             (loop_736 (j_737 + 1))
            else (t_732 := (Some (j_737, t_738))) in
         (loop_736 (t_730 + 1));
        (match (! t_732) with
         | Some (i_733) ->
            if ((fst i_733) <> t_730) then
             let t_734 = t_725.(t_730) in
             t_725.(t_730) <- t_725.(fst i_733);
             t_725.(fst i_733) <- t_734;
            (Some (snd i_733))
         | None -> (None))
       end in
      (match t_739 with
       | Some (i_740) ->
          begin
           for j_741 = (t_730 + 1) to (t_727 - 1) do
            let t_742 = (t_725.(j_741)).(t_731) in
            if (t_742 <> (* cross-stage persistent value (as id: zero) *)) then begin
             for j_743 = (t_731 + 1) to (t_726 - 1) do
              (t_725.(j_741)).(j_743) <-
               (((* cross-stage persistent value (as id: Num.sub_num) *))
                 (t_725.(j_741)).(j_743)
                 (((* cross-stage persistent value (as id: Num.mult_num) *))
                   (((* cross-stage persistent value (as id: Num.div_num) *))
                     t_742 i_740) (t_725.(t_730)).(j_743)))
             done;
             (t_725.(j_741)).(t_731) <-
              (* cross-stage persistent value (as id: zero) *)
            end
           done;
           ()
          end;
          (t_722 := ((! t_722) + 1))
       | None -> ());
      (t_723 := ((! t_723) + 1))
     done;
     t_725>.
val resRA2 : ('a, GAC_R.contr -> GenRA2.O.res) code =
  .<fun a_744 ->
     let t_745 = (ref 0) in
     let t_746 = (ref 0) in
     let t_748 =
      (Array.map (fun x_747 -> (Array.copy x_747)) (Array.copy a_744)) in
     let t_749 = (Array.length a_744.(0)) in
     let t_750 = (Array.length a_744) in
     let t_751 = (ref (* cross-stage persistent value (as id: one) *)) in
     let t_752 = (ref 1) in
     while (((! t_746) < t_749) && ((! t_745) < t_750)) do
      let t_755 = (! t_745) in
      let t_756 = (! t_746) in
      let t_757 = (ref (None)) in
      let t_764 =
       begin
        let t_760 = (t_748.(t_755)).(t_756) in
        if (t_760 <> (* cross-stage persistent value (as id: zero) *)) then
         (t_757 := (Some (t_755, t_760)))
        else
         let rec loop_761 =
          fun j_762 ->
           if (j_762 < t_750) then
            let t_763 = (t_748.(j_762)).(t_756) in
            if (t_763 = (* cross-stage persistent value (as id: zero) *)) then
             (loop_761 (j_762 + 1))
            else (t_757 := (Some (j_762, t_763))) in
         (loop_761 (t_755 + 1));
        (match (! t_757) with
         | Some (i_758) ->
            if ((fst i_758) <> t_755) then begin
             let t_759 = t_748.(t_755) in
             t_748.(t_755) <- t_748.(fst i_758);
             t_748.(fst i_758) <- t_759;
             (t_752 := (~- (! t_752)))
            end;
            (Some (snd i_758))
         | None -> (None))
       end in
      (match t_764 with
       | Some (i_765) ->
          begin
           for j_766 = (t_755 + 1) to (t_750 - 1) do
            let t_767 = (t_748.(j_766)).(t_756) in
            if (t_767 <> (* cross-stage persistent value (as id: zero) *)) then begin
             for j_768 = (t_756 + 1) to (t_749 - 1) do
              (t_748.(j_766)).(j_768) <-
               (((* cross-stage persistent value (as id: Num.sub_num) *))
                 (t_748.(j_766)).(j_768)
                 (((* cross-stage persistent value (as id: Num.mult_num) *))
                   (((* cross-stage persistent value (as id: Num.div_num) *))
                     t_767 i_765) (t_748.(t_755)).(j_768)))
             done;
             (t_748.(j_766)).(t_756) <-
              (* cross-stage persistent value (as id: zero) *)
            end
           done;
           (t_751 :=
             (((* cross-stage persistent value (as id: Num.mult_num) *))
               (! t_751) i_765))
          end;
          (t_745 := ((! t_745) + 1))
       | None -> (t_752 := 0));
      (t_746 := ((! t_746) + 1))
     done;
     (t_748,
      if ((! t_752) = 0) then
       (* cross-stage persistent value (as id: zero) *)
      else if ((! t_752) = 1) then (! t_751)
      else
       (((* cross-stage persistent value (as id: Num.minus_num) *))
         (! t_751)))>.
val resRA3 : ('a, GAC_R.contr -> GenRA3.O.res) code =
  .<fun a_769 ->
     let t_770 = (ref 0) in
     let t_771 = (ref 0) in
     let t_773 =
      (Array.map (fun x_772 -> (Array.copy x_772)) (Array.copy a_769)) in
     let t_774 = (Array.length a_769.(0)) in
     let t_775 = (Array.length a_769) in
     while (((! t_771) < t_774) && ((! t_770) < t_775)) do
      let t_778 = (! t_770) in
      let t_779 = (! t_771) in
      let t_780 = (ref (None)) in
      let t_787 =
       begin
        let t_783 = (t_773.(t_778)).(t_779) in
        if (t_783 <> (* cross-stage persistent value (as id: zero) *)) then
         (t_780 := (Some (t_778, t_783)))
        else
         let rec loop_784 =
          fun j_785 ->
           if (j_785 < t_775) then
            let t_786 = (t_773.(j_785)).(t_779) in
            if (t_786 = (* cross-stage persistent value (as id: zero) *)) then
             (loop_784 (j_785 + 1))
            else (t_780 := (Some (j_785, t_786))) in
         (loop_784 (t_778 + 1));
        (match (! t_780) with
         | Some (i_781) ->
            if ((fst i_781) <> t_778) then
             let t_782 = t_773.(t_778) in
             t_773.(t_778) <- t_773.(fst i_781);
             t_773.(fst i_781) <- t_782;
            (Some (snd i_781))
         | None -> (None))
       end in
      (match t_787 with
       | Some (i_788) ->
          begin
           for j_789 = (t_778 + 1) to (t_775 - 1) do
            let t_790 = (t_773.(j_789)).(t_779) in
            if (t_790 <> (* cross-stage persistent value (as id: zero) *)) then begin
             for j_791 = (t_779 + 1) to (t_774 - 1) do
              (t_773.(j_789)).(j_791) <-
               (((* cross-stage persistent value (as id: Num.sub_num) *))
                 (t_773.(j_789)).(j_791)
                 (((* cross-stage persistent value (as id: Num.mult_num) *))
                   (((* cross-stage persistent value (as id: Num.div_num) *))
                     t_790 i_788) (t_773.(t_778)).(j_791)))
             done;
             (t_773.(j_789)).(t_779) <-
              (* cross-stage persistent value (as id: zero) *)
            end
           done;
           ()
          end;
          (t_770 := ((! t_770) + 1))
       | None -> ());
      (t_771 := ((! t_771) + 1))
     done;
     (t_773, (! t_770))>.
val resRA4 : ('a, GAC_R.contr -> GenRA4.O.res) code =
  .<fun a_792 ->
     let t_793 = (ref 0) in
     let t_794 = (ref 0) in
     let t_796 =
      (Array.map (fun x_795 -> (Array.copy x_795)) (Array.copy a_792)) in
     let t_797 = (Array.length a_792.(0)) in
     let t_798 = (Array.length a_792) in
     let t_799 = (ref (* cross-stage persistent value (as id: one) *)) in
     let t_800 = (ref 1) in
     while (((! t_794) < t_797) && ((! t_793) < t_798)) do
      let t_803 = (! t_793) in
      let t_804 = (! t_794) in
      let t_805 = (ref (None)) in
      let t_812 =
       begin
        let t_808 = (t_796.(t_803)).(t_804) in
        if (t_808 <> (* cross-stage persistent value (as id: zero) *)) then
         (t_805 := (Some (t_803, t_808)))
        else
         let rec loop_809 =
          fun j_810 ->
           if (j_810 < t_798) then
            let t_811 = (t_796.(j_810)).(t_804) in
            if (t_811 = (* cross-stage persistent value (as id: zero) *)) then
             (loop_809 (j_810 + 1))
            else (t_805 := (Some (j_810, t_811))) in
         (loop_809 (t_803 + 1));
        (match (! t_805) with
         | Some (i_806) ->
            if ((fst i_806) <> t_803) then begin
             let t_807 = t_796.(t_803) in
             t_796.(t_803) <- t_796.(fst i_806);
             t_796.(fst i_806) <- t_807;
             (t_800 := (~- (! t_800)))
            end;
            (Some (snd i_806))
         | None -> (None))
       end in
      (match t_812 with
       | Some (i_813) ->
          begin
           for j_814 = (t_803 + 1) to (t_798 - 1) do
            let t_815 = (t_796.(j_814)).(t_804) in
            if (t_815 <> (* cross-stage persistent value (as id: zero) *)) then begin
             for j_816 = (t_804 + 1) to (t_797 - 1) do
              (t_796.(j_814)).(j_816) <-
               (((* cross-stage persistent value (as id: Num.sub_num) *))
                 (t_796.(j_814)).(j_816)
                 (((* cross-stage persistent value (as id: Num.mult_num) *))
                   (((* cross-stage persistent value (as id: Num.div_num) *))
                     t_815 i_813) (t_796.(t_803)).(j_816)))
             done;
             (t_796.(j_814)).(t_804) <-
              (* cross-stage persistent value (as id: zero) *)
            end
           done;
           (t_799 :=
             (((* cross-stage persistent value (as id: Num.mult_num) *))
               (! t_799) i_813))
          end;
          (t_793 := ((! t_793) + 1))
       | None -> (t_800 := 0));
      (t_794 := ((! t_794) + 1))
     done;
     (t_796,
      if ((! t_800) = 0) then
       (* cross-stage persistent value (as id: zero) *)
      else if ((! t_800) = 1) then (! t_799)
      else
       (((* cross-stage persistent value (as id: Num.minus_num) *))
         (! t_799)), (! t_793))>.
val resFA5 : ('a, GAC_F.contr * int -> GenFA5.O.res) code =
  .<fun a_817 ->
     let t_818 = (ref 0) in
     let t_819 = (ref 0) in
     let t_821 =
      (Array.map (fun x_820 -> (Array.copy x_820)) (Array.copy (fst a_817))) in
     let t_822 = (Array.length (fst a_817).(0)) in
     let t_823 = (snd a_817) in
     let t_824 = (Array.length (fst a_817)) in
     while (((! t_819) < t_822) && ((! t_818) < t_823)) do
      let t_827 = (! t_818) in
      let t_828 = (! t_819) in
      let t_829 = (ref (None)) in
      let t_835 =
       begin
        for j_832 = t_827 to (t_824 - 1) do
         let t_833 = (t_821.(j_832)).(t_828) in
         if (t_833 <> 0.) then
          (match (! t_829) with
           | Some (i_834) ->
              if ((abs_float (snd i_834)) < (abs_float t_833)) then
               (t_829 := (Some (j_832, t_833)))
           | None -> (t_829 := (Some (j_832, t_833))))
        done;
        (match (! t_829) with
         | Some (i_830) ->
            if ((fst i_830) <> t_827) then
             let t_831 = t_821.(t_827) in
             t_821.(t_827) <- t_821.(fst i_830);
             t_821.(fst i_830) <- t_831;
            (Some (snd i_830))
         | None -> (None))
       end in
      (match t_835 with
       | Some (i_836) ->
          begin
           for j_837 = (t_827 + 1) to (t_824 - 1) do
            let t_838 = (t_821.(j_837)).(t_828) in
            if (t_838 <> 0.) then begin
             for j_839 = (t_828 + 1) to (t_822 - 1) do
              (t_821.(j_837)).(j_839) <-
               ((t_821.(j_837)).(j_839) -.
                 ((t_838 /. i_836) *. (t_821.(t_827)).(j_839)))
             done;
             (t_821.(j_837)).(t_828) <- 0.
            end
           done;
           ()
          end;
          (t_818 := ((! t_818) + 1))
       | None -> ());
      (t_819 := ((! t_819) + 1))
     done;
     t_821>.
val resFA6 : ('a, GAC_F.contr * int -> GenFA6.O.res) code =
  .<fun a_840 ->
     let t_841 = (ref 0) in
     let t_842 = (ref 0) in
     let t_844 =
      (Array.map (fun x_843 -> (Array.copy x_843)) (Array.copy (fst a_840))) in
     let t_845 = (Array.length (fst a_840).(0)) in
     let t_846 = (snd a_840) in
     let t_847 = (Array.length (fst a_840)) in
     let t_848 = (ref 1.) in
     let t_849 = (ref 1) in
     while (((! t_842) < t_845) && ((! t_841) < t_846)) do
      let t_852 = (! t_841) in
      let t_853 = (! t_842) in
      let t_854 = (ref (None)) in
      let t_860 =
       begin
        for j_857 = t_852 to (t_847 - 1) do
         let t_858 = (t_844.(j_857)).(t_853) in
         if (t_858 <> 0.) then
          (match (! t_854) with
           | Some (i_859) ->
              if ((abs_float (snd i_859)) < (abs_float t_858)) then
               (t_854 := (Some (j_857, t_858)))
           | None -> (t_854 := (Some (j_857, t_858))))
        done;
        (match (! t_854) with
         | Some (i_855) ->
            if ((fst i_855) <> t_852) then begin
             let t_856 = t_844.(t_852) in
             t_844.(t_852) <- t_844.(fst i_855);
             t_844.(fst i_855) <- t_856;
             (t_849 := (~- (! t_849)))
            end;
            (Some (snd i_855))
         | None -> (None))
       end in
      (match t_860 with
       | Some (i_861) ->
          begin
           for j_862 = (t_852 + 1) to (t_847 - 1) do
            let t_863 = (t_844.(j_862)).(t_853) in
            if (t_863 <> 0.) then begin
             for j_864 = (t_853 + 1) to (t_845 - 1) do
              (t_844.(j_862)).(j_864) <-
               ((t_844.(j_862)).(j_864) -.
                 ((t_863 /. i_861) *. (t_844.(t_852)).(j_864)))
             done;
             (t_844.(j_862)).(t_853) <- 0.
            end
           done;
           (t_848 := ((! t_848) *. i_861))
          end;
          (t_841 := ((! t_841) + 1))
       | None -> (t_849 := 0));
      (t_842 := ((! t_842) + 1))
     done;
     (t_844,
      if ((! t_849) = 0) then 0.
      else if ((! t_849) = 1) then (! t_848)
      else (~-. (! t_848)))>.
val resFA7 : ('a, GAC_F.contr * int -> GenFA7.O.res) code =
  .<fun a_865 ->
     let t_866 = (ref 0) in
     let t_867 = (ref 0) in
     let t_869 =
      (Array.map (fun x_868 -> (Array.copy x_868)) (Array.copy (fst a_865))) in
     let t_870 = (Array.length (fst a_865).(0)) in
     let t_871 = (snd a_865) in
     let t_872 = (Array.length (fst a_865)) in
     while (((! t_867) < t_870) && ((! t_866) < t_871)) do
      let t_875 = (! t_866) in
      let t_876 = (! t_867) in
      let t_877 = (ref (None)) in
      let t_883 =
       begin
        for j_880 = t_875 to (t_872 - 1) do
         let t_881 = (t_869.(j_880)).(t_876) in
         if (t_881 <> 0.) then
          (match (! t_877) with
           | Some (i_882) ->
              if ((abs_float (snd i_882)) < (abs_float t_881)) then
               (t_877 := (Some (j_880, t_881)))
           | None -> (t_877 := (Some (j_880, t_881))))
        done;
        (match (! t_877) with
         | Some (i_878) ->
            if ((fst i_878) <> t_875) then
             let t_879 = t_869.(t_875) in
             t_869.(t_875) <- t_869.(fst i_878);
             t_869.(fst i_878) <- t_879;
            (Some (snd i_878))
         | None -> (None))
       end in
      (match t_883 with
       | Some (i_884) ->
          begin
           for j_885 = (t_875 + 1) to (t_872 - 1) do
            let t_886 = (t_869.(j_885)).(t_876) in
            if (t_886 <> 0.) then begin
             for j_887 = (t_876 + 1) to (t_870 - 1) do
              (t_869.(j_885)).(j_887) <-
               ((t_869.(j_885)).(j_887) -.
                 ((t_886 /. i_884) *. (t_869.(t_875)).(j_887)))
             done;
             (t_869.(j_885)).(t_876) <- 0.
            end
           done;
           ()
          end;
          (t_866 := ((! t_866) + 1))
       | None -> ());
      (t_867 := ((! t_867) + 1))
     done;
     (t_869, (! t_866))>.
val resFA8 : ('a, GAC_F.contr * int -> GenFA8.O.res) code =
  .<fun a_888 ->
     let t_889 = (ref 0) in
     let t_890 = (ref 0) in
     let t_892 =
      (Array.map (fun x_891 -> (Array.copy x_891)) (Array.copy (fst a_888))) in
     let t_893 = (Array.length (fst a_888).(0)) in
     let t_894 = (snd a_888) in
     let t_895 = (Array.length (fst a_888)) in
     let t_896 = (ref 1.) in
     let t_897 = (ref 1) in
     while (((! t_890) < t_893) && ((! t_889) < t_894)) do
      let t_900 = (! t_889) in
      let t_901 = (! t_890) in
      let t_902 = (ref (None)) in
      let t_908 =
       begin
        for j_905 = t_900 to (t_895 - 1) do
         let t_906 = (t_892.(j_905)).(t_901) in
         if (t_906 <> 0.) then
          (match (! t_902) with
           | Some (i_907) ->
              if ((abs_float (snd i_907)) < (abs_float t_906)) then
               (t_902 := (Some (j_905, t_906)))
           | None -> (t_902 := (Some (j_905, t_906))))
        done;
        (match (! t_902) with
         | Some (i_903) ->
            if ((fst i_903) <> t_900) then begin
             let t_904 = t_892.(t_900) in
             t_892.(t_900) <- t_892.(fst i_903);
             t_892.(fst i_903) <- t_904;
             (t_897 := (~- (! t_897)))
            end;
            (Some (snd i_903))
         | None -> (None))
       end in
      (match t_908 with
       | Some (i_909) ->
          begin
           for j_910 = (t_900 + 1) to (t_895 - 1) do
            let t_911 = (t_892.(j_910)).(t_901) in
            if (t_911 <> 0.) then begin
             for j_912 = (t_901 + 1) to (t_893 - 1) do
              (t_892.(j_910)).(j_912) <-
               ((t_892.(j_910)).(j_912) -.
                 ((t_911 /. i_909) *. (t_892.(t_900)).(j_912)))
             done;
             (t_892.(j_910)).(t_901) <- 0.
            end
           done;
           (t_896 := ((! t_896) *. i_909))
          end;
          (t_889 := ((! t_889) + 1))
       | None -> (t_897 := 0));
      (t_890 := ((! t_890) + 1))
     done;
     (t_892,
      if ((! t_897) = 0) then 0.
      else if ((! t_897) = 1) then (! t_896)
      else (~-. (! t_896)), (! t_889))>.
val resFA9 : ('a, GAC_F.contr -> GenFA9.O.res) code =
  .<fun a_913 ->
     let t_914 = (ref 0) in
     let t_915 = (ref 0) in
     let t_917 =
      (Array.map (fun x_916 -> (Array.copy x_916)) (Array.copy a_913)) in
     let t_918 = (Array.length a_913.(0)) in
     let t_919 = (Array.length a_913) in
     let t_920 = (ref ([])) in
     while (((! t_915) < t_918) && ((! t_914) < t_919)) do
      let t_921 = (! t_914) in
      let t_922 = (! t_915) in
      let t_923 = (ref (None)) in
      let t_929 =
       begin
        for j_926 = t_921 to (t_919 - 1) do
         let t_927 = (t_917.(j_926)).(t_922) in
         if (t_927 <> 0.) then
          (match (! t_923) with
           | Some (i_928) ->
              if ((abs_float (snd i_928)) < (abs_float t_927)) then
               (t_923 := (Some (j_926, t_927)))
           | None -> (t_923 := (Some (j_926, t_927))))
        done;
        (match (! t_923) with
         | Some (i_924) ->
            if ((fst i_924) <> t_921) then begin
             let t_925 = t_917.(t_921) in
             t_917.(t_921) <- t_917.(fst i_924);
             t_917.(fst i_924) <- t_925;
             (t_920 := ((RowSwap ((fst i_924), t_921)) :: (! t_920)))
            end;
            (Some (snd i_924))
         | None -> (None))
       end in
      (match t_929 with
       | Some (i_930) ->
          begin
           for j_931 = (t_921 + 1) to (t_919 - 1) do
            let t_932 = (t_917.(j_931)).(t_922) in
            if (t_932 <> 0.) then
             for j_933 = (t_922 + 1) to (t_918 - 1) do
              (t_917.(j_931)).(j_933) <-
               ((t_917.(j_931)).(j_933) -.
                 ((t_932 /. i_930) *. (t_917.(t_921)).(j_933)))
             done
           done;
           ()
          end;
          (t_914 := ((! t_914) + 1))
       | None -> ());
      (t_915 := ((! t_915) + 1))
     done;
     (t_917, (! t_920))>.
val resFA31 : ('a, GAC_F.contr -> GenFA31.O.res) code =
  .<fun a_934 ->
     let t_935 = (ref 0) in
     let t_936 = (ref 0) in
     let t_938 =
      (Array.map (fun x_937 -> (Array.copy x_937)) (Array.copy a_934)) in
     let t_939 = (Array.length a_934.(0)) in
     let t_940 = (Array.length a_934) in
     let t_941 = (ref ([])) in
     let t_944 =
      (Array.init t_940
        (fun i_942 ->
          (Array.init t_939
            (fun j_943 -> if (i_942 = j_943) then 1. else 0.)))) in
     while (((! t_936) < t_939) && ((! t_935) < t_940)) do
      let t_945 = (! t_935) in
      let t_946 = (! t_936) in
      let t_947 = (ref (None)) in
      let t_953 =
       begin
        for j_950 = t_945 to (t_940 - 1) do
         let t_951 = (t_938.(j_950)).(t_946) in
         if (t_951 <> 0.) then
          (match (! t_947) with
           | Some (i_952) ->
              if ((abs_float (snd i_952)) < (abs_float t_951)) then
               (t_947 := (Some (j_950, t_951)))
           | None -> (t_947 := (Some (j_950, t_951))))
        done;
        (match (! t_947) with
         | Some (i_948) ->
            if ((fst i_948) <> t_945) then begin
             let t_949 = t_938.(t_945) in
             t_938.(t_945) <- t_938.(fst i_948);
             t_938.(fst i_948) <- t_949;
             (t_941 := ((RowSwap ((fst i_948), t_945)) :: (! t_941)))
            end;
            (Some (snd i_948))
         | None -> (None))
       end in
      (match t_953 with
       | Some (i_954) ->
          begin
           for j_955 = (t_945 + 1) to (t_940 - 1) do
            let t_956 = (t_938.(j_955)).(t_946) in
            if (t_956 <> 0.) then begin
             for j_957 = (t_946 + 1) to (t_939 - 1) do
              (t_938.(j_955)).(j_957) <-
               ((t_938.(j_955)).(j_957) -.
                 ((t_956 /. i_954) *. (t_938.(t_945)).(j_957)))
             done;
             (t_944.(j_955)).(t_946) <- (t_956 /. i_954);
             (t_938.(j_955)).(t_946) <- 0.
            end
           done;
           ()
          end;
          (t_935 := ((! t_935) + 1))
       | None -> ());
      (t_936 := ((! t_936) + 1))
     done;
     (t_938, t_944, (! t_941))>.
val resFA32 : ('a, GAC_F.contr -> GenFA32.O.res) code =
  .<fun a_958 ->
     let t_959 = (ref 0) in
     let t_960 = (ref 0) in
     let t_962 =
      (Array.map (fun x_961 -> (Array.copy x_961)) (Array.copy a_958)) in
     let t_963 = (Array.length a_958.(0)) in
     let t_964 = (Array.length a_958) in
     let t_965 = (ref ([])) in
     while (((! t_960) < t_963) && ((! t_959) < t_964)) do
      let t_966 = (! t_959) in
      let t_967 = (! t_960) in
      let t_968 = (ref (None)) in
      let t_974 =
       begin
        for j_971 = t_966 to (t_964 - 1) do
         let t_972 = (t_962.(j_971)).(t_967) in
         if (t_972 <> 0.) then
          (match (! t_968) with
           | Some (i_973) ->
              if ((abs_float (snd i_973)) < (abs_float t_972)) then
               (t_968 := (Some (j_971, t_972)))
           | None -> (t_968 := (Some (j_971, t_972))))
        done;
        (match (! t_968) with
         | Some (i_969) ->
            if ((fst i_969) <> t_966) then begin
             let t_970 = t_962.(t_966) in
             t_962.(t_966) <- t_962.(fst i_969);
             t_962.(fst i_969) <- t_970;
             (t_965 := ((RowSwap ((fst i_969), t_966)) :: (! t_965)))
            end;
            (Some (snd i_969))
         | None -> (None))
       end in
      (match t_974 with
       | Some (i_975) ->
          begin
           for j_976 = (t_966 + 1) to (t_964 - 1) do
            let t_977 = (t_962.(j_976)).(t_967) in
            if (t_977 <> 0.) then
             for j_978 = (t_967 + 1) to (t_963 - 1) do
              (t_962.(j_976)).(j_978) <-
               ((t_962.(j_976)).(j_978) -.
                 ((t_977 /. i_975) *. (t_962.(t_966)).(j_978)))
             done
           done;
           ()
          end;
          (t_959 := ((! t_959) + 1))
       | None -> ());
      (t_960 := ((! t_960) + 1))
     done;
     (t_962, (! t_965))>.
val resZp3 : ('a, GVC_Z3.contr -> GenZp3.O.res) code =
  .<fun a_979 ->
     let t_980 = (ref 0) in
     let t_981 = (ref 0) in
     let t_982 = {arr = (Array.copy a_979.arr)} (a_979) in
     let t_983 = a_979.m in
     let t_984 = a_979.n in
     let t_985 = (ref 1) in
     let t_986 = (ref 1) in
     let t_987 = (ref ([])) in
     while (((! t_981) < t_983) && ((! t_980) < t_984)) do
      let t_992 = (! t_980) in
      let t_993 = (! t_981) in
      let t_994 = (ref (None)) in
      let t_1006 =
       begin
        let t_1002 = (t_982.arr).((t_993 * t_982.m) + t_992) in
        if (t_1002 <> 0) then (t_994 := (Some (t_992, t_1002)))
        else
         let rec loop_1003 =
          fun j_1004 ->
           if (j_1004 < t_984) then
            let t_1005 = (t_982.arr).((j_1004 * t_982.m) + t_993) in
            if (t_1005 = 0) then (loop_1003 (j_1004 + 1))
            else (t_994 := (Some (j_1004, t_1005))) in
         (loop_1003 (t_992 + 1));
        (match (! t_994) with
         | Some (i_995) ->
            if ((fst i_995) <> t_992) then begin
             begin
              let a_996 = t_982.arr
              and m_997 = t_982.m in
              let i1_998 = (t_992 * m_997)
              and i2_999 = ((fst i_995) * m_997) in
              for i_1000 = t_993 to (m_997 - 1) do
               let t_1001 = a_996.(i1_998 + i_1000) in
               a_996.(i1_998 + i_1000) <- a_996.(i2_999 + i_1000);
               a_996.(i2_999 + i_1000) <- t_1001
              done;
              (t_986 := (~- (! t_986)))
             end;
             (t_987 := ((RowSwap ((fst i_995), t_992)) :: (! t_987)))
            end;
            (Some (snd i_995))
         | None -> (None))
       end in
      (match t_1006 with
       | Some (i_1007) ->
          begin
           for j_1008 = (t_992 + 1) to (t_984 - 1) do
            let t_1009 = (t_982.arr).((j_1008 * t_982.m) + t_993) in
            if (t_1009 <> 0) then begin
             for j_1010 = (t_993 + 1) to (t_983 - 1) do
              (t_982.arr).((j_1008 * t_982.m) + j_1010) <-
               (((* cross-stage persistent value (as id: minus) *))
                 (t_982.arr).((j_1008 * t_982.m) + j_1010)
                 (((* cross-stage persistent value (as id: times) *))
                   (((* cross-stage persistent value (as id: div) *)) t_1009
                     i_1007) (t_982.arr).((t_992 * t_982.m) + j_1010)))
             done;
             (t_982.arr).((j_1008 * t_982.m) + t_993) <- 0
            end
           done;
           (t_985 :=
             (((* cross-stage persistent value (as id: times) *)) (! t_985)
               i_1007))
          end;
          (t_980 := ((! t_980) + 1))
       | None -> (t_986 := 0));
      (t_981 := ((! t_981) + 1))
     done;
     (t_982,
      if ((! t_986) = 0) then 0
      else if ((! t_986) = 1) then (! t_985)
      else (((* cross-stage persistent value (as id: uminus) *)) (! t_985)),
      (! t_980), (! t_987))>.
val resZp19 : ('a, GVC_Z19.contr -> GenZp19.O.res) code =
  .<fun a_1011 ->
     let t_1012 = (ref 0) in
     let t_1013 = (ref 0) in
     let t_1014 = {arr = (Array.copy a_1011.arr)} (a_1011) in
     let t_1015 = a_1011.m in
     let t_1016 = a_1011.n in
     let t_1017 = (ref 1) in
     let t_1018 = (ref 1) in
     let t_1019 = (ref ([])) in
     while (((! t_1013) < t_1015) && ((! t_1012) < t_1016)) do
      let t_1024 = (! t_1012) in
      let t_1025 = (! t_1013) in
      let t_1026 = (ref (None)) in
      let t_1038 =
       begin
        let t_1034 = (t_1014.arr).((t_1025 * t_1014.m) + t_1024) in
        if (t_1034 <> 0) then (t_1026 := (Some (t_1024, t_1034)))
        else
         let rec loop_1035 =
          fun j_1036 ->
           if (j_1036 < t_1016) then
            let t_1037 = (t_1014.arr).((j_1036 * t_1014.m) + t_1025) in
            if (t_1037 = 0) then (loop_1035 (j_1036 + 1))
            else (t_1026 := (Some (j_1036, t_1037))) in
         (loop_1035 (t_1024 + 1));
        (match (! t_1026) with
         | Some (i_1027) ->
            if ((fst i_1027) <> t_1024) then begin
             begin
              let a_1028 = t_1014.arr
              and m_1029 = t_1014.m in
              let i1_1030 = (t_1024 * m_1029)
              and i2_1031 = ((fst i_1027) * m_1029) in
              for i_1032 = t_1025 to (m_1029 - 1) do
               let t_1033 = a_1028.(i1_1030 + i_1032) in
               a_1028.(i1_1030 + i_1032) <- a_1028.(i2_1031 + i_1032);
               a_1028.(i2_1031 + i_1032) <- t_1033
              done;
              (t_1018 := (~- (! t_1018)))
             end;
             (t_1019 := ((RowSwap ((fst i_1027), t_1024)) :: (! t_1019)))
            end;
            (Some (snd i_1027))
         | None -> (None))
       end in
      (match t_1038 with
       | Some (i_1039) ->
          begin
           for j_1040 = (t_1024 + 1) to (t_1016 - 1) do
            let t_1041 = (t_1014.arr).((j_1040 * t_1014.m) + t_1025) in
            if (t_1041 <> 0) then begin
             for j_1042 = (t_1025 + 1) to (t_1015 - 1) do
              (t_1014.arr).((j_1040 * t_1014.m) + j_1042) <-
               (((* cross-stage persistent value (as id: div) *))
                 (((* cross-stage persistent value (as id: minus) *))
                   (((* cross-stage persistent value (as id: times) *))
                     (t_1014.arr).((j_1040 * t_1014.m) + j_1042) i_1039)
                   (((* cross-stage persistent value (as id: times) *))
                     (t_1014.arr).((t_1024 * t_1014.m) + j_1042) t_1041))
                 (! t_1017))
             done;
             (t_1014.arr).((j_1040 * t_1014.m) + t_1025) <- 0
            end
           done;
           (t_1017 := i_1039)
          end;
          (t_1012 := ((! t_1012) + 1))
       | None -> (t_1018 := 0));
      (t_1013 := ((! t_1013) + 1))
     done;
     (t_1014,
      if ((! t_1018) = 0) then 0
      else if ((! t_1018) = 1) then (! t_1017)
      else (((* cross-stage persistent value (as id: uminus) *)) (! t_1017)),
      (! t_1012), (! t_1019))>.
val rFA1 : GAC_F.contr -> GenFA1.O.res = <fun>
val rFA2 :
  Domains_code.FloatDomainL.v array array ->
  Domains_code.FloatDomainL.v array array * Domains_code.FloatDomainL.v =
  <fun>
val rFA3 :
  Domains_code.FloatDomainL.v array array ->
  Domains_code.FloatDomainL.v array array * int = <fun>
val rFA4 :
  Domains_code.FloatDomainL.v array array ->
  Domains_code.FloatDomainL.v array array * Domains_code.FloatDomainL.v * int =
  <fun>
val rFV1 :
  Domains_code.FloatDomainL.v Domains_code.container2dfromvector ->
  Domains_code.FloatDomainL.v Domains_code.container2dfromvector = <fun>
val rFV2 :
  Domains_code.FloatDomainL.v Domains_code.container2dfromvector ->
  Domains_code.FloatDomainL.v Domains_code.container2dfromvector *
  Domains_code.FloatDomainL.v = <fun>
val rFV3 : GVC_F.contr -> GVC_F.contr * int = <fun>
val rFV4 : GVC_F.contr -> GVC_F.contr * GVC_F.Dom.v * int = <fun>
val rFV5 : GVC_F.contr -> GVC_F.contr * GVC_F.Dom.v * int = <fun>
val rIA1 : GAC_I.contr -> GAC_I.contr = <fun>
val rIA2 : GAC_I.contr -> GAC_I.contr * GAC_I.Dom.v = <fun>
val rIA3 : GAC_I.contr -> GAC_I.contr * int = <fun>
val rIA4 : GAC_I.contr -> GAC_I.contr * GAC_I.Dom.v * int = <fun>
val rIV1 : GVC_I.contr -> GVC_I.contr = <fun>
val rIV2 : GVC_I.contr -> GVC_I.contr * GVC_I.Dom.v = <fun>
val rIV3 : GVC_I.contr -> GVC_I.contr * int = <fun>
val rIV4 : GVC_I.contr -> GVC_I.contr * GVC_I.Dom.v * int = <fun>
val rIV5 : GVC_I.contr -> GVC_I.contr * GVC_I.Dom.v * int = <fun>
val rIV6 : GVC_I.contr -> GVC_I.contr * GVC_I.Dom.v * int * Code.perm list =
  <fun>
val rFA11 : GAC_F.contr -> GAC_F.contr = <fun>
val rFA12 : GAC_F.contr -> GAC_F.contr * GAC_F.Dom.v = <fun>
val rFA13 : GAC_F.contr -> GAC_F.contr * int = <fun>
val rFA14 : GAC_F.contr -> GAC_F.contr * GAC_F.Dom.v * int = <fun>
val rFA24 : GAC_F.contr -> GAC_F.contr * GAC_F.Dom.v * int * Code.perm list =
  <fun>
val rFA25 : GAC_F.contr -> GAC_F.contr * GAC_F.Dom.v * int * int array =
  <fun>
val rFA26 : GAC_F.contr -> GAC_F.contr = <fun>
val rRA1 : GAC_R.contr -> GAC_R.contr = <fun>
val rRA2 : GAC_R.contr -> GAC_R.contr * GAC_R.Dom.v = <fun>
val rRA3 : GAC_R.contr -> GAC_R.contr * int = <fun>
val rRA4 : GAC_R.contr -> GAC_R.contr * GAC_R.Dom.v * int = <fun>
val rFA5 : GAC_F.contr * int -> GAC_F.contr = <fun>
val rFA6 : GAC_F.contr * int -> GAC_F.contr * GAC_F.Dom.v = <fun>
val rFA7 : GAC_F.contr * int -> GAC_F.contr * int = <fun>
val rFA8 : GAC_F.contr * int -> GAC_F.contr * GAC_F.Dom.v * int = <fun>
val rFA9 : GAC_F.contr -> GAC_F.contr * Code.perm list = <fun>
val rFA31 : GAC_F.contr -> GAC_F.contr * GAC_F.contr * Code.perm list = <fun>
val rFA32 : GAC_F.contr -> GAC_F.contr * Code.perm list = <fun>
val rZp3 : GVC_Z3.contr -> GVC_Z3.contr * GVC_Z3.Dom.v * int * Code.perm list =
  <fun>
val rZp19 :
  GVC_Z19.contr -> GVC_Z19.contr * GVC_Z19.Dom.v * int * Code.perm list =
  <fun>
val ia0 : int array array = [|[|1|]|]
val ia1 : int array array = [|[|1; 2; 3|]; [|4; 13; 5|]; [|-1; 3; 0|]|]
val ia2 : int array array =
  [|[|1; 2; 3; 0|]; [|4; 13; 5; 0|]; [|-1; 3; 0; 0|]|]
val ia3 : int array array =
  [|[|1; 2; 3|]; [|4; 13; 5|]; [|-1; 3; 0|]; [|0; 0; 0|]|]
val ia4 : int array array = [|[|0; 2; 3|]; [|0; 13; 5|]; [|0; 3; 0|]|]
val ia5 : int array array list =
  [[|[|1|]|]; [|[|1; 2; 3|]; [|4; 13; 5|]; [|-1; 3; 0|]|];
   [|[|1; 2; 3; 0|]; [|4; 13; 5; 0|]; [|-1; 3; 0; 0|]|];
   [|[|1; 2; 3|]; [|4; 13; 5|]; [|-1; 3; 0|]; [|0; 0; 0|]|];
   [|[|0; 2; 3|]; [|0; 13; 5|]; [|0; 3; 0|]|]]
val resI11 : GAC_I.contr list =
  [[|[|1|]|]; [|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]|];
   [|[|1; 2; 3; 0|]; [|0; 5; -7; 0|]; [|0; 0; 50; 0|]|];
   [|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]; [|0; 0; 0|]|];
   [|[|0; 2; 3|]; [|0; 0; -9|]; [|0; 0; 0|]|]]
val resI12 : (GAC_I.contr * GAC_I.Dom.v) list =
  [([|[|1|]|], 1); ([|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]|], 50);
   ([|[|1; 2; 3; 0|]; [|0; 5; -7; 0|]; [|0; 0; 50; 0|]|], 50);
   ([|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]; [|0; 0; 0|]|], 50);
   ([|[|0; 2; 3|]; [|0; 0; -9|]; [|0; 0; 0|]|], 0)]
val resI13 : (GAC_I.contr * int) list =
  [([|[|1|]|], 1); ([|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]|], 3);
   ([|[|1; 2; 3; 0|]; [|0; 5; -7; 0|]; [|0; 0; 50; 0|]|], 3);
   ([|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]; [|0; 0; 0|]|], 3);
   ([|[|0; 2; 3|]; [|0; 0; -9|]; [|0; 0; 0|]|], 2)]
val resI14 : (GAC_I.contr * GAC_I.Dom.v * int) list =
  [([|[|1|]|], 1, 1); ([|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]|], 50, 3);
   ([|[|1; 2; 3; 0|]; [|0; 5; -7; 0|]; [|0; 0; 50; 0|]|], 50, 3);
   ([|[|1; 2; 3|]; [|0; 5; -7|]; [|0; 0; 50|]; [|0; 0; 0|]|], 50, 3);
   ([|[|0; 2; 3|]; [|0; 0; -9|]; [|0; 0; 0|]|], 0, 2)]
val iv0 : int Domains_code.container2dfromvector =
  {arr = [|1|]; n = 1; m = 1}
val iv1 : int Domains_code.container2dfromvector =
  {arr = [|1; 2; 3; 4; 13; 5; -1; 3; 0|]; n = 3; m = 3}
val iv2 : int Domains_code.container2dfromvector =
  {arr = [|1; 2; 3; 0; 4; 13; 5; 0; -1; 3; 0; 0|]; n = 3; m = 4}
val iv4 : int Domains_code.container2dfromvector =
  {arr = [|0; 2; 3; 0; 13; 5; 0; 3; 0|]; n = 3; m = 3}
val iv5 : int Domains_code.container2dfromvector list =
  [{arr = [|1|]; n = 1; m = 1};
   {arr = [|1; 2; 3; 4; 13; 5; -1; 3; 0|]; n = 3; m = 3};
   {arr = [|1; 2; 3; 0; 4; 13; 5; 0; -1; 3; 0; 0|]; n = 3; m = 4};
   {arr = [|0; 2; 3; 0; 13; 5; 0; 3; 0|]; n = 3; m = 3}]
val resI21 : GVC_I.contr list =
  [{arr = [|1|]; n = 1; m = 1};
   {arr = [|1; 2; 3; 0; 5; -7; 0; 0; 50|]; n = 3; m = 3};
   {arr = [|1; 2; 3; 0; 0; 5; -7; 0; 0; 0; 50; 0|]; n = 3; m = 4};
   {arr = [|0; 2; 3; 0; 0; -9; 0; 0; 0|]; n = 3; m = 3}]
val resI22 : (GVC_I.contr * GVC_I.Dom.v) list =
  [({arr = [|1|]; n = 1; m = 1}, 1);
   ({arr = [|1; 2; 3; 0; 5; -7; 0; 0; 50|]; n = 3; m = 3}, 50);
   ({arr = [|1; 2; 3; 0; 0; 5; -7; 0; 0; 0; 50; 0|]; n = 3; m = 4}, 50);
   ({arr = [|0; 2; 3; 0; 0; -9; 0; 0; 0|]; n = 3; m = 3}, 0)]
val resI23 : (GVC_I.contr * int) list =
  [({arr = [|1|]; n = 1; m = 1}, 1);
   ({arr = [|1; 2; 3; 0; 5; -7; 0; 0; 50|]; n = 3; m = 3}, 3);
   ({arr = [|1; 2; 3; 0; 0; 5; -7; 0; 0; 0; 50; 0|]; n = 3; m = 4}, 3);
   ({arr = [|0; 2; 3; 0; 0; -9; 0; 0; 0|]; n = 3; m = 3}, 2)]
val resI24 : (GVC_I.contr * GVC_I.Dom.v * int) list =
  [({arr = [|1|]; n = 1; m = 1}, 1, 1);
   ({arr = [|1; 2; 3; 0; 5; -7; 0; 0; 50|]; n = 3; m = 3}, 50, 3);
   ({arr = [|1; 2; 3; 0; 0; 5; -7; 0; 0; 0; 50; 0|]; n = 3; m = 4}, 50, 3);
   ({arr = [|0; 2; 3; 0; 0; -9; 0; 0; 0|]; n = 3; m = 3}, 0, 2)]
val resI25 : (GVC_I.contr * GVC_I.Dom.v * int) list =
  [({arr = [|1|]; n = 1; m = 1}, 1, 1);
   ({arr = [|1; 3; 2; 0; 3; 5; 0; 0; 50|]; n = 3; m = 3}, 50, 3);
   ({arr = [|1; 3; 2; 0; 0; 3; 5; 0; 0; 0; 50; 0|]; n = 3; m = 4}, 50, 3);
   ({arr = [|2; 3; 0; 0; -9; 0; 0; 0; 0|]; n = 3; m = 3}, 0, 2)]
val resI26 : (GVC_I.contr * GVC_I.Dom.v * int * Code.perm list) list =
  [({arr = [|1|]; n = 1; m = 1}, 1, 1, []);
   ({arr = [|1; 3; 2; 0; 3; 5; 0; 0; 50|]; n = 3; m = 3}, 50, 3,
    [Code.RowSwap (2, 1); Code.ColSwap (2, 1)]);
   ({arr = [|1; 3; 2; 0; 0; 3; 5; 0; 0; 0; 50; 0|]; n = 3; m = 4}, 50, 3,
    [Code.RowSwap (2, 1); Code.ColSwap (2, 1)]);
   ({arr = [|2; 3; 0; 0; -9; 0; 0; 0; 0|]; n = 3; m = 3}, 0, 2,
    [Code.RowSwap (2, 1); Code.ColSwap (2, 1); Code.ColSwap (1, 0)])]
val fa0 : float array array = [|[|1.|]|]
val fa1 : float array array =
  [|[|1.; 2.; 3.|]; [|4.; 13.; 5.|]; [|-1.; 3.; 0.|]|]
val fa2 : float array array =
  [|[|1.; 2.; 3.; 0.|]; [|4.; 13.; 5.; 0.|]; [|-1.; 3.; 0.; 0.|]|]
val fa3 : float array array =
  [|[|1.; 2.; 3.|]; [|4.; 13.; 5.|]; [|-1.; 3.; 0.|]; [|0.; 0.; 0.|]|]
val fa4 : float array array =
  [|[|0.; 2.; 3.|]; [|0.; 10.; 5.|]; [|0.; 3.; 0.|]|]
val fa5 : float array array list =
  [[|[|1.|]|]; [|[|1.; 2.; 3.|]; [|4.; 13.; 5.|]; [|-1.; 3.; 0.|]|];
   [|[|1.; 2.; 3.; 0.|]; [|4.; 13.; 5.; 0.|]; [|-1.; 3.; 0.; 0.|]|];
   [|[|1.; 2.; 3.|]; [|4.; 13.; 5.|]; [|-1.; 3.; 0.|]; [|0.; 0.; 0.|]|];
   [|[|0.; 2.; 3.|]; [|0.; 10.; 5.|]; [|0.; 3.; 0.|]|]]
val fa6 : float array array = [|[|1.; 1.|]|]
val fa7 : float array array =
  [|[|1.; 2.; 3.; 1.; 0.; 0.|]; [|4.; 13.; 5.; 0.; 1.; 0.|];
    [|-1.; 3.; 0.; 0.; 0.; 1.|]|]
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
- : unit = ()
val resFA9 : GAC_F.contr * Code.perm list =
  ([|[|4.; 13.; 5.|]; [|-1.; 6.25; 1.25|]; [|1.; -1.25; 2.|]|],
   [Code.RowSwap (2, 1); Code.RowSwap (1, 0)])
- : unit = ()
- : unit = ()
- : unit = ()
val resF1 : GAC_F.contr list =
  [[|[|1.|]|]; [|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]|];
   [|[|4.; 13.; 5.; 0.|]; [|0.; 6.25; 1.25; 0.|]; [|0.; 0.; 2.; 0.|]|];
   [|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|];
   [|[|0.; 10.; 5.|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|]]
- : unit = ()
- : unit = ()
- : unit = ()
val resFA31 : (GAC_F.contr * GAC_F.contr * Code.perm list) list =
  [([|[|1.|]|], [|[|1.|]|], []);
   ([|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]|],
    [|[|1.; 0.; 0.|]; [|0.25; 1.; 0.|]; [|-0.25; -0.2; 1.|]|],
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|4.; 13.; 5.; 0.|]; [|0.; 6.25; 1.25; 0.|]; [|0.; 0.; 2.; 0.|]|],
    [|[|1.; 0.; 0.; 0.|]; [|0.25; 1.; 0.; 0.|]; [|-0.25; -0.2; 1.; 0.|]|],
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|],
    [|[|1.; 0.; 0.|]; [|0.25; 1.; 0.|]; [|-0.25; -0.2; 1.|]; [|0.; 0.; 0.|]|],
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|0.; 10.; 5.|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|],
    [|[|1.; 0.; 0.|]; [|0.; 0.2; 0.|]; [|0.; 0.3; -0.75|]|],
    [Code.RowSwap (1, 0)])]
val resFA32 : (GAC_F.contr * Code.perm list) list =
  [([|[|1.|]|], []);
   ([|[|4.; 13.; 5.|]; [|-1.; 6.25; 1.25|]; [|1.; -1.25; 2.|]|],
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|4.; 13.; 5.; 0.|]; [|-1.; 6.25; 1.25; 0.|]; [|1.; -1.25; 2.; 0.|]|],
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|4.; 13.; 5.|]; [|-1.; 6.25; 1.25|]; [|1.; -1.25; 2.|];
      [|0.; 0.; 0.|]|],
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|0.; 10.; 5.|]; [|0.; 2.; 2.|]; [|0.; 3.; -1.5|]|],
    [Code.RowSwap (1, 0)])]
val a2v : 'a array array -> 'a Domains_code.container2dfromvector = <fun>
val xxx : Domains_code.FloatDomainL.v Domains_code.container2dfromvector list =
  [{arr = [|1.|]; n = 1; m = 1};
   {arr = [|1.; 2.; 3.; 4.; 13.; 5.; -1.; 3.; 0.|]; n = 3; m = 3};
   {arr = [|1.; 2.; 3.; 0.; 4.; 13.; 5.; 0.; -1.; 3.; 0.; 0.|]; n = 3; m = 4};
   {arr = [|1.; 2.; 3.; 4.; 13.; 5.; -1.; 3.; 0.; 0.; 0.; 0.|]; n = 4; m = 3};
   {arr = [|0.; 2.; 3.; 0.; 10.; 5.; 0.; 3.; 0.|]; n = 3; m = 3}]
- : unit = ()
val resFV5 : (GVC_F.contr * GVC_F.Dom.v * int) list =
  [({arr = [|1.|]; n = 1; m = 1}, 1., 1);
   ({arr =
      [|13.; 5.; 4.; 0.; 2.23076923076923084; 0.384615384615384581; 0.; 0.;
        -1.72413793103448287|];
     n = 3; m = 3},
    50., 3);
   ({arr =
      [|13.; 5.; 4.; 0.; 0.; 2.23076923076923084; 0.384615384615384581; 0.;
        0.; 0.; -1.72413793103448287; 0.|];
     n = 3; m = 4},
    50., 3);
   ({arr =
      [|13.; 5.; 4.; 0.; 2.23076923076923084; 0.384615384615384581; 0.; 0.;
        -1.72413793103448287; 0.; 0.; 0.|];
     n = 4; m = 3},
    50., 3);
   ({arr = [|10.; 5.; 0.; 0.; 2.; 0.; 0.; 0.; 0.|]; n = 3; m = 3}, 0., 2)]
val resF11 : GAC_F.contr list =
  [[|[|1.|]|];
   [|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
     [|0.; 0.; -1.72413793103448287|]|];
   [|[|13.; 5.; 4.; 0.|];
     [|0.; 2.23076923076923084; 0.384615384615384581; 0.|];
     [|0.; 0.; -1.72413793103448287; 0.|]|];
   [|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
     [|0.; 0.; -1.72413793103448287|]; [|0.; 0.; 0.|]|];
   [|[|10.; 5.; 0.|]; [|0.; 2.; 0.|]; [|0.; 0.; 0.|]|]]
val resF12 : (GAC_F.contr * GAC_F.Dom.v) list =
  [([|[|1.|]|], 1.);
   ([|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
      [|0.; 0.; -1.72413793103448287|]|],
    50.);
   ([|[|13.; 5.; 4.; 0.|];
      [|0.; 2.23076923076923084; 0.384615384615384581; 0.|];
      [|0.; 0.; -1.72413793103448287; 0.|]|],
    50.);
   ([|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
      [|0.; 0.; -1.72413793103448287|]; [|0.; 0.; 0.|]|],
    50.);
   ([|[|10.; 5.; 0.|]; [|0.; 2.; 0.|]; [|0.; 0.; 0.|]|], 0.)]
val resF13 : (GAC_F.contr * int) list =
  [([|[|1.|]|], 1);
   ([|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
      [|0.; 0.; -1.72413793103448287|]|],
    3);
   ([|[|13.; 5.; 4.; 0.|];
      [|0.; 2.23076923076923084; 0.384615384615384581; 0.|];
      [|0.; 0.; -1.72413793103448287; 0.|]|],
    3);
   ([|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
      [|0.; 0.; -1.72413793103448287|]; [|0.; 0.; 0.|]|],
    3);
   ([|[|10.; 5.; 0.|]; [|0.; 2.; 0.|]; [|0.; 0.; 0.|]|], 2)]
val resF14 : (GAC_F.contr * GAC_F.Dom.v * int) list =
  [([|[|1.|]|], 1., 1);
   ([|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
      [|0.; 0.; -1.72413793103448287|]|],
    50., 3);
   ([|[|13.; 5.; 4.; 0.|];
      [|0.; 2.23076923076923084; 0.384615384615384581; 0.|];
      [|0.; 0.; -1.72413793103448287; 0.|]|],
    50., 3);
   ([|[|13.; 5.; 4.|]; [|0.; 2.23076923076923084; 0.384615384615384581|];
      [|0.; 0.; -1.72413793103448287|]; [|0.; 0.; 0.|]|],
    50., 3);
   ([|[|10.; 5.; 0.|]; [|0.; 2.; 0.|]; [|0.; 0.; 0.|]|], 0., 2)]
val resF24 : (GAC_F.contr * GAC_F.Dom.v * int * Code.perm list) list =
  [([|[|1.|]|], 1., 1, []);
   ([|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]|], 50., 3,
    [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|4.; 13.; 5.; 0.|]; [|0.; 6.25; 1.25; 0.|]; [|0.; 0.; 2.; 0.|]|], 50.,
    3, [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|],
    50., 3, [Code.RowSwap (2, 1); Code.RowSwap (1, 0)]);
   ([|[|0.; 10.; 5.|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|], 0., 2,
    [Code.RowSwap (1, 0)])]
val resF25 : (GAC_F.contr * GAC_F.Dom.v * int * int array) list =
  [([|[|1.|]|], 1., 1, [|0|]);
   ([|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]|], 50., 3,
    [|1; 2; 0|]);
   ([|[|4.; 13.; 5.; 0.|]; [|0.; 6.25; 1.25; 0.|]; [|0.; 0.; 2.; 0.|]|], 50.,
    3, [|1; 2; 0|]);
   ([|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|],
    50., 3, [|1; 2; 0; 3|]);
   ([|[|0.; 10.; 5.|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|], 0., 2, [|1; 0; 2|])]
val resF26 : GAC_F.contr list =
  [[|[|1.|]|]; [|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]|];
   [|[|4.; 13.; 5.; 0.|]; [|0.; 6.25; 1.25; 0.|]; [|0.; 0.; 2.; 0.|]|];
   [|[|4.; 13.; 5.|]; [|0.; 6.25; 1.25|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|];
   [|[|0.; 10.; 5.|]; [|0.; 0.; 2.|]; [|0.; 0.; 0.|]|]]
val ra0 : Num.num array array = [|[|Num.Int 1|]|]
val ra1 : Num.num array array =
  [|[|Num.Int 1; Num.Int 2; Num.Int 3|];
    [|Num.Int 4; Num.Int 13; Num.Int 5|];
    [|Num.Int (-1); Num.Int 3; Num.Int 0|]|]
val ra2 : Num.num array array =
  [|[|Num.Int 1; Num.Int 2; Num.Int 3; Num.Int 0|];
    [|Num.Int 4; Num.Int 13; Num.Int 5; Num.Int 0|];
    [|Num.Int (-1); Num.Int 3; Num.Int 0; Num.Int 0|]|]
val ra3 : Num.num array array =
  [|[|Num.Int 1; Num.Int 2; Num.Int 3|];
    [|Num.Int 4; Num.Int 13; Num.Int 5|];
    [|Num.Int (-1); Num.Int 3; Num.Int 0|];
    [|Num.Int 0; Num.Int 0; Num.Int 0|]|]
val ra4 : Num.num array array =
  [|[|Num.Int 0; Num.Int 2; Num.Int 3|];
    [|Num.Int 0; Num.Int 13; Num.Int 5|];
    [|Num.Int 0; Num.Int 3; Num.Int 0|]|]
val ra5 : Num.num array array list =
  [[|[|Num.Int 1|]|];
   [|[|Num.Int 1; Num.Int 2; Num.Int 3|];
     [|Num.Int 4; Num.Int 13; Num.Int 5|];
     [|Num.Int (-1); Num.Int 3; Num.Int 0|]|];
   [|[|Num.Int 1; Num.Int 2; Num.Int 3; Num.Int 0|];
     [|Num.Int 4; Num.Int 13; Num.Int 5; Num.Int 0|];
     [|Num.Int (-1); Num.Int 3; Num.Int 0; Num.Int 0|]|];
   [|[|Num.Int 1; Num.Int 2; Num.Int 3|];
     [|Num.Int 4; Num.Int 13; Num.Int 5|];
     [|Num.Int (-1); Num.Int 3; Num.Int 0|];
     [|Num.Int 0; Num.Int 0; Num.Int 0|]|];
   [|[|Num.Int 0; Num.Int 2; Num.Int 3|];
     [|Num.Int 0; Num.Int 13; Num.Int 5|];
     [|Num.Int 0; Num.Int 3; Num.Int 0|]|]]
val resR11 : GAC_R.contr list =
  [[|[|Num.Int 1|]|];
   [|[|Num.Int 1; Num.Int 2; Num.Int 3|];
     [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
     [|Num.Int 0; Num.Int 0; Num.Int 10|]|];
   [|[|Num.Int 1; Num.Int 2; Num.Int 3; Num.Int 0|];
     [|Num.Int 0; Num.Int 5; Num.Int (-7); Num.Int 0|];
     [|Num.Int 0; Num.Int 0; Num.Int 10; Num.Int 0|]|];
   [|[|Num.Int 1; Num.Int 2; Num.Int 3|];
     [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
     [|Num.Int 0; Num.Int 0; Num.Int 10|];
     [|Num.Int 0; Num.Int 0; Num.Int 0|]|];
   [|[|Num.Int 0; Num.Int 2; Num.Int 3|];
     [|Num.Int 0; Num.Int 0; Num.Ratio <abstr>|];
     [|Num.Int 0; Num.Int 0; Num.Int 0|]|]]
val resR12 : (GAC_R.contr * GAC_R.Dom.v) list =
  [([|[|Num.Int 1|]|], Num.Int 1);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
      [|Num.Int 0; Num.Int 0; Num.Int 10|]|],
    Num.Int 50);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3; Num.Int 0|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7); Num.Int 0|];
      [|Num.Int 0; Num.Int 0; Num.Int 10; Num.Int 0|]|],
    Num.Int 50);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
      [|Num.Int 0; Num.Int 0; Num.Int 10|];
      [|Num.Int 0; Num.Int 0; Num.Int 0|]|],
    Num.Int 50);
   ([|[|Num.Int 0; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 0; Num.Ratio <abstr>|];
      [|Num.Int 0; Num.Int 0; Num.Int 0|]|],
    Num.Int 0)]
val resR13 : (GAC_R.contr * int) list =
  [([|[|Num.Int 1|]|], 1);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
      [|Num.Int 0; Num.Int 0; Num.Int 10|]|],
    3);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3; Num.Int 0|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7); Num.Int 0|];
      [|Num.Int 0; Num.Int 0; Num.Int 10; Num.Int 0|]|],
    3);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
      [|Num.Int 0; Num.Int 0; Num.Int 10|];
      [|Num.Int 0; Num.Int 0; Num.Int 0|]|],
    3);
   ([|[|Num.Int 0; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 0; Num.Ratio <abstr>|];
      [|Num.Int 0; Num.Int 0; Num.Int 0|]|],
    2)]
val resR14 : (GAC_R.contr * GAC_R.Dom.v * int) list =
  [([|[|Num.Int 1|]|], Num.Int 1, 1);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
      [|Num.Int 0; Num.Int 0; Num.Int 10|]|],
    Num.Int 50, 3);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3; Num.Int 0|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7); Num.Int 0|];
      [|Num.Int 0; Num.Int 0; Num.Int 10; Num.Int 0|]|],
    Num.Int 50, 3);
   ([|[|Num.Int 1; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 5; Num.Int (-7)|];
      [|Num.Int 0; Num.Int 0; Num.Int 10|];
      [|Num.Int 0; Num.Int 0; Num.Int 0|]|],
    Num.Int 50, 3);
   ([|[|Num.Int 0; Num.Int 2; Num.Int 3|];
      [|Num.Int 0; Num.Int 0; Num.Ratio <abstr>|];
      [|Num.Int 0; Num.Int 0; Num.Int 0|]|],
    Num.Int 0, 2)]
# 
